<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[淘淘商城软件安装(三)-fastdfs]]></title>
    <url>%2F2018%2F06%2F06%2F%E6%B7%98%E6%B7%98%E5%95%86%E5%9F%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-%E4%B8%89-fastdfs%2F</url>
    <content type="text"><![CDATA[1.FastDFS简介FastDFS是用c语言编写的一款开源的分布式文件系统。FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。 2.FastDFS架构FastDFS架构包括 Tracker server和Storage server。客户端请求Tracker server进行文件上传、下载，通过Tracker server调度最终由Storage server完成文件上传和下载。 ​ Tracker server作用是负载均衡和调度，通过Tracker server在文件上传时可以根据一些策略找到Storage server提供文件上传服务。可以将tracker称为追踪服务器或调度服务器。 ​ Storage server作用是文件存储，客户端上传的文件最终存储在Storage服务器上，Storage server没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将storage称为存储服务器。 2.1 Tracker集群FastDFS集群中的Tracker server可以有多台，Tracker server之间是相互平等关系同时提供服务，Tracker server不存在单点故障。客户端请求Tracker server采用轮询方式，如果请求的tracker无法提供服务则换另一个tracker。 2.2 Storage集群Storage集群采用了分组存储方式。storage集群由一个或多个组构成，集群存储总容量为集群中所有组的存储容量之和。一个组由一台或多台存储服务器组成，组内的Storage server之间是平等关系，不同组的Storage server之间不会相互通信，同组内的Storage server之间会相互连接进行文件同步，从而保证同组内每个storage上的文件完全一致的。一个组的存储容量为该组内存储服务器容量最小的那个，由此可见组内存储服务器的软硬件配置最好是一致的。 采用分组存储方式的好处是灵活、可控性较强。比如上传文件时，可以由客户端直接指定上传到的组也可以由tracker进行调度选择。一个分组的存储服务器访问压力较大时，可以在该组增加存储服务器来扩充服务能力（纵向扩容）。当系统容量不足时，可以增加组来扩充存储容量（横向扩容）。 2.3 Storage状态收集Storage server会连接集群中所有的Tracker server，定时向他们报告自己的状态，包括磁盘剩余空间、文件同步状况、文件上传下载次数等统计信息。 2.4 文件上传流程 客户端上传文件后存储服务器将文件ID返回给客户端，此文件ID用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名 组名：文件上传后所在的storage组名称，在文件上传成功后有storage服务器返回，需要客户端自行保存。 虚拟磁盘路径：storage配置的虚拟路径，与磁盘选项store_path*对应。如果配置了store_path0则是M00，如果配置了store_path1则是M01，以此类推。 数据两级目录：storage服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。 文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。 2.5 文件下载流程 tracker根据请求的文件路径即文件ID 来快速定义文件。 比如请求下边的文件： 通过组名tracker能够很快的定位到客户端需要访问的存储服务器组是group1，并选择合适的存储服务器提供客户端访问。 存储服务器根据“文件存储虚拟磁盘路径”和“数据文件两级目录”可以很快定位到文件所在目录，并根据文件名找到客户端需要访问的文件。 3.FastDFS+Nginx实现文件服务器3.1 下载tracker和storage使用相同的安装包，下载地址：http://sourceforge.net/projects/FastDFS/ 或https://github.com/happyfish100/FastDFS（推荐） 本教程下载：FastDFS_v5.05.tar.gz 3.2 FastDFS安装环境FastDFS是C语言开发，建议在linux上运行，本教程使用Centos6.4作为安装环境。 安装FastDFS需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc： 1yum install gcc-c++ FastDFS依赖libevent库，需要安装： 1yum -y install libevent libfastcommon是FastDFS官方提供的，libfastcommon包含了FastDFS运行所需要的一些基础库。 123456将libfastcommonV1.0.7.tar.gz拷贝至/usr/local/下cd /usr/localtar -zxvf libfastcommonV1.0.7.tar.gzcd libfastcommon-1.0.7./make.sh./make.sh install 注意：libfastcommon**安装好后会自动将库文件拷贝至/usr/lib64下，由于FastDFS程序引用usr/lib目录所以需要将/usr/lib64下的库文件拷贝至/usr/lib**下。 要拷贝的文件如下： 3.3 tracker编译安装将FastDFS_v5.05.tar.gz拷贝至/usr/local/下 1234tar -zxvf FastDFS_v5.05.tar.gz cd FastDFS./make.sh./make.sh install 安装成功将安装目录下的conf下的文件拷贝到/etc/fdfs/下。 3.4 配置安装成功后进入/etc/fdfs目录： 12345678拷贝一份新的tracker配置文件：cp tracker.conf.sample tracker.conf修改tracker.confvi tracker.confbase_path=/home/yuqing/FastDFS 改为：base_path=/home/FastDFS 3.5 启动usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart 启动的日志显示先停止5619进程（实际环境不是5619）再启动，如下图： 注意：如果没有显示上图要注意是否正常停止原有进程。 设置开机自动启动。 将运行命令行添加进文件：/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart 3.6 storage安装libevent 、libfastcommon 、同tracker安装编译 3.7 配置安装成功后进入/etc/fdfs目录： 1234567891011121314拷贝一份新的storage配置文件：cp storage.conf.sample storage.conf修改storage.confvi storage.confgroup_name=group1base_path=/home/yuqing/FastDFS改为：base_path=/home/FastDFSstore_path0=/home/yuqing/FastDFS改为：store_path0=/home/FastDFS/fdfs_storage#如果有多个挂载磁盘则定义多个store_path，如下#store_path1=.....#store_path2=......tracker_server=192.168.101.3:22122 #配置tracker服务器:IP#如果有多个则配置多个trackertracker_server=192.168.101.4:22122 3.8 启动/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart 启动的日志显示先停止8931进程（实际环境不是8931）再启动，如下图： 注意：如果没有显示上图要注意是否正常停止原有进程。 设置开机自动启动。 将运行命令行添加进文件：/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart 4.和nginx的整合将FastDFS-nginx-module_v1.16.tar.gz传至/usr/local/下 cd /usr/local tar -zxvf FastDFS-nginx-module_v1.16.tar.gz cd FastDFS-nginx-module/src 修改config文件将/usr/local/路径改为/usr/ 1234567891011121314151617将FastDFS-nginx-module/src下的mod_FastDFS.conf拷贝至/etc/fdfs/下cp mod_FastDFS.conf /etc/fdfs/并修改mod_FastDFS.conf的内容：vi /etc/fdfs/mod_FastDFS.confbase_path=/home/FastDFStracker_server=192.168.101.3:22122#tracker_server=192.168.101.4:22122（多个tracker配置多行）url_have_group_name=true #url中包含group名称store_path0=/home/FastDFS/fdfs_storage #指定文件存储路径将libfdfsclient.so拷贝至/usr/lib下cp /usr/lib64/libfdfsclient.so /usr/lib/创建nginx/client目录mkdir -p /var/temp/nginx/client 添加FastDFS-nginx-module模块 12345678910111213141516./configure \--prefix=/usr/local/nginx \--pid-path=/var/run/nginx/nginx.pid \--lock-path=/var/lock/nginx.lock \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--with-http_gzip_static_module \--http-client-body-temp-path=/var/temp/nginx/client \--http-proxy-temp-path=/var/temp/nginx/proxy \--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \--http-scgi-temp-path=/var/temp/nginx/scgi \--add-module=/root/fastdfs-nginx-module/srcmakemake install 新建一个nginx配置文件nginx-fdfs.conf. 添加server: 123456789server &#123; listen 80; server_name 192.168.101.3; location /group1/M00/&#123; #root /home/FastDFS/fdfs_storage/data; ngx_fastdfs_module; &#125;&#125; 说明： server_name指定本机ip location /group1/M00/：group1为nginx 服务FastDFS的分组名称，M00是FastDFS自动生成编号，对应store_path0=/home/FastDFS/fdfs_storage，如果FastDFS定义store_path1，这里就是M01 5.附录1 基本配置 disable #func：配置是否生效 #valu：true、false disable=false bind_addr #func：绑定IP #valu：IP地址 bind_addr=192.168.6.102 port #func：服务端口 #valu：端口整数值 port=22122 connect_timeout #func：连接超时 #valu：秒单位正整数值 connect_timeout=30 network_timeout #func：网络超时 #valu：秒单位正整数值 network_timeout=60 base_path #func：Tracker数据/日志目录地址 #valu：路径 base_path=/home/michael/fdfs/base4tracker max_connections #func：最大连接数 #valu：正整数值 max_connections=256 work_threads #func：线程数，通常设置CPU数 #valu：正整数值 work_threads=4 store_lookup #func：上传文件的选组方式。 #valu：0、1或2。 # 0：表示轮询 # 1：表示指定组 # 2：表示存储负载均衡（选择剩余空间最大的组） store_lookup=2 store_group #func：指定上传的组，如果在应用层指定了具体的组，那么这个参数将不会起效。另外如果store_lookup如果是0或2，则此参数无效。 #valu：group1等 store_group=group1 store_server #func：上传服务器的选择方式。(一个文件被上传后，这个storage server就相当于这个文件的storage server源，会对同组的storage server推送这个文件达到同步效果) #valu：0、1或2 # 0: 轮询方式（默认） # 1: 根据ip 地址进行排序选择第一个服务器（IP地址最小者） # 2: 根据优先级进行排序（上传优先级由storage server来设置，参数名为upload_priority），优先级值越小优先级越高。 store_server=0 store_path #func：上传路径的选择方式。storage server可以有多个存放文件的base path（可以理解为多个磁盘）。 #valu： # 0: 轮流方式，多个目录依次存放文件 # 2: 存储负载均衡。选择剩余空间最大的目录存放文件（注意：剩余磁盘空间是动态的，因此存储到的目录或磁盘可能也是变化的） store_path=0 download_server #func：下载服务器的选择方式。 #valu： # 0：轮询（默认） # 1：IP最小者 # 2：优先级排序（值最小的，优先级最高。） download_server=0 reserved_storage_space #func：保留空间值。如果某个组中的某个服务器的剩余自由空间小于设定值，则文件不会被上传到这个组。 #valu： # G or g for gigabyte # M or m for megabyte # K or k for kilobyte reserved_storage_space=1GB log_level #func：日志级别 #valu： # emerg for emergency # alert # crit for critical # error # warn for warning # notice # info for information # debug for debugging log_level=info run_by_group / run_by_user #func：指定运行该程序的用户组 #valu：用户组名或空 run_by_group= #func： #valu： run_by_user= allow_hosts #func：可以连接到tracker server的ip范围。可设定多个值。 #valu allow_hosts= check_active_interval #func：检测 storage server 存活的时间隔，单位为秒。 # storage server定期向tracker server 发心跳， # 如果tracker server在一个check_active_interval内还没有收到storage server的一次心跳， # 那边将认为该storage server已经下线。所以本参数值必须大于storage server配置的心跳时间间隔。 # 通常配置为storage server心跳时间间隔的2倍或3倍。 check_active_interval=120 thread_stack_size #func：设定线程栈的大小。 线程栈越大，一个线程占用的系统资源就越多。 # 如果要启动更多的线程（V1.x对应的参数为max_connections，V2.0为work_threads），可以适当降低本参数值。 #valu：如64KB，默认值为64，tracker server线程栈不应小于64KB thread_stack_size=64KB storage_ip_changed_auto_adjust #func：这个参数控制当storage server IP地址改变时，集群是否自动调整。注：只有在storage server进程重启时才完成自动调整。 #valu：true或false storage_ip_changed_auto_adjust=true 2 同步 storage_sync_file_max_delay #func：同组storage服务器之间同步的最大延迟时间。存储服务器之间同步文件的最大延迟时间，根据实际情况进行调整 #valu：秒为单位，默认值为1天（24*3600） #sinc：v2.0 storage_sync_file_max_delay=86400 storage_sync_file_max_time #func：存储服务器同步一个文件需要消耗的最大时间，缺省为300s，即5分钟。 #sinc：v2.0 storage_sync_file_max_time=300 sync_log_buff_interval #func：同步或刷新日志信息到硬盘的时间间隔。注意：tracker server 的日志不是时时写硬盘的，而是先写内存。 #valu：以秒为单位 sync_log_buff_interval=10 3 trunk 和 slot #func：是否使用trunk文件来存储几个小文件 #valu：true或false #sinc：v3.0 use_trunk_file=false #func：最小slot大小 #valu：&lt;= 4KB，默认为256字节 #sinc：v3.0 slot_min_size=256 #func：最大slot大小 #valu：&gt;= slot_min_size，当小于这个值的时候就存储到trunk file中。默认为16MB。 #sinc：v3.0 slot_max_size=16MB #func：trunk file的size #valu：&gt;= 4MB，默认为64MB #sinc：v3.0 trunk_file_size=64MB 4 HTTP 相关 是否启用 HTTP #func：HTTP是否生效 #valu：true或false http.disabled=false HTTP 服务器端口号 #func：tracker server上的http port #valu： #note：只有http.disabled=false时才生效 http.server_port=7271 检查Storage存活状态的间隔时间（心跳检测） #func：检查storage http server存活的间隔时间 #valu：单位为秒 #note：只有http.disabled=false时才生效 http.check_alive_interval=30 心跳检测使用的协议方式 #func：检查storage http server存活的方式 #valu： # tcp：连接到storage server的http端口，不进行request和response。 # http：storage check alive url must return http status 200. #note：只有http.disabled=false时才生效 http.check_alive_type=tcp 检查 Storage 状态的 URI #func：检查storage http server是否alive的uri/url #note：只有http.disabled=false时才生效 http.check_alive_uri=/status.html]]></content>
      <categories>
        <category>java软件安装</category>
      </categories>
      <tags>
        <tag>fastdfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[淘淘商城软件安装(二)--nginx的使用]]></title>
    <url>%2F2018%2F06%2F05%2F%E6%B7%98%E6%B7%98%E5%95%86%E5%9F%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-%E4%BA%8C-nginx%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 使用场景 http服务器。nginx是一个http服务器可以独立提供http服务。可以做静态服务器 虚拟主机。可以实现一台服务器虚拟出多个网站。 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载过高宕机而某台服务器闲置。 2.安装1.下载官方网站 2.要求的环境 需要安装gcc环境。yum install gcc-c++ 第三方的开发包 PCRE (perl库，perl的正则表达式) 1yum install -y pcre pcre-devel zlib 1yum install -y zlib zlib-devel openssl 1yum install -y openssl openssl-devel 3.安装编译 解压 1tar -zxvf nginx-1.8.0.tar.gz 编译 123456789101112131415161718./configure \--prefix=/usr/local/nginx \--pid-path=/var/run/nginx/nginx.pid \--lock-path=/var/lock/nginx.lock \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--with-http_gzip_static_module \--http-client-body-temp-path=/var/temp/nginx/client \--http-proxy-temp-path=/var/temp/nginx/proxy \--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \--http-scgi-temp-path=/var/temp/nginx/scgi注意：上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录makemake install 启动 123456789cd /usr/local/nginx/sbin/./nginx # 查看进程ps -aux | grep nginx注意：执行./nginx启动nginx，这里可以-c指定加载的nginx配置文件，如下：./nginx -c /usr/local/nginx/conf/nginx.conf如果不指定-c，nginx在启动时默认加载conf/nginx.conf文件，此文件的地址也可以在编译安装nginx时指定./configure的参数（--conf-path= 指向配置文件（nginx.conf）） 停止 123456789方式1，快速停止：cd /usr/local/nginx/sbin./nginx -s stop此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。方式2，完整停止(建议使用)：cd /usr/local/nginx/sbin./nginx -s quit此方式停止步骤是待nginx进程处理任务完毕进行停止。 重启 123456789方式1，先停止再启动（建议使用）：对nginx进行重启相当于先停止nginx再启动nginx，即先执行停止命令再执行启动命令。如下：./nginx -s quit./nginx方式2，重新加载配置文件：当nginx的配置文件nginx.conf修改后，要想让配置生效需要重启nginx，使用-s reload不用先停止nginx再启动nginx即可将配置信息在nginx中生效，如下：./nginx -s reload]]></content>
      <categories>
        <category>java软件安装</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[淘淘商城软件安装(一)--zookeeper和dubbo的使用]]></title>
    <url>%2F2018%2F05%2F24%2F%E6%B7%98%E6%B7%98%E5%95%86%E5%9F%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-%E4%B8%80-zookeeper%E5%92%8Cdubbo%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 什么是Dubbo随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。 · 单一应用架构 · 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。 · 此时，用于简化增删改查工作量的 数据访问框架**(ORM)** 是关键。 · 垂直应用架构 · 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。 · 此时，用于加速前端页面开发的 Web**框架**(MVC) 是关键。 · 分布式服务架构 · 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。 · 此时，用于提高业务复用及整合的 分布式服务框架**(RPC)** 是关键。 · 流动计算架构 · 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 · 此时，用于提高机器利用率的 资源调度和治理中心**(SOA)** 是关键。 Dubbo就是资源调度和治理中心的管理工具。 2. Dubbo的架构 节点角色说明： · Provider: 暴露服务的服务提供方。 · Consumer: 调用远程服务的服务消费方。 · Registry: 服务注册与发现的注册中心。 · Monitor: 统计服务的调用次调和调用时间的监控中心。 · Container: 服务运行容器。 调用关系说明： · 0. 服务容器负责启动，加载，运行服务提供者。 · 1. 服务提供者在启动时，向注册中心注册自己提供的服务。 · 2. 服务消费者在启动时，向注册中心订阅自己所需的服务。 · 3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 · 4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 · 5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 3. 使用方法添加依赖 12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.jboss.netty&lt;/groupId&gt; &lt;artifactId&gt;netty&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;$&#123;zookeeper.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;$&#123;zkclient.version&#125;&lt;/version&gt;&lt;/dependency&gt; Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。 单一工程中spring**的配置** 1234&lt;bean id="xxxService" class="com.xxx.XxxServiceImpl" /&gt;&lt;bean id="xxxAction" class="com.xxx.XxxAction"&gt; &lt;property name="xxxService" ref="xxxService" /&gt;&lt;/bean&gt; 远程服务： 在本地服务的基础上，只需做简单配置，即可完成远程化： 将上面的local.xml配置拆分成两份，将服务定义部分放在服务提供方remote-provider.xml，将服务引用部分放在服务消费方remote-consumer.xml。 并在提供方增加暴露服务配置，在消费方增加引用服务配置。 发布服务： 123456789&lt;!-- 使用dubbo发布服务 --&gt;&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;&lt;dubbo:application name="e3-manager" /&gt;&lt;dubbo:registry protocol="zookeeper" address="192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183" /&gt;&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;&lt;dubbo:protocol name="dubbo" port="20880" /&gt;&lt;!-- 声明需要暴露的服务接口 --&gt;&lt;dubbo:service interface="cn.e3mall.service.ItemService" ref="itemServiceImpl" /&gt; 调用服务： 1234&lt;!-- 引用dubbo服务 --&gt;&lt;dubbo:application name="e3-manager-web"/&gt;&lt;dubbo:registry protocol="zookeeper" address="192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183"/&gt; &lt;dubbo:reference interface="cn.e3mall.service.ItemService" id="itemService" /&gt; 3. 注册中心3.1 Zookeeper介绍官方推荐使用zookeeper注册中心。 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。使用dubbo-2.3.3以上版本，建议使用zookeeper注册中心。 Zookeeper是Apacahe Hadoop的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbo服务的注册中心，工业强度较高，可用于生产环境，并推荐使用 Zookeeper： 可以作为集群的管理工具使用。 可以集中管理配置文件。 3.2 Zookeeper的安装安装环境： Linux：centos6.4 Jdk:1.7以上版本 Zookeeper是java开发的可以运行在windows、linux环境。需要先安装jdk。 安装步骤： 第一步：安装jdk 第二步：把zookeeper的压缩包上传到linux系统。 第三步：解压缩压缩包 tar -zxvf zookeeper-3.4.6.tar.gz 第四步：进入zookeeper-3.4.6目录，创建data文件夹。 第五步：把zoo_sample.cfg改名为zoo.cfg [root@localhost conf]# mv zoo_sample.cfg zoo.cfg 第六步：修改data属性：dataDir=/root/zookeeper-3.4.6/data 第七步：启动zookeeper [root@localhost bin]# ./zkServer.shstart 关闭：[root@localhost bin]#./zkServer.sh stop 查看状态：[root@localhost bin]#./zkServer.sh status 注意：需要关闭防火墙。 3.3 Zookeeper集群第一步zookeeper集群配置（三台机器都要配置） conf/zoo.cfg文件 修改 dataDir=/opt/zookeeper 端口号clientPort=2181 最后面增加 server.1=centos1:2888:3888 server.2=centos2:2888:3888 server.3=centos3:2888:3888 第二步/opt/zookeeper目录下创建myid文件，目录不存在就手动创建目录。 centos1的myid文件内容设置为1 centos1的myid文件内容设置为2 centos1的myid文件内容设置为3 （分别对应zoo.cfg配置的的server.1、server.2、server.3中的1，2，3） 3.4 dubbo的监控中心 安装tomcat(建议jdk1.8 如果是2.5.4需要1.7) 将dubbo-admin-2.5.8.war上传至服务器，并修改名称为dubbo-admin.war 将dubbo-admin.war移动到tomcat的webapps下，并启动tomcat即可 直接访问http://localhost:8080/dubbo-admin (默认用户和密码都是root) 如果和zookeeper不在同一台机器上，需要修改配置文件dubbo-admin/WEB-INF/dubbo.properties dubbo.registry.address=zookeeper://127.0.0.1:2181dubbo.admin.root.password=rootdubbo.admin.guest.password=guest]]></content>
      <categories>
        <category>java软件安装</category>
      </categories>
      <tags>
        <tag>zookeeper dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins权威指南读书笔记(二)--Jenkins起步]]></title>
    <url>%2F2018%2F04%2F14%2FJenkins%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BA%8C-Jenkins%E8%B5%B7%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[迈入Jenkins的第一步1.准备环境 任何持续集成工具最基本的功能就是: 监控版本控制的源代码，并在任何更改被提交的时候获取和构建源代码的最新版本。 所以第一步我们需要一个版本控制系统，在这里我们选择Git，具体教程见Git教程 因为jenkins是基于Java的web应用程序，所以需要安装Java环境,Java环境搭建 本实例使用的实例代码 请自行Fork，如果想要代码修改请clone到本地修改 2.启动Jenkins 下载Jenkins.war下载地址 启动Jenkins（多种方式） 方式一:直接运行java -jar jenkins.war 方式二:部署war到Java的应用服务器(Tomcat、Jboss等) 然后就可以在本地使用Jenkins了,浏览器输入http://localhost:8080即可(有可能需要带项目名jenkins) 3.配置工具我们需要告诉Jenkins我们需要的构建工具和JDK版本。 在主页点击系统管理,这将把你带入管理Jenkins界面,为你的Jenkins配置提供中央一站式服务。从这个界面，你可以配置Jenkins服务器，安装和升级各种插件，跟踪系统负荷，管理分布式服务器，等等。下载我们点击列表顶部的系统设置。 我们需要配置必要的工具来构建我们的示例项目。我们将使用Maven构建一个Java应用程序。在这种情况下，我们需要设置最近的Maven和JDK。点击全局工具配置 配置你的Maven 上图为选择系统中安装的Maven，如果系统中没有安装，点击新建Maven勾选自动安装即可 配置JDK 等同Maven配置 安装Git插件 搜索Git Plugin进行安装，如果已安装中已存在就不需要安装了。 4.你的第一个Jenkins的Job构建Job是Jenkins构建过程中的核心。简单的说，你可以认为Jenkins构建Job是你的构建过程的一项特定的任务或步骤。这可能涉及编译你的源代码和运行单元测试。或者你希望你的构建作业来做其它相关的业务，例如集成测试、测试代码覆盖率或代码质量度量，生成技术文档，或者甚至将你的应用部署到web服务器。一个真实的项目通常需要许多独立的但是相关的构建作业。 对于第一个工作，只要完成编译和测试示例应用程序。 点击新建任务 输入构建工作的名称game-of-life-default,点击构建一个自由风格的软件项目点击OK 简单的说，Jenkins通过检查你的项目源代码并在它的工作目录中进行构建。所以你需要做的下一件事就是告诉Jenkins，在哪里可以找到你的项目源代码。 再下一步我们可以配置多久一次检查更新，我们想要Jenkins监控仓库，而且任务更改被提交时就会进行构建。这是在集成环境中最常用的方式，其它的方式包括在固定的时间间隔触发、手工触发等。 下一步就是配置构建本身。在自由模式下，你可以将构建作业分解为若干个步骤。下载我们只想运行一个简单的构建。如下图点击。 下一步可以让Jenkins密切关注测试 5.执行构建Job一旦保存就进入如下界面 ​]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins devops</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins权威指南读书笔记(一)--Jenkins简介]]></title>
    <url>%2F2018%2F04%2F14%2FJenkins%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80-Jenkins%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[1. 持续集成基础 持续集成:就其最简单的形式来讲，就是一个能监控版本控制系统变化的工具。无论任何时候，只要检测到有变化，这个工具就会自动编译和测试你的应用程序。如果出现问题，它就会马上通知开发人员，以便他们可以立即着手解决这个问题。 当然持续集成可以做的事情还能更多，比如 密切监视代码库的健康 自动监控代码质量和代码覆盖率 降低技术债务和减少维护成本 还可以结合插件完成自动化部署等 自动化部署的想法很重要。事实上，理论上来讲自动化部署的过程可以使你能够推送每一个带有必要的自动化测试构建到生产环境中去，这种实践就叫做持续部署。 2.Jenkins简介 Jenkins，最开始被称为Hudson，是一个Java语言编写的开源的持续集成工具。 它拥有以下的好处： 首先，Jenkins易于使用。用户界面非常的简单、直观。 其次，Jenkins拥有良好的扩展性，能够极其灵活地迎合你的想法。（它拥有很多的插件） 最后，Jenkins的社区规模庞大，活跃度也非常的高。 3.引进持续集成到公司的阶段阶段一：无构建服务器期初，团队没有任何形式的中央构建服务器。软件实在开发人员的机器上手工进行触发构建的，尽管这个构建可能使用了Maven或者Ant等构件工具。源代码可能存储在一个中央源代码仓库（Git，Svn等）中,但是开发人员不需要定期提交其代码变更。在计划发布一个新的版本之前的那段时间里，开发人员需要手动集成他的代码改动，这个过程非常的痛苦。 阶段二：夜间构建这个阶段，团体有一个构建服务器，并且会定期（通常是夜间）的按照计划触发自动化构建。但是这个过程只是简单的代码编译，没有可靠的或可重复的单元测试。即使有自动化测试，它也不是强制地要作为构建的一部分，并很可能运行的不正确。在这个阶段开发人员至少会在每天结束后提交代码更新。加入一个开发人员的代码和另一个开发人员的代码发生冲突，构建服务器会在第二天早上通过发送邮件的方式向团队报警。但是这个阶段，开发人员不会立即的修改错误的构建，所以有些构建会一直坏在构建服务器上没人处理。 阶段三：夜间构建加自动化测试在这个阶段，无论任何时候，只要有代码更新提交到版本控制系统中，构建服务器就会触发一个构建，团队成员可以轻易的看到那些源码变化触发了这个特定的构建。此外，构建运行脚本去编译和运行应用的一系列自动化的测试、集成测试。除了发送邮件，构建服务器也会使用更积极的沟通渠道（比如即使通信）来提醒团队成员在集成的过程中出现的问题。运行失败的构建的构建在这个阶段一般都可以很快地得到修复。 阶段四：加入度量指标在这个阶段，构建中会运行自动化的代码质量和代码覆盖率检查，来帮助我们检查代码库的质量和测试相关性以及有效性。质量构建也会自动为程序生成API文档。如果代码质量发生下降也会进行警报。同时团队还会建立一个“构建展示器”。 阶段五：更认真的对待测试持续集成的好处是可以和可靠的测试实践紧密结合。 阶段六：自动化验收测试和自动化部署这个阶段，测试人员进行测试验收，当测试人员认为可以的时候，就可以手工触发构建来部署一个新的版本去进行用户测试或直接交付到生产环境。如果当前版本出现严重问题，团队还可以使用构建服务器把当前版本回滚到上个版本。 阶段七：持续部署]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins devops</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker(二)--docker容器和镜像的使用]]></title>
    <url>%2F2018%2F03%2F29%2FDocker-%E4%BA%8C-docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.Docker容器的使用1.1 Docker 客户端docker 客户端非常简单 ,我们可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。 可以通过命令 docker command --help 更深入的了解指定的 Docker 命令使用方法。 例如我们要查看 docker stats 指令的具体使用方法：docker stats --help 1.2 运行一个web应用前面我们运行的容器并没有一些什么特别的用处。 接下来让我们尝试使用 docker 构建一个 web 应用程序。 我们将在docker容器中运行一个 Python Flask 应用来运行一个web应用。 首先载入一个镜像training/webapp 再在容器上启动一个web应用 参数说明: -d:让容器在后台运行。 -P:将容器内部使用的网络端口映射到我们使用的主机上。 1.3 查看 WEB 应用容器使用 docker ps 来查看我们正在运行的容器 这里我们发现在PORTS这一栏中多个信息0.0.0.0:32768-&gt;5000/tcp表示docker开放了5000端口到主机的32768上，现在我们可以使用http://localhost:32768来进行访问 我们也可以指定 -p 标识来绑定指定端口。 docker run -d -p 5000:5000 training/webapp python app.py 1.4 查看WEB应用程序日志docker logs [ID或者名字] 可以查看容器内部的标准输出。 -f:让 dokcer logs 像使用tail -f 一样来输出容器内部的标准输出。 从上面，我们可以看到应用程序使用的是 5000 端口并且能够查看到应用程序的访问日志。 1.5 检查WEB应用程序使用 docker inspect 来查看Docker的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。 1.6 停止WEB应用容器,重启WEB应用容器,移除WEB应用容器分别使用docker stop docker start docker rm 2.Docker镜像的使用当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。 下面我们来学习： 1、管理和使用本地 Docker 主机镜像 2、创建镜像 2.1 列出镜像列表我们可以使用docker images来列出本机上的所有的镜像。 各个选项说明: REPOSITORY：表示镜像的仓库源 TAG：镜像的标签 IMAGE ID：镜像ID CREATED：镜像创建时间 SIZE：镜像大小 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如ubuntu仓库源里，有15.10、14.04等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。 所以，我们如果要使用版本为15.10的ubuntu系统镜像来运行容器时，命令如下： 如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。 2.2 获取一个新的镜像当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。 下载完成后，我们可以直接使用这个镜像来运行容器。 2.3 查找镜像我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： https://hub.docker.com/ 我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个httpd的镜像来作为我们的web服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。 NAME:镜像仓库源的名称 DESCRIPTION:镜像的描述 OFFICIAL:是否docker官方发布 2.4 创建镜像当我们从docker镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。 1.从已经创建的容器中更新镜像，并且提交这个镜像 2.使用 Dockerfile 指令来创建一个新的镜像 具体操作后期会详细讲解。 2.5 更新镜像更新镜像之前，我们需要使用镜像来创建一个容器。 在运行的容器内使用 apt-get update 命令进行更新。 在完成操作之后，输入 exit命令来退出这个容器。 此时ID为5b3413d2e84a的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit来提交容器副本。 docker commit -m=&quot;has update&quot; -a=&quot;wuqinghua&quot; 5b3413d2e84a wuqinghua/ubuntu:v2 各个参数说明： -m:提交的描述信息 -a:指定镜像作者 5b3413d2e84a：容器ID wuqinghua/ubuntu:v2:指定要创建的目标镜像名 2.6 构建镜像我们使用命令 docker build ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。 2.6.1 DockerfileDockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。它们简化了从头到尾的流程并极大的简化了部署工作。Dockerfile从FROM命令开始，紧接着跟随者各种方法，命令和参数。其产出为一个新的可以用于创建容器的镜像。 2.6.2 Dockerfile 语法2.6.2.1 语法示例12345678Dockerfile语法由两部分构成，注释和命令+参数# Line blocks used for commentingcommand argument argument ..一个简单的例子：# Print "Hello docker!"RUN echo "Hello docker!" 2.6.2.2 Dockerfile命令Dockerfile有十几条命令可用于构建镜像，下文将简略介绍这些命令。 ADD ADD命令有两个参数，源和目标。它的基本作用是从源系统的文件系统上复制文件到目标容器的文件系统。如果源是一个URL，那该URL的内容将被下载并复制到容器中。 12# Usage: ADD [source directory or URL] [destination directory]ADD /my_app_folder /my_app_folder CMD 和RUN命令相似，CMD可以用于执行特定的命令。和RUN不同的是，这些命令不是在镜像构建的过程中执行的，而是在用镜像构建容器后被调用。 12# Usage 1: CMD application "argument", "argument", ..CMD "echo" "Hello docker!" ENTRYPOINT 配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。 每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有最后一个起效。 ENTRYPOINT 帮助你配置一个容器使之可执行化，如果你结合CMD命令和ENTRYPOINT命令，你可以从CMD命令中移除“application”而仅仅保留参数，参数将传递给ENTRYPOINT命令。 1234567# Usage: ENTRYPOINT application "argument", "argument", ..# Remember: arguments are optional. They can be provided by CMD or during the creation of a container.ENTRYPOINT echo# Usage example with CMD:# Arguments set with CMD can be overridden during *run*CMD "Hello docker!"ENTRYPOINT echo ENV ENV命令用于设置环境变量。这些变量以”key=value”的形式存在，并可以在容器内被脚本或者程序调用。这个机制给在容器中运行应用带来了极大的便利。 12Usage: ENV key valueENV SERVER_WORKS 4 EXPOSE EXPOSE用来指定端口，使容器内的应用可以通过端口和外界交互。 12# Usage: EXPOSE [port]EXPOSE 8080 FROM FROM命令可能是最重要的Dockerfile命令。改命令定义了使用哪个基础镜像启动构建流程。基础镜像可以为任意镜 像。如果基础镜像没有被发现，Docker将试图从Docker image index来查找该镜像。FROM命令必须是Dockerfile的首个命令。 12# Usage: FROM [image name]FROM ubuntu MAINTAINER 我建议这个命令放在Dockerfile的起始部分，虽然理论上它可以放置于Dockerfile的任意位置。这个命令用于声明作者，并应该放在FROM的后面。 12# Usage: MAINTAINER [name]MAINTAINER authors_name RUN RUN命令是Dockerfile执行命令的核心部分。它接受命令作为参数并用于创建镜像。不像CMD命令，RUN命令用于创建镜像（在之前commit的层之上形成新的层）。 12# Usage: RUN [command]RUN aptitude install -y riak USER USER命令用于设置运行容器的UID。 12# Usage: USER [UID]USER 751 VOLUME VOLUME命令用于让你的容器访问宿主机上的目录。 12# Usage: VOLUME ["/dir_1", "/dir_2" ..]VOLUME ["/my_files"] WORKDIR WORKDIR命令用于设置CMD指明的命令的运行目录。 12# Usage: WORKDIR /pathWORKDIR ~/ 2.6.2.3 Docfile示例一：创建一个MongoDB镜像123456789101112131415161718192021222324252627# 定义文件和它的目的# 让阅读者明确Dockerfile的目的永远是必要的。为此，我们通常从注释开始写Dockerfile。############################################################# Dockerfile to build MongoDB container images# Based on Ubuntu############################################################# 设置基础镜像 FROM ubuntu# 设置作者MAINTAINER WuQinghua# 设置命令与参数下载MongoDB################## BEGIN INSTALLATION ######################RUN apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10RUN echo 'deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen' | tee /etc/apt/sources.list.d/mongodb.listRUN apt-get updateRUN apt-get install -y mongodb-10genRUN mkdir -p /data/db##################### INSTALLATION END ###################### 设置MongoDB端口 EXPOSE 27017CMD ["--port 27017"]ENTRYPOINT usr/bin/mongod 2.6.2.3 Docfile示例二：创建一个Nginx镜像12345678910111213141516171819202122232425############################################################# Dockerfile to build Nginx Installed Containers# Based on Ubuntu############################################################FROM ubuntu# 设置作者MAINTAINER WuQinghua# Install NginxRUN echo "deb http://archive.ubuntu.com/ubuntu/ raring main universe" &gt;&gt; /etc/apt/sources.listRUN apt-get updateRUN apt-get install -y nano wget dialog net-toolsRUN apt-get install -y nginx# 安装Nginx后，我们需要配置Nginx并且替换掉默认的配置文件RUN rm -v /etc/nginx/nginx.confADD nginx.conf /etc/nginx/RUN echo "daemon off;" &gt;&gt; /etc/nginx/nginx.confEXPOSE 80CMD service nginx start 需要在当前目录下含有一个nginx.conf 123456789101112worker_processes 1;events &#123; worker_connections 1024; &#125;http &#123; sendfile on; server &#123; listen 80; location / &#123; proxy_pass http://httpstat.us/; proxy_set_header X-Real-IP $remote_addr; &#125; &#125;&#125; 2.7 设置镜像标签我们可以使用 docker tag 命令，为镜像添加一个新的标签。]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker devops</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker(一)--docker简介]]></title>
    <url>%2F2018%2F03%2F29%2FDocker-%E4%B8%80-docker%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[1.什么是Docker?Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。 Docker通常用于如下场景： web应用的自动化打包和发布； 自动化测试和持续集成、发布； 在服务型环境中部署和调整数据库或其他的后台应用； 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。 2.准备1.准备开始Docker系统有两个程序：docker服务端和docker客户端。其中docker服务端是一个服务进程，管理着所有的容器。docker客户端则扮演着docker服务端的远程控制器，可以用来控制docker的服务端进程。大部分情况下，docker服务端和客户端运行在一台机器上。 Docker 容器通过 Docker 镜像来创建。 容器与镜像的关系类似于面向对象编程中的对象与类。 Docker架构如下: 其中名词如下表所示 2.Docker的安装安装过程请参考http://www.docker.org.cn/book/install/supported-platform-17.html 3.检查Docker是否运行检查docker的版本，这样可以用来确认docker服务在运行并可通过客户端链接。 在命令行输入docker version 4.Docker的HelloWorldDocker 允许你在容器内运行应用程序， 使用 docker run 命令来在容器内运行一个应用程序。 输出Hello world 各个参数解析： docker:Docker的二进制执行文件 run:与前面的 docker 组合来运行一个容器。 ubuntu:15.10:指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。 /bin/echo “Hello world”: 在启动的容器里执行的命令 以上命令完整的意思可以解释为：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo “Hello world”，然后输出结果。 5.运行交互式的容器我们通过docker的两个参数 -i -t，让docker运行的容器实现”对话”的能力 此时我们已进入一个 ubuntu15.10系统的容器 我们尝试在容器中运行命令cat /proc/version和ls分别查看当前系统的版本信息和当前目录下的文件列表 各个参数解析： -t:在新容器内指定一个伪终端或终端。 -i:允许你对容器内的标准输入 (STDIN) 进行交互。 我们可以通过运行exit命令或者使用CTRL+D来退出容器。 6.启动容器（后台方式）使用以下命令创建一个以进程方式运行的容器 在输出中，我们没有看到期望的”hello world”，而是一串长字符 59dd21ee9fae6055ed8c4f7e8515ec4ca13e1af989513737adce7b0e86b4f615 这个长字符串叫做容器ID，对每个容器来说都是唯一的，我们可以通过容器ID来查看对应的容器发生了什么。 首先，我们需要确认容器有在运行，可以通过 docker ps 来查看 其中： CONTAINER ID:容器ID NAMES:自动分配的容器名称 在容器内使用docker logs命令，查看容器内的标准输出 7.停止容器我们使用 docker stop 命令来停止容器: ###]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker devops</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop学习(一)--安装并运行hadoop]]></title>
    <url>%2F2018%2F02%2F27%2Fhadoop%E5%AD%A6%E4%B9%A0-%E4%B8%80-%E5%AE%89%E8%A3%85%E5%B9%B6%E8%BF%90%E8%A1%8Chadoop%2F</url>
    <content type="text"><![CDATA[一、Hadoop组成部分​ 作为一个顶级项目，Hadoop项目包含许多组件子项目。最主要的两个子项目分别为Hadoop分布式文件系统（HDFS）和MapReduce，可以将其理解为一对独立而互补的技术。 ​ HDFS是一个可以存储极大数据集的文件系统，它通过向外扩展方式（集群）构建的主机集群。它有独特的设计和性能特点，特别是，HDFS以延时为代价对吞吐量进行了优化，并通过副本替换冗余达到了高可用性。 ​ MapReduce是一个数据处理范式，它规范了数据在两个处理阶段（Map和Reduce）的输入和输出，并将其应用于任意规模的大数据集。MapReduce和HDFS紧密结合，确保在任何情况下，MapReduce任务直接存储所需数据的HDFS节点上运行。 二、Hadoop的安装(基于centos6.8) 打开终端 12345$ java -version出现如下信息，表示JDK安装成功java version &quot;1.8.0_122-ea&quot;Java(TM) SE Runtime Environment (build 1.8.0_122-ea-b04)Java HotSpot(TM) 64-Bit Server VM (build 25.122-b04, mixed mode) 安装Hadoop123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123安装Hadoop2.71 下载Hadoop2.7.1 下载地址：http://mirrors.hust.edu.cn/apache/hadoop/common/stable2/hadoop-2.7.1.tar.gz2 解压安装 1）复制 hadoop-2.7.1.tar.gz 到/usr/hadoop目录下， 然后#tar -xzvf hadoop-2.7.1.tar.gz 解压，解压后目录为：/usr/hadoop/hadoop-2.7.1 2）在/usr/hadoop/目录下，建立tmp、hdfs/name、hdfs/data目录，执行如下命令 #mkdir /usr/hadoop/tmp #mkdir /usr/hadoop/hdfs #mkdir /usr/hadoop/hdfs/data #mkdir /usr/hadoop/hdfs/name3）设置环境变量，#vi ~/.bash_profile# set hadoop pathexport HADOOP_HOME=/usr/hadoop/hadoop-2.7.1export PATH=$PATH:$HADOOP_HOME/bin4) 使环境变量生效，$source ~/.bash_profile3） Hadoop配置 进入$HADOOP_HOME/etc/hadoop目录，配置 hadoop-env.sh等。涉及的配置文件如下： hadoop-2.7.1/etc/hadoop/hadoop-env.sh hadoop-2.7.1/etc/hadoop/yarn-env.sh hadoop-2.7.1/etc/hadoop/core-site.xml hadoop-2.7.1/etc/hadoop/hdfs-site.xml hadoop-2.7.1/etc/hadoop/mapred-site.xml hadoop-2.7.1/etc/hadoop/yarn-site.xml1） 配置hadoop-env.sh# The java implementation to use.#export JAVA_HOME=$&#123;JAVA_HOME&#125;export JAVA_HOME=/usr/java/jdk1.7.0_792）配置yarn-env.sh#export JAVA_HOME=/home/y/libexec/jdk1.7.0/export JAVA_HOME=/usr/java/jdk1.7.0_793）配置core-site.xml 添加如下配置：&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;description&gt;HDFS的URI，文件系统://namenode标识:端口号&lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/usr/hadoop/tmp&lt;/value&gt; &lt;description&gt;namenode上本地的hadoop临时文件夹&lt;/description&gt;&lt;/property&gt;&lt;/configuration&gt;4） 配置hdfs-site.xml 添加如下配置&lt;configuration&gt;&lt;!—hdfs-site.xml--&gt;&lt;property&gt; &lt;name&gt;dfs.name.dir&lt;/name&gt; &lt;value&gt;/usr/hadoop/hdfs/name&lt;/value&gt; &lt;description&gt;namenode上存储hdfs名字空间元数据 &lt;/description&gt; &lt;/property&gt;&lt;property&gt; &lt;name&gt;dfs.data.dir&lt;/name&gt; &lt;value&gt;/usr/hadoop/hdfs/data&lt;/value&gt; &lt;description&gt;datanode上数据块的物理存储位置&lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;description&gt;副本个数，配置默认是3,应小于datanode机器数量&lt;/description&gt;&lt;/property&gt;&lt;/configuration&gt;5） 配置mapred-site.xml 添加如下配置：&lt;configuration&gt;&lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;6） 配置yarn-site.xml 添加如下配置：&lt;configuration&gt;&lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &lt;value&gt;192.168.241.128:8099&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;4，Hadoop启动 1）格式化namenode$ bin/hdfs namenode –format2）启动NameNode 和 DataNode 守护进程$ sbin/start-dfs.sh3）启动ResourceManager 和 NodeManager 守护进程$ sbin/start-yarn.sh5，启动验证 1）执行jps命令，有如下进程，说明Hadoop正常启动# jps6097 NodeManager11044 Jps7497 -- process information unavailable8256 Worker5999 ResourceManager5122 SecondaryNameNode8106 Master4836 NameNode4957 DataNodevim /etc/profile ​]]></content>
      <categories>
        <category>java hadoop 大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm详解]]></title>
    <url>%2F2018%2F02%2F25%2Fjvm%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[[TOC] 1、Java虚拟机概述和基本概念1.1 Java虚拟机的原理​ 所谓的虚拟机，就是一台虚拟的机器。它是一款软件，用来执行一系列虚拟计算机指令。大体上虚拟机分为系统虚拟机和程序虚拟机，大名鼎鼎的Visual Box、VMare就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。程序虚拟机典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。Java发展至今，出现过很多的虚拟机，最初Sun使用的一款叫Classic的Java虚拟机，到现在引用最广泛的是HotSpot虚拟机。除了Sun以外，还有BEA的JRockit，目前JRockit和HotSpot都被Oracle收入旗下，大有整合的趋势。 1.2 认识Java虚拟机 类加载器子系统：负责从文件系统或网络中加载Class信息，加载的信息存放在一块称为方法区的内存空间。 方法区：就是存放类信息、常量信息、常量池信息、包括字符串字面量和数字常量等。 Java堆：在java虚拟机启动的时候建立java堆，它是Java程序最主要的内存工作区域，几乎所有的对象的实例都存放在Java堆中，堆空间是所有的线程共享的。 直接内存：Java的NIO库允许Java程序使用直接内存，从而提高性能，通常直接内存速度会优于Java堆。读写频繁的场合可能会考虑使用。 JVM栈：每个虚拟机线程都有一个私有的栈，一个线程的Java栈在线程创建的时候被创建，java栈中保存着局部变量、方法参数、同时java方法调用、返回值等 本地方法栈：和java栈非常相似，最大的不同为本地为本地方法栈用于本地方法调用。java虚拟机允许java直接调用本地方法（通常使用C编写） 垃圾收集系统：是java的核心，也是必不可少的，java有一套自己进行垃圾清理的机制，开发人员无需手工清理，稍后在第三节我们详细说明。 PC（Program Counter）：寄存器也是每个线程私有的空间，java虚拟机会为每个线程创建PC寄存器，在任意时刻，一个java线程总是在执行一个方法，这个方法被称为当前方法，如果当前方法不是本地方法，PC寄存器就会执行当前正在被执行的指令，如果是本地方法，则PC寄存器为undefined，寄存器存放如当前执行环境指针、程序计数器、操作栈指针、计算的变量指针等信息。 虚拟机最核心的就是执行引擎了，它负责执行虚拟机的字节码。一般进行编译成机器码后执行。 2、堆、栈、方法区2.1 堆、栈、方法区概念和联系堆解决的数据存储的问题，即数据怎么放、放在哪个。栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。方法区则是辅助堆栈的永久区（Perm），解决堆栈信息的产生，是先决条件。比如：我们创建一个新的对象，User，那么User类的一些信息（类信息、静态信息都存放在方法区中） 而User类实例化后，被存储到java堆中 当我们使用的时候，都是使用user对象的引用，形如User user = new User(); 这里的user存放在java的栈中，即User真是对象时一个引用 2.2 辨清java堆​ java堆是和java应用程序关系最密切的内存空间，几乎所有的对象都存放在其中，并且java堆完全为自动化管理的，通过垃圾回收机制，垃圾对象会自动清理，不需要显示的释放。 ​ 根据垃圾回收机制不同，Java堆有可能拥有不同的结构。最常见的就是讲Java堆分为新生代和老年代。其中新生代存放新生的对象或者年龄不大的对象，老年代则存放老年代对象 ​ 新生代分为eden区、s0区、s1区，s0和s1也成为from和to区域，它们是两块大小相等并且可能相互转换角色的空间 ​ 绝大多数情况下，对象首先分配在eden区，在一次新生代回收后，如果对象还存活，则会进入s0或s1区，之后每经过一次新生代回收，如果对象存活则它的年龄就被加1，当对象达到一定的年龄后，则进入老年代。 2.3 java栈java栈是一块线程私有的内存空间，一个栈，一般由三个部分组成：局部变量表、操作数栈和帧数据区 局部变量表：用于报错函数的参数以及局部变量 操作数栈：主要保存计算过程的中间结果，同时作为计算过程中的变量临时的存储空间。 帧数据区：除了局部变量表和操作数栈以外，栈还需要一些数据来支持常量池的解析，这里的帧数据区保存着访问常量池的指针，方便程序访问常量池，另外，当函数返回或者出现异常时，虚拟机必须有一个异常处理表，方便发送异常的时候找到异常的代码，因此异常处理表噎死帧数据区的一部分。 2.4 java方法区java方法区和堆一样，方法区是一块所有内存共享的区域，它保存系统的类信息，比如类的字段、方法、常量池等。方法区的大小决定了系统可以保存多少个类，如果系统定义太多类，导致方法区溢出。虚拟机同样会抛出内存溢出错误。方法区可以理解为永久区(Perm)。 3、了解虚拟机参数3.1 虚拟机参数在虚拟机运行的过程中，如果可以跟踪系统的运行状态，那么对于问题的故障排查会有一定的帮助，为此，虚拟机提供了一些跟踪系统状态的参数，使用给定的参数执行java虚拟机，就可以在系统运行的时候打印相关的日志，用于分析实际的问题。我们进行的参数配置，其实主要就是围绕着堆、栈、方法区进行配置。 3.2 堆分配参数（一） 命令 说明 -XX:+PrintGC 虚拟机启动后，只要遇到GC就会打印参数 -XX:+UserSerialGC 配置串行回收器 -XX:PrintGCDetails 可以查看详细信息，包括各个区的情况 -Xms 设置程序启动的时候初始堆大小 -Xmx 设置程序启动的时候最大堆大小 -XX:+PrintCommandLineFlags 可以显示或隐式给虚拟机的参数输出 实例: Test01 总结：在实际工作中，我们可以直接将初始的堆大小与最大堆大小设置相同，这样的好处是可以减少程序运行时的垃圾回收次数，从而提高性能。 3.3 堆分配参数 (二) 参数 说明 -Xmn 设置新生代大小，新生代通常为堆空间的1/3到1/4左右 -XX:SurvivorRatio 用来设置新生代中eden\from\to的空间比例 -XX:SurvivorRatio=eden/from=eden/to 实例:Test02 总结:在不同的堆分布情况，对系统执行会产生一定的影响，在实际工作中，应该根据系统的特点做出合理的配置，基本策略：尽量可能将对象预留在新生代，减少老年代GC次数。 除了可以设置新生代的绝对大小(-Xmn),还可以使用(-XX:NewRatio)设置新生代和老年代的比例：-XX:NewRatio=老年代/新生代 3.4 堆溢出处理在Java程序的运行过程中，如果堆空间不足，则会抛出内存溢出的错误(OutOfMemory)OOM，java虚拟机提供了-XX:+HeapDumpOnOutOfMemoryError,使用该参数可以在内存溢出导出整个堆信息，与之配合使用的还有参数，-XX:HeapDumpPath，可以设置导出路径 内存分析工具：Memory Analyzer 1.5.0 实例:Test03 3.5 栈配置java虚拟机提供-Xss来指定线程的最大栈空间，整个参数也直接决定了函数可调用的最大深度 实例:Test04 3.6 方法区可以使用-XX:MaxPremSize和-XX:PermSize进行配置 默认情况为64m。 3.7 Client和Server虚拟机模式可以通过java -version查看虚拟机的模式，可以通过-client指定为Client模式 Client模式启动较快，如果不追求系统的长时间使用可以使用Client模式。 JVM一个不错的博客 4、垃圾回收概念和算法一、对象存活判断判断对象是否存活一般有两种方式： 1.引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。 2.可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。 在Java语言中，GC Roots包括： 虚拟机栈中引用的对象。 方法区中类静态属性实体引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI引用的对象。 二、JVM的垃圾回收过程首先从GC Roots开始进行可达性分析，判断哪些是不可达对象。 对于不可达对象，判断是否需要执行其finalize方法，如果对象没有覆盖finalize方法或已经执行过finalize方法则视为不需要执行，进行回收；如果需要，则把对象加入F-Queue队列。 对于F-Queue队列里的对象，稍后虚拟机会自动建立一个低优先级的线程去触发其finalize方法，但不会等待这个方法返回。 如果在finalize方法的执行过程中，对象重新被引用，那么进行第二次标记时将被移出F-Queue，在finalize方法执行完成后，对象仍然没有被引用，则进行回收。 对于被移出F-Queue的对象，如果它下一次面临回收时，将不会再执行其finalize方法。 finalize方法只执行一次。 三、垃圾收集算法 1、引用计数（reference counting） ​ 原理：此对象有一个引用，则+1；删除一个引用，则-1。只用收集计数为0的对象。 ​ 缺点：无法处理循环引用的问题。如：对象A和B分别有字段b、a，令A.b=B和B.a=A，除此之外这2个对象再无任何引用，那实际上这2个对象已经不可能再被访问，但是引用计数算法却无法回收他们。 2、复制（copying） ​ 原理：把内存空间划分为2个相等的区域，每次只使用一个区域。垃圾回收时，遍历当前使用区域，把正在使用的对象复制到另外一个区域。 ​ 优点：不会出现碎片问题。 ​ 缺点：1、暂停整个应用。2、需要2倍的内存空间。 3、标记-清扫（Mark-and-sweep）—sun前期版本就是用这个技术。 ​ 原理：对于“活”的对象，一定可以追溯到其存活在堆栈、静态存储区之中的引用。这个引用链条可能会穿过数个对象层次。第一阶段：从GC roots开始遍历所有的引用，对有活的对象进行标记。第二阶段：对堆进行遍历，把未标记的对象进行清除。这个解决了循环引用的问题。 ​ 缺点：1、暂停整个应用；2、会产生内存碎片。 4、标记-压缩（Mark-Compact）自适应 ​ 原理：第一阶段标记活的对象，第二阶段把为标记的对象压缩到堆的其中一块，按顺序放。 ​ 优点：1、避免标记扫描的碎片问题；2、避免停止复制的空间问题。 ​ ​ 具体使用什么方法GC，Java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器的效率低的话，就切换到“标记-扫描”方式；同样，Java虚拟机会跟踪“标记-扫描”的效果，要是堆空间碎片出现很多碎片，就会切换回“停止-复制”模式。这就是自适应的技术。 5、分代（generational collecting）—–J2SE1.2以后使用此算法 ​ 原理：基于对象生命周期分析得出的垃圾回收算法。把对象分为年轻代、年老代、持久代，对不同的生命周期使用不同的算法（2-3方法中的一个即4自适应）进行回收。 6、自适应算法(Adaptive Collector) ​ 在特定的情况下，一些垃圾收集算法会优于其它算法。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，并将选择适当算法的垃圾收集器。 年轻代（young） 年轻代分三个区。一个Eden区，两个Survivor区。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当第二个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到tenured generation。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来对象，和从前一个 Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。young generation的gc称为minor gc。经过数次minor gc，依旧存活的对象，将被移出young generation，移到tenured generation。 年老代（tenured） 存放从年轻代（young）复制过来的对象。生命周期较长的对象，归入到tenured generation。一般是经过多次minor gc，还依旧存活的对象，将移入到tenured generation。（当然，在minor gc中如果存活的对象的超过survivor的容量，放不下的对象会直接移入到tenured generation）。tenured generation的gc称为major gc，就是通常说的full gc。 ​ 采用compaction算法。由于tenured generaion区域比较大，而且通常对象生命周期都比较长，compaction需要一定时间。所以这部分的gc时间比较长。 ​ minor gc可能引发full gc。当eden＋from space的空间大于tenured generation区的剩余空间时，会引发full gc。这是悲观算法，要确保eden＋from space的对象如果都存活，必须有足够的tenured generation空间存放这些对象。 持久代（perm） ​ 用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著的影响，但是有些应用可能动态生成或者调用一些class。持久代大小通过-XX:MaxPermSize=N进行设置 该区域比较稳定，主要用于存放classloader信息，比如类信息和method信息。 对于spring hibernate这些需要动态类型支持的框架，这个区域需要足够的空间。(这部分空间应该存在于方法区而不是heap中)。 四、Minor collections和Major collectionsMinor collection当young space被占满时执行。它比major collections快，因为minor collection仅仅检查major collection相应的一个子集对象。minor collection比major collection发生的频率高。 Major collection当tenured space被占满时执行。他会清理tenured和young。 Thinking in java给java gc取了一个罗嗦的称呼：“自适应、分代的、停止-复制、标记-扫描”式的垃圾回收器。 五、导致Gc的情况：1、tenured被写满 2、perm被写满 3、System.gc()的显式调用。 4、上一次GC之后heap的各域分配策略动态变化。 六、GC运行的三种方式在java5和java6中有4中垃圾回收的算法，有一种算法将不再支持，剩余的三种垃圾回收算法是：serial, throughput and concurrent low pause。 Stop the world（停止所有程序的方式）：在这种方式运行的GC，在GC完成前，JVM中的所有程序都不允许运行。Serial collector此时做minor和major收集。Throughput collector此时做major collector。 Incremental（增量运行方式）：目前没要Java GC算法支持这种运行方式。GC以这种方式运行时，GC允许程序做一小段时间的工作，然后做垃圾回收工作。 Concurrent（并行运行）：Throughput collector此时做minor collect，Concurrent low pause collector此时做minor和major收集。在这种运行方式下，GC和程序并行的运行，因此程序仅仅被短暂的暂停。 七、关于finalize方法的问题finalize方法使得GC过程做了更多的事情，增加的GC的负担。 如果某个对象的finalize方法运行时间过长，它会使得其他对象的finalize方法被延迟执行。 finalize方法中如果创建了strong reference引用了其他对象，这会阻止此对象被GC。 finalize方法有可能以不可确定的顺序执行（也就是说要在安全性要求严格的场景中尽量避免使用finalize方法）。 不确保finalize方法会被及时调用，也许程序都退出了，但是finalize方法还没被调用。 八、对象引用的类型Reference(or named Strong Reference)（ 强引用）：普通类型的引用。 SoftReference（ 软引用）：被这种引用指向的对象，如果此对象没要再被其他Strong Reference引用的话，可能在任何时候被GC。虽然是可能在任何时候被GC，但是通常是在可用内存数比较低的时候，并且在程序抛出OutOfMemoryError之前才发生对此对象的GC。SoftReference通常被用作实现Cache的对象引用，如果这个对象被GC了，那么他可以在任何时候再重新被创建。另外，根据JDK文档中介绍，实际JVM的实现是鼓励不回收最近创建和最近使用的对象。SoftReference 类的一个典型用途就是用于内存敏感的高速缓存。 WeakReference（弱引用）：如果一个被WeakReference引用的对象，当没要任何SoftReference和StrongReference引用时，立即会被GC。和SoftReference的区别是：WeakReference对象是被eagerly collected，即一旦没要任何SoftReference和StrongReference引用，立即被清楚；而只被SoftReference引用的对象，不回立即被清楚，只有当内存不够，即将发生OutOfMemoryError时才被清除，而且是先清除不常用的。SoftReference适合实现Cache用。WeakReference 类的一个典型用途就是规范化映射（ canonicalized mapping ） PhantomReference（虚引用）：当没有StrongReference，SoftReference和WeakReference引用时，随时可被GC。通常和ReferenceQueue联合使用，管理和清除与被引用对象（没有finalize方法）相关的本地资源。 ##]]></content>
      <categories>
        <category>JavaJVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot(1)--基础(servlet3+springMVC去除所有的xml)]]></title>
    <url>%2F2017%2F12%2F28%2Fspring-boot-1-%E5%9F%BA%E7%A1%80-servlet3-springMVC%E5%8E%BB%E9%99%A4%E6%89%80%E6%9C%89%E7%9A%84xml%2F</url>
    <content type="text"><![CDATA[在一些基于spring／spring mvc的java web项目中，总是会有一些xml配置文件，如web.xml、applicationContext.xml等，本文的目标是消除这些xml文件，使用代码和注解替代。由于本文是基于servlet3，所以首先采用的servlet3的容器，例如tomcat7以上版本、jetty8及以上版本。 消除web.xml下面是一个典型的web.xml,包涵spring／spring mvc的配置： 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 下一步去除web.xml文件，使用java代码替代下。Spring MVC提供了一个接口WebApplicationInitializer，用于替代web.xml文件。实现这个借口的类会在Servlet容器启动的时候自动加载并运行。将以上代码替换为Java代码: 123456789101112131415161718192021222324public class MyWebInitializer implements WebApplicationInitializer &#123; /** * Servlet容器启动时会自动运行该方法 * @param servletContext * @throws ServletException */ @Override public void onStartup(ServletContext servletContext) throws ServletException &#123; //初始化参数 servletContext.setInitParameter("contextConfigLocation","classpath:applicationContext" + ".xml"); //springMVC的servlet ServletRegistration.Dynamic dispatcher = servletContext.addServlet("dispatcher", new DispatcherServlet()); dispatcher.setLoadOnStartup(1); dispatcher.addMapping("/"); dispatcher.setInitParameter("contextConfigLocation","classpath:dispatcher-servlet.xml"); //添加监听 servletContext.addListener(new ContextLoaderListener()); &#125;&#125; 此时便可以删除web.xml。 去除spring mvc的配置文件dispatcher-servlet.xml一个典型的spring mvc配置文件如下 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;mvc:annotation-driven/&gt; &lt;context:component-scan base-package="org.wuqinghua.web"/&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;/beans&gt; Spring提供了@Configuration注解替代xml配置文件，@Bean注解可以替代xml中的来创建bean。将以上xml配置文件转换为Java代码。 12345678910111213@Configuration@EnableWebMvc //开启支持mvc@ComponentScan(basePackages = "org.wuqinghua.web")public class SpringMVCConfig &#123; @Bean public InternalResourceViewResolver internalResourceViewResolver() &#123; InternalResourceViewResolver viewResolver = new InternalResourceViewResolver(); viewResolver.setPrefix("/WEB-INF/views/"); viewResolver.setSuffix(".jsp"); return viewResolver; &#125;&#125; 去除spring配置文件applicationContext.xmlspring配置文件中的配置比较多，根据不同的项目还有不同的配置，一下提供了一个简单的配置： 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="org.wuqinghua"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"&gt;&lt;/context:exclude-filter&gt; &lt;/context:component-scan&gt; &lt;context:property-placeholder location="classpath:dataSource.properties"/&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/bean&gt;&lt;/beans&gt; 其中的配置文件dataSource.properties文件 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/taotao?useUnicode=true&amp;characterEncoding=utf-8jdbc.username=rootjdbc.password=root 将以上代码转换为java代码为 12345678910111213141516171819202122232425262728293031323334353637@Configuration@ComponentScan(basePackages = "org.wuqinghua", excludeFilters = &#123;@ComponentScan.Filter(value = Controller.class)&#125;)public class SpringConfig &#123; @Value("$&#123;jdbc.driver&#125;") private String driver; @Value("$&#123;jdbc.url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;jdbc.password&#125;") private String password; @Bean public DataSource dataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125; /** * 必须添加static * * @return */ @Bean public static PropertyPlaceholderConfigurer loadProperties() &#123; PropertyPlaceholderConfigurer placeholderConfigurer = new PropertyPlaceholderConfigurer(); ClassPathResource resource = new ClassPathResource("dataSource.properties"); placeholderConfigurer.setLocation(resource); return placeholderConfigurer; &#125;&#125; 修改MyWebAppInitializer.java1234567891011121314151617181920212223242526public class MyWebInitializer implements WebApplicationInitializer &#123; /** * Servlet容器启动时会自动运行该方法 * * @param servletContext * @throws ServletException */ @Override public void onStartup(ServletContext servletContext) throws ServletException &#123; AnnotationConfigWebApplicationContext rootContext = new AnnotationConfigWebApplicationContext(); rootContext.register(SpringConfig.class); servletContext.addListener(new ContextLoaderListener(rootContext)); AnnotationConfigWebApplicationContext webContext = new AnnotationConfigWebApplicationContext(); webContext.register(SpringMVCConfig.class); ServletRegistration.Dynamic registration = servletContext.addServlet("dispatcher", new DispatcherServlet(webContext)); registration.setLoadOnStartup(1); registration.addMapping("/"); &#125;&#125;]]></content>
      <categories>
        <category>java spring</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql(一)--数据库基础]]></title>
    <url>%2F2017%2F11%2F07%2Fmysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数据库基础1.什么是数据库?数据库：database，存储数据的仓库，高效的存储和处理数据的介质（介质主要是两种：磁盘和内存） 2.数据库分类?数据库基于存储介质的不同：分为两类：关系型数据库（SQL）和非关系型数据库（NoSQL：Not Only SQL，不是关系型的数据库都叫非关系型数据库） 3.不同的数据库阵营的产品有哪些？关系型数据库：Oracle、DB2、MySql等非关系型数据库:memcached、mongoldb、redis等 关系型数据库1.什么是关系型数据库?关系型数据库：是一种建立在关系模型（数学模型）上的数据库。关系模型：一种所谓建立在关系上的模型，关系模型包涵三个方面： 数据结构：数据存储的问题，二维表（有行和列） 操作指令集合: 所有sql语句 完整型约束: 表内数据约束(字段与字段),表与表之间约束（外键） 2.关键字数据库:database数据库系统:DBS(Database System):是一种虚拟系统，将多种内容关联起来的称呼DBS = DBMS+DBDBMS:Database Management System,数据库管理系统，专门管理数据库DBA:Database Administrator,数据库管理员行/记录:row/record,本质是一个东西：都是指表]]></content>
      <categories>
        <category>MySqL</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习(十)--远程仓库]]></title>
    <url>%2F2017%2F09%2F20%2FGit%E5%AD%A6%E4%B9%A0-%E5%8D%81-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[转载廖雪峰的官方网站 创建github账号请自行百度 配置github到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。 可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。 没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。 Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。 你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？ 其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。 实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。 完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。 在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。 确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习(九)--删除文件]]></title>
    <url>%2F2017%2F09%2F20%2FGit%E5%AD%A6%E4%B9%A0-%E4%B9%9D-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[转载廖雪峰的官方网站 删除文件在Git中，删除也是一种修改，先添加一个test.txt文件到Git并提交 12345$ git add test.txt$ git commit -m &quot;add test.txt&quot;[master 3f4eef2] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt 一般情况下，你可以直接在文件系统中将其删除，或者使用rm命令删除 1rm test.txt 这个时候工作区和版本库的就不一致了，git status命令就会告诉你删除了哪些文件 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 现在你有两个选择​ 1.确实需要将版本库中的文件删除（使用git rm &lt;file&gt;...在进行git commit提交）​ 2.误删了，需要将版本库的test.txt还原(使用git checkout -- &lt;file&gt;) 123456$ git rm test.txtrm &apos;test.txt&apos;$ git commit -m &quot;delete test.txt&quot;[master 894d519] delete test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： 1$ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 小结命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习(八)--撤销修改]]></title>
    <url>%2F2017%2F09%2F20%2FGit%E5%AD%A6%E4%B9%A0-%E5%85%AB-%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[转载廖雪峰的官方网站 撤销修改1.工作区文件撤销如果不小心在readme.txt中不小心添加一行： 123456$ cat readme.txt Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN. 在你准备提交的时候，发现stupid boss不是太合适。既然发现了，就可以及时的将其删除，删除最后一行，恢复到上个版本。你可以使用git status查看一下 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Git告诉你可以使用git checkout -- &lt;file&gt;可以丢弃工作区的修改 123456$ git checkout -- readme.txt$ cat readme.txt Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 果然，readme.txt又恢复到了原来的内容。 2.暂存区文件撤销再在readme.txt中添加一行 123456$ cat readme.txt Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN. 并且进行了git add操作,再通过git status查看一下状态 123456$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: readme.txt 同样的Git告诉我们可以使用git reset HEAD &lt;file&gt;...撤销暂存区的内容 123$ git reset HEAD readme.txtUnstaged changes after reset:M readme.txt git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。再用git status查看一下，现在暂存区是干净的，工作区有修改： 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 在通过git checkout -- &lt;file&gt;撤销工作区的修改 123456$ git checkout -- readme.txt$ cat readme.txt Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了…… 小结又到了小结时间。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习(七)--管理修改]]></title>
    <url>%2F2017%2F09%2F20%2FGit%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E7%AE%A1%E7%90%86%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[转载廖雪峰的官方网站 修改管理现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。 你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。 为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容： 12345$ cat readme.txt Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes. 然后，添加使用git add命令 1234567$ git add readme.txt$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: readme.txt 然后，在修改readme.txt 12345$ cat readme.txt Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 提交 123$ git commit -m &quot;git tracks changes&quot;[master 2fec10d] git tracks changes 1 file changed, 1 insertion(+) 这个时候在看看状态 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 咦，怎么第二次的修改没有被提交？ 别激动，我们回顾一下操作过程： 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit 你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别： 1234567891011$ git diff HEAD -- readme.txtdiff --git a/readme.txt b/readme.txtindex 76d770f..a9c5755 100644--- a/readme.txt+++ b/readme.txt@@ -1,4 +1,4 @@ Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage.-Git tracks changes.+Git tracks changes of files. 可见，第二次修改确实没有被提交。那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit 好，现在，把第二次修改提交了，然后开始小结。 小结现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习(六)--工作区和暂存区]]></title>
    <url>%2F2017%2F09%2F19%2FGit%E5%AD%A6%E4%B9%A0-%E5%85%AD-%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[转载廖雪峰的官方网站 工作区(Working Directory)就是在你电脑中可以看到的目录比如我们这里的learngit 版本库(Repository)在工作区中含有一个隐藏的目录.git，这个不是工作区，而是Git的版本库。在Git的版本库中存放了很多东西，其中最重要的就是被称为stage(或index)的暂存区，还有Git为我们自动创建的第一个分支master，以及一个指向master的指针HEAD 其中，分支和HEAD后面会讲。​ 前面我们将文件添加到Git版本库中分为两步。​ 第一步使用git add把文件添加进去，实际就是将文件添加到暂存区中；​ 第二步使用git commit提交修改，实际上就是将暂存区所有的内容添加到当前分支。​ 因为我们在创建Git版本库的时候，Git自动会为我们创建一个master分支，所以，现在git commit就是往master分支上提交。​ 你可以简单的理解为，先将需要提交修改的文件统统放入到暂存区，然后一次性提交暂存区的所有修改。下面我们在实践一下：​ 先对readme.txt进行修改,比如添加一行 123Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage. ​ 然后在添加一个文件LICENSE文本文件 1apache license ​ 先使用git status查看状态 1234567891011121314$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) LICENSEno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) ​ Git非常清楚的告诉我们，readme.txt被修改了，LICENSE还从来没有被添加过，所以它的状态为Untracked。​ 现在使用命令git add,把readme.txt和LICENSE文件都添加到暂存区，用git status查看一下状态. 12345678$ git add .$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: LICENSE modified: readme.txt ​ 现在暂存区的状态就变为 ​ 所以，git add命令实际上是将要提交的所有的修改放倒暂存区（stage）,然后，执行git commit就可以一次性把暂存区所有的修改提交到分支。 1234$ git commit -m &quot;understand how stage works&quot;[master eb1b3cd] understand how stage works 2 files changed, 2 insertions(+) create mode 100644 LICENSE 一旦提交后，如果没有对工作区做任何修改，那么工作区就是干净的。 123$ git statusOn branch masternothing to commit, working tree clean 现在版本库就变为​ 小结暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。 没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习(五)--版本回退]]></title>
    <url>%2F2017%2F09%2F19%2FGit%E5%AD%A6%E4%B9%A0-%E4%BA%94-%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80%2F</url>
    <content type="text"><![CDATA[转载廖雪峰的官方网站 查看提交版本现在我们已经学会了修改文件，然后把修改后的文件提交到Git版本库，现在，我们在联系一次，修改readme.txt文件如下。 12Git is a distributed version control system.Git is free software distributed under the GPL. 然后尝试提交 1234$ git add readme.txt $ git commit -m &quot;append GPL&quot;[master d6715a5] append GPL 1 file changed, 1 insertion(+), 1 deletion(-) ​ 像这样，你不断的对文件进行修改，然后不断的提交修改到版本库中，这个就像大家玩RPG游戏似的，每通关一关就会自动将游戏状态存盘，如果某一关没有过去，就可以选择读取上一关的状态。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以保存一个“快照”，这个“快照”在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。​ 现在，我们回顾一下readme.txt文件一共又几个版本被提交到Git仓库中版本1：wrote a readme file 12Git is a version control system.Git is free software. 版本2：add distributed 12Git is a distributed version control system.Git is free software. 版本3：append GPL 12Git is a distributed version control system.Git is free software distributed under the GPL. 当然，在实际工作中，我们不可能记得每次修改的内容，不然要版本控制系统干什么。版本控制系统中肯定含有命令可以告诉我们历史记录，在Git中，我们用git log命令查看： 123456789101112131415161718git logcommit d6715a56b8e891b6e3894b4e2662fa67340f562aAuthor: wuqinghua &lt;zffwqh@126.com&gt;Date: Tue Sep 19 13:00:16 2017 +0800 append GPLcommit bf483385124eb7e4634cbdc1a293eeba19c17818Author: wuqinghua &lt;zffwqh@126.com&gt;Date: Tue Sep 19 12:49:41 2017 +0800 add distributedcommit ead05c0c5508b9a3d7e7e36896e8524c5c7fae47Author: wuqinghua &lt;zffwqh@126.com&gt;Date: Tue Sep 19 11:26:34 2017 +0800 wrote a readme file ​ git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近一次是append GPL,上一次是add distributed,最早一次是wrote a readme file。​ 如果嫌输出的信息太多，看不清晰，可以尝试添加上--pretty=oneline参数: 1234$ git log --pretty=onelined6715a56b8e891b6e3894b4e2662fa67340f562a append GPLbf483385124eb7e4634cbdc1a293eeba19c17818 add distributedead05c0c5508b9a3d7e7e36896e8524c5c7fae47 wrote a readme file ​ PS:日志中的前面的一串字符串为提交的id commit id 进行版本回退​ 现在我们就可以开启时光穿梭机了，准备将readme.txt回退到上个版本，也就是回退到add distribute的那个版本，怎么做呢?​ 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是d6715a...67340f562a(我的提交id肯定和你的不一样)，上一个版本就是HEAD^，上上个版本就是HEAD^^，当然往上100个版本写上100个^不容易写出了,所以可以写成HEAD-100​ 现在，我们要把当前版本append GPL回退到add distributed，就可以使用git reset命令 12$ git reset --hard HEAD^HEAD is now at bf48338 add distributed --hard参数的含义我们后面会讲，现在先使用现在看看readme.txt的内容是不是回退到上个版本的内容了，也就是是否为add distributed了 123cat readme.txt Git is a distributed version control system.Git is free software. 还可以恢复到上个版本wrote a readme file,我们先使用git log在看看提交的记录 123456789101112$ git logcommit bf483385124eb7e4634cbdc1a293eeba19c17818Author: wuqinghua &lt;zffwqh@126.com&gt;Date: Tue Sep 19 12:49:41 2017 +0800 add distributedcommit ead05c0c5508b9a3d7e7e36896e8524c5c7fae47Author: wuqinghua &lt;zffwqh@126.com&gt;Date: Tue Sep 19 11:26:34 2017 +0800 wrote a readme file 最新的那个append GPL已经看不到，这个就好比，21世纪的人穿梭到19世纪，回不去了，怎么版？办法其实还是存在的，比如如果你的终端没有关闭的话，可以在上面找到那个append GPL的commit id是d6715a56b8e891b6e3894b4e2662fa67340f562a,于是就可以指定回到未来的某个版本。 12$ git reset --hard d6715a56b8eHEAD is now at d6715a5 append GPL ​ 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。​ 这个时候再查看一下文件。 123$ cat readme.txt Git is a distributed version control system.Git is free software distributed under the GPL. ​ 果然，又回到了add GPL版本​ Git的版本回退速度非常的快，因为在Git中含有一个指向HEAD指针，当你回退版本的时候，Git仅仅是将HEAD指向append GPL 修改为指向add distributed 然后顺便将工作区的文件更新了。所以你让HEAD指向哪个版本，你就把当前的版本定位在哪里。 但是如果，你回退到哪个版本之后，关掉了电脑，第二天后悔了，想要恢复怎么办？找不到commit id了。在Git中总是有方式决解的。当你用git reset --hard HEAD^回退到add distributed版本时，再想恢复到add GPL就必须找到add GPL的commit id。在Git中提供了一个命令git reflog用来记录你的每一次命令: 123456$ git reflogd6715a5 HEAD@&#123;0&#125;: reset: moving to d6715a56b8ebf48338 HEAD@&#123;1&#125;: reset: moving to HEAD^d6715a5 HEAD@&#123;2&#125;: commit: append GPLbf48338 HEAD@&#123;3&#125;: commit: add distributedead05c0 HEAD@&#123;4&#125;: commit (initial): wrote a readme file 可以看到第三行显示就为append GPL的commit id，现在你又可以使用git reset命令进行版本穿梭了 小结现在总结一下： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习(四)--Git的状态]]></title>
    <url>%2F2017%2F09%2F19%2FGit%E5%AD%A6%E4%B9%A0-%E5%9B%9B-Git%E7%9A%84%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[转载廖雪峰的官方网站 查看Git状态我们已经成功的添加并提交一个readme.txt文件，现在，我们继续修改文件,修改为一下内容 12Git is a distributed version control system.Git is free software. 现在，运行git status命令看看结果 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) git status命令可以让我们时刻掌握仓库的状态，上面的命令告诉我们，readme.txt被修改了，但是还没有准备提交的修改。虽然Git告诉我们readme.txt被修改了，但是如果能看到具体修改了什么内容，那就更好了。比如你长时间没有查看该文件，已经记不清楚上次修改的内容，所以在Git中提供了git diff命令来查看不同点。 123456789$ git diff readme.txtdiff --git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is free software. git diff 就是查看difference，显示的格式为Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。知道readme.txt作了修改的内容后，再把它提交到仓库就放心多了，提交修改和提交新文件的步骤是一致的。第一步：git add 1$ git add readme.txt 同样没有任何的输出。在执行第二步git commit之前，我们先在运行一下git status看看当前的仓库状态: 123456$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: readme.txt git status告诉我们待提交的文件含有readme.txt,下一步，就可以放心的提交了： 123$ git commit -m &quot;add distributed&quot;[master bf48338] add distributed 1 file changed, 1 insertion(+), 1 deletion(-) 提交之后，我们仔通过git status 查看当前仓库的状态： 123$ git statusOn branch masternothing to commit, working tree clean Git告诉我们当前没有需要提交的修改，而且，工作目录是干净的（working tree clean）的。 小结 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习(三)--创建版本库]]></title>
    <url>%2F2017%2F09%2F19%2FGit%E5%AD%A6%E4%B9%A0-%E4%B8%89-%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93%2F</url>
    <content type="text"><![CDATA[转载廖雪峰的官方网站 什么是版本呢？版本库又名仓库，英文名称repository，你可以简单的理解为一个目录，这个目录中的所有的文件都可以被Git管理起来，每个文件的修改、删除，Git都可以对其跟踪，以便任何时候都可以追踪历史，或在将来的某个时候进行还原。 创建版本首先，选择一个合适的地方，创建一个空目录 pwd命令为显示当前目录。在这里这个仓库位置为/Users/wuqinghua/git/learngit（尽量不要包涵中文和空格）第二步，通过git init命令把这个目录变成Git可以管理的仓库 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。 把文件添加到版本库​ 首先我们编写一个readme.txt文件，内容如下 12Git is a version control system.Git is free software. ​ PS:一定要放倒learngit目录或其子目录下，因为这是一个Git仓库，放倒其他地方Git发现不了 ​ 第二步，使用git add命令告诉Git，把文件添加到仓库 1git add readme.txt ​ 执行上面的命令，没有任何显示信息，这就对了，Unix的哲学就是“没有消息就是好消息”，说明添加成功。 ​ 第三步,使用git commit命令告诉Git，把文件提交到仓库 1234$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) ead05c0] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt ​ 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 嫌麻烦不想输入-m &quot;xxx&quot;行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。 git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： 123$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot; 小结现在总结一下今天学的两点内容： 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 第一步，使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习(二)--安装Git]]></title>
    <url>%2F2017%2F09%2F19%2FGit%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%E5%AE%89%E8%A3%85Git%2F</url>
    <content type="text"></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习(一)--Git简介]]></title>
    <url>%2F2017%2F09%2F19%2FGit%E5%AD%A6%E4%B9%A0-%E4%B8%80-Git%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA之IO--字符流(四)]]></title>
    <url>%2F2017%2F08%2F23%2FJAVA%E4%B9%8BIO-%E5%AD%97%E7%AC%A6%E6%B5%81-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[字符流处理文件字符流只能处理纯文本，全部为可见字符.步骤和使用字节流一致。(使用流Reader和Writer) 1.文件（纯文本）读取 123456789101112131415161718@Test public void readTest() throws IOException &#123; //1.创建文件关联 File src = new File("pom.xml"); //2.选择流 Reader reader = new FileReader(src); //3.操作 char[] chars = new char[1024]; @SuppressWarnings("unused") int len = 0; while((len=reader.read(chars, 0, 1024))!=-1) &#123; System.out.println(new String(chars)); &#125; //4.关闭流 reader.close(); &#125; 2.文件的写入 1234567891011121314151617181920212223@Test public void writerTest() throws IOException &#123; //1.写出的文件 File dest = new File("pom.txt"); //2.选择流 Writer writer = new FileWriter(dest); //3.操作 String mes="锄禾日当午\r\n汗滴禾下土\r\n谁知盘中餐\r\n粒粒皆辛苦"; char[] cbuf = mes.toCharArray(); writer.write(cbuf, 0, cbuf.length); //写入还可以使用一下两种方式 //writer.writer(mes); //writer.append(mes); writer.flush(); //4.关闭 writer.close(); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA之IO--字节流(三)]]></title>
    <url>%2F2017%2F08%2F21%2FJAVA%E4%B9%8BIO-%E5%AD%97%E8%8A%82%E6%B5%81-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[使用字节流进行文件操作1、读取文件 一般步骤：1）建立连接 File—&gt;2）选择流 InputStream —&gt;3)操作 byte[]+read—&gt;4)关闭 12345678910111213141516171819202122232425262728293031@Test public void readFile() &#123; // 1.建立连接 File File pom = new File("pom.xml"); // 2.选择流 InputStream in = null; try &#123; in = new FileInputStream(pom); // 3.操作 byte[] bytes = new byte[1024]; // 每次读取1024个字节 int len = 0;// 接收读取的大小 while ((len = in.read(bytes, 0, 1024)) != -1) &#123; System.out.println(new String(bytes, 0, len)); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); System.out.println("文件不存在！"); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println("读取文件失败!"); &#125; finally &#123; //4.释放资源 try &#123; if (null != in) &#123; in.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 2、写出文件一般步骤：1）建立连接 File—&gt;2）选择流 OutputStream —&gt;3)write+flush—&gt;4)关闭 12345678910111213141516171819202122232425262728293031@Test public void writeFile() &#123; // 1.建立联系 File File file = new File("test.txt"); // 2.选择流 OutputStream out = null; try &#123; out = new FileOutputStream(file, true);// 表示写文件是追加还是覆盖 // 3.操作 String msg = "hello world!\n"; byte[] data = msg.getBytes(); out.write(data, 0, data.length); out.flush();// 强制刷新出去 &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); System.out.println("文件找不到!"); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println("文件写出失败！"); &#125;finally &#123; try &#123; if (out != null) &#123; out.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println("关闭失败!"); &#125; &#125; &#125; 3、文件的拷贝就是将文件的读取和文件的写出就是文件的拷贝。 12345678910111213141516171819202122232425262728293031323334353637383940414243@Test public void copyFile() &#123; // 1.建立联系 File inFile = new File("pom.xml"); File outFile = new File("test.txt"); //只能拷贝文件 if(inFile.isFile)&#123; return; &#125; // 2.选择流 InputStream in = null; OutputStream out = null; try &#123; in = new FileInputStream(inFile); out = new FileOutputStream(outFile); // 3.操作 byte[] bytes = new byte[1024]; int len = 0; while ((len = in.read(bytes, 0, 1024)) != -1) &#123; out.write(bytes, 0, len); &#125; out.flush();// 强制刷新 &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (out != null) &#123; out.close(); &#125; if (in != null) &#123; in.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 4、文件夹的拷贝1234567891011121314151617181920212223242526272829303132@Test public void copyFile2() &#123; File inFile = new File("src"); File outFile= new File("outSrc"); try &#123; copy(inFile,outFile); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private void copy(File inFile, File outFile) throws IOException &#123; File nowOut = new File(outFile,inFile.getName()); //需要拷贝的文件名称 if(inFile.isDirectory()) &#123; nowOut.mkdirs(); //如果是目录就创建目录 for (File subFile : inFile.listFiles()) &#123; copy(subFile,nowOut); //递归调用 &#125; &#125;else &#123; //如果是文件就进行拷贝 InputStream in = new FileInputStream(inFile); OutputStream out = new FileOutputStream(nowOut); byte[] bytes = new byte[1024]; int len = 0; while((len=in.read(bytes, 0, 1024))!=-1) &#123; out.write(bytes, 0, len); &#125; out.flush(); out.close(); in.close(); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA之IO--流的原理(二)]]></title>
    <url>%2F2017%2F08%2F21%2FJAVA%E4%B9%8BIO-%E6%B5%81%E7%9A%84%E5%8E%9F%E7%90%86-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[一、概念​ 流：流动、流向（比如车流。。）从一端移动到另一段，那么就会出现源头和目的地，那么在代码中就是文件移动到代码获取网络上到程序等 。需要注意以程序为中心。 二、IO流的分类​ 1.流向:以程序为中心，输入流和输出流​ 2.数据：字节流：二进制，可以处理一切数据，比如文本、视频、音频等​ 字符流：文本文件，只能处理纯文本​ 3.功能：节点流：离源头比较近的，包裹源头​ 处理流：增强功能，提高效率 三、常用的一些流 ​ 1.字节流：​ 输入流：InputStream​ 输出流：OutputSteacm​ 2.字符流​ 输入流：Reader​ 输出流：Writer 操作流的一般步骤：(一般家为例)​ 1.选择需要搬家的的房子（关联房子） ——&gt;建立和文件的联系 2.选择搬家公司 ——&gt;选择对应的流​ 3.进行搬家 ——&gt;文件的读取｜写入​ 选择卡车 ——&gt;数组大小​ 运输​ 4.结束搬家 ——&gt;释放资源 过程为：​ 1)建立连接－－》2）选择合适的流－－》3）操作，选择数组的大小进行读取－－－》4）关闭流]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA之IO--FILE(一)]]></title>
    <url>%2F2017%2F08%2F21%2FJAVA%E4%B9%8BIO-FILE-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[File类​ 表示为文件和路径名的抽象表示，也就是系统中文件或文件夹在Java中表示形式，File不能直接操作文件，只能表示文件，如果需要操作文件，后面会使用到流。 1.File中的常量 pathSeparator:与系统有关的的路径分隔符 separator:与系统有关的名称分隔符12345@Test public void fileConstant() &#123; System.out.println(File.pathSeparator); //windows --&gt; ; linux --&gt; : System.out.println(File.separator); //windows \ linux / &#125; 2.绝对路径和相对路径​ 表示一个文件的位置信息，绝对路径表示从盘符开始表示其位置。绝对路径表示相对于一个位置，其位置的信息。 123456789101112/*** 比如在你的电脑上存在 d:/file/parent/test/test.txt**/@Test public void filePath() &#123; /**绝度路径**/ File file1 = new File("d:/file/parent/test"); /**相对路径**/ File file2 = new File(new File("d:/file/parent/test"),"text.txt"); File file3 = new File("abc.txt");//表示当前工程 &#125; 3.File的简单使用(常用的方法)1.文件名相关的操作getName():文件名称getPath():路径名，如果采用绝对路径那么返回的就是绝对路径，如果采用相对路径构建的File那么就是相对路径getAbsoluteFile():绝对路径对应的文件getAbsolutePath:绝对路径getParent():父目录,相对路径的父目录，可能为nullrenameTo(File newName);重命名 1234567891011@Test public void fileTest() &#123; //表示工程目录下的pom.xml File file = new File("pom.xml"); System.out.println("文件名称:"+file.getName()); System.out.println("绝对路径:"+file.getAbsolutePath()); System.out.println("路径:"+file.getPath()); //如果为绝度路径，返回绝对路径，否则相对路径 System.out.println("上级目录:"+file.getParent()); //相对路径返回null System.out.println("绝对文件:"+file.getAbsoluteFile()); System.out.println("绝对文件的上级目录:"+file.getAbsoluteFile().getParent()); //可以返回为上级目录 &#125; #####2.判断信息操作exists():是否存在canWrite():能否写入canRead()：能否进行读取isFile():判断是否为文件isDirectory():判断是否为文件夹isAbsolute():消除平台差异，windows是以盘符开头,其它以/ 12345678910@Test public void fileTest02() &#123; File file = new File("pom.xml"); System.out.println("文件是否存在:"+file.exists()); System.out.println("文件是否可读："+file.canRead()); System.out.println("文件是否可写："+file.canWrite()); System.out.println("是否为文件:"+file.isFile()); System.out.println("是否为文件夹:"+file.isDirectory()); System.out.println("是否为绝对路径构建："+file.isAbsolute()); &#125; #####3.长度length():文件的大小 #####4.创建和删除createNewFile():不存在创建新文件delete():删除文件static createTempFile(前缀3个字节，后缀默认.temp) 在默认的临时空间中创建临时文件static createTempFile(前缀3个字节，后缀默认.temp,目录) 在目录中创建临时文件deleteOnExit() 退出虚拟机删除，常用语删除临时文件 12345678910111213@Testpublic void fileTest03() throws IOException &#123; File file = new File("test.txt"); if(!file.exists()) &#123; file.createNewFile(); //文件不存在创建文件 &#125; file.delete();//删除文件 File fileTemp1 = File.createTempFile("abc", ".temp");//创建临时文件 File fileTemp2 = File.createTempFile("abc", ".temp", new File(".")); fileTemp1.deleteOnExit(); //退出时删除 fileTemp2.deleteOnExit();&#125; #####5.操作目录mkdir() 创建目录，但是父目录不存在不能创建mkdirs() 创建目录，父目录不存在也同时创建list() : 返回的为字符串数组，表示文件的字符串表示listFiles() :返回目录下的所有的字符串listFiles(FileFilter):进行过滤器过滤static listRoots(): 根目录1234567891011121314151617181920212223242526272829303132@Test public void fileTest04() throws IOException &#123; File file1 = new File("abc/ccc"); file1.mkdir();//创建目录，必须保证父路径存在 file1.mkdirs();//创建目录，父目录不存在，同时创建 //创建文件 for(int i = 0;i&lt;5;i++) &#123; File file = new File(file1,i+".txt"); if(!file.exists()) &#123; file.createNewFile(); &#125; &#125; String[] fileNames = file1.list();//返回目录中的文件字符串表示 System.out.println(Arrays.toString(fileNames)); File[] listFiles = file1.listFiles(); System.out.println(Arrays.toString(listFiles)); /**进行过滤器**/ File[] listFiles2 = file1.listFiles(new FileFilter() &#123; @Override public boolean accept(File pathname) &#123; return pathname.getName().endsWith("4.txt"); &#125; &#125;); System.out.println(Arrays.toString(listFiles2)); File[] listRoots = File.listRoots(); //获取跟目录 System.out.println(Arrays.toString(listRoots)); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM之运行时数据区-Runtime-Data-Area]]></title>
    <url>%2F2017%2F08%2F03%2FJVM%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-Runtime-Data-Area%2F</url>
    <content type="text"><![CDATA[Java虚拟机的自动内存管理机制1、Java内存区域与内存溢出异常​ Java虚拟机在执行Java程序的过程中会将其管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间，有的区域随着虚拟机进程启动而存在，有些区域依据用户线程启动和结束而建立和销毁。根据《Java虚拟机规范（第二版）》的规定，Java虚拟机所管理的内存包括以下几个运行时数据区域。 1、程序计数器​ 程序计数器(Program Counter Register)是一块较小的内存空间，它的作用可以看做为当前线程所执行字节码的行号指示器。在虚拟机的概念模型中（仅是概念模型，各种虚拟机可能会根据一些高效的方式实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。 ​ 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说为一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 ​ 如果线程正在执行的为一个Java方法，这个计数器纪录的是正在执行的虚拟机字节码指令地址；如果正在执行的是Native方法，这个计数器则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 2、Java虚拟机栈​ 与程序计数器一样，Java虚拟机栈（Java Virtual Machie Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 ​ 经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。其中所讲的“堆”在后面会专门的讲述，而所指的“栈”就是现在讲的虚拟机栈，或者虚拟机栈中的局部变量表部分。 ​ 局部变量表存放了编译期可知的各种基本数据类型（byte、short、int、long、double、float、char、boolean）、对象引用（reference类型，它不等同与对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的指针，也可能表示指向一个对象的句柄或者其它与此对象相关的位置）和returnAddress类型（指向一条字节码指令地址）。 ​ 其中64位长度的long和double类型的数据会占用两个局部变量的空间（slot），其余的数据类型只占用一个。局部表所需的内存在编译期间完成分配，当进入一个方法的时候，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 ​ 在Java虚拟机规范中，对这个区域规定了两种异常情况；如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分Java虚拟机都可以动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。 3、本地方法栈​ 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的， 其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到Native方法服务。虚拟机规范中本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由的实现它。甚至有些虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 4、Java堆​ 对于大多数引用来讲，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有的线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这点在Java虚拟机中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上渐渐变得不是那么“绝对”了。 ​ Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”（Garbage Collected Heap）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间，From Survivor空间、To Survivor空间等。如果从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过，无论如何划分，都与存放的内容无关，无论哪个区域，存放的都仍然是对象的实例，进一步的划分的目的是为了更好的回收内存，或者更快地分配内存。 ​ 根据Java虚拟机规范规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 5、方法区​ 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被Java虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范将方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做NonHeap（非堆），目的是与Java堆分开。 ​ 对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意将方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其它虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。即时是HotSpot虚拟机本身，根据官方路线图信息，现在也有放弃永久代并“搬家”至Native Memory来实现方法区的规划了。 ​ Java虚拟机规范对这个区域的限制非常的宽松，除了和Java堆一样不需要连续的内存和可以固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当的苛刻，但是这区域的回收确实比较有必要的。在Sun公司的BUG列表中，曾出现过若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收导致内存泄漏。 ​ 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 6、运行时常量池​ 运行时常量池（Runtime Constant Pool）是方法的一部分。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 ​ Java虚拟机对Class文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储那种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。 ​ 运行时常量池相对Class文件常量池的另一个重要的特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特征被开发人员利用得比较多的便是String类的intern（）方法。 ​ 既然运行时常量池是方法区的一部分，自然会受到方法区的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 7、直接内存​ 直接内存（Direct Memory）并不是虚拟机运行时数据区一部分，也不是Java虚拟机规范中定义的内存区域，但是这个内存也被频繁使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。 ​ 在JDK1.4中新加入NIO（New Input／Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I／O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 ​ 显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM及SWAP区或者分页文件）的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。 2、对象访问​ 介绍完Java虚拟机的运行时运行时数据区之后，我们就可以来探讨一个问题：在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码： 1Object obj = new Object(); ​ 假如这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java栈的本地变量表中，作为reference类型数据出现。而“new Object()”这部分语义会反应到Java堆中，形成一块存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。 ​ 由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。 如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄包含了对象实例数据和类型数据各自的具体地址信息。如下图所示 如果使用直接指针访问方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如下图所示 ​ 这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。 ​ 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就Sun HotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。]]></content>
      <categories>
        <category>JavaJVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言学习(四)--顺序编程(二)]]></title>
    <url>%2F2017%2F07%2F11%2Fgo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E5%9B%9B-%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 流程控制​ 程序设计语言的流程控制语句,用于设定计算执行的次序,建立程序的逻辑结构。可以说,流程控制语句是整个程序的骨架。 ​ 从根本上讲,流程控制只是为了控制程序语句的执行顺序,一般需要与各种条件配合,因此,在各种流程中,会加入条件判断语句。流程控制语句一般起以下3个作用:  选择,即根据条件跳转到不同的执行序列;  循环,即根据条件反复执行某个序列,当然每一次循环执行的输入输出可能会发生变化;  跳转,即根据条件返回到某执行序列。 Go语言支持如下的几种流程控制语句:  条件语句,对应的关键字为if、else和else if;  选择语句,对应的关键字为switch、case和select(将在介绍channel的时候细说);  循环语句,对应的关键字为for和range;  跳转语句,对应的关键字为goto。 在具体的应用场景中,为了满足更丰富的控制需求,Go语言还添加了如下关键字:break、continue和fallthrough。在实际的使用中,需要根据具体的逻辑目标、程序执行的时间和空间限制、代码的可读性、编译器的代码优化设定等多种因素,灵活组合。 接下来简要介绍一下各种流程控制功能的用法以及需要注意的要点。 1.条件语句​ 关于条件语句的示例代码: 12345if a &lt; 5 &#123; return 0&#125;else&#123; return 1&#125; ​ 关于条件语句,需要注意以下几点:  条件语句不需要使用括号将条件包含起来();  无论语句体内有几条语句,花括号{}都是必须存在的;  左花括号{必须与if或者else处于同一行;  在if之后,条件语句之前,可以添加变量初始化语句,使用;间隔; ​ 2.选择语句根据传入的条件不同，选择语句会执行不同的语句。下面的例子根据传入的整形变量i不同而打印不同的的内容。 123456789101112switch i &#123; case 0: fmt.Println(0) case 1: fmt.Println(1) case 2: fallthrough case 4, 5, 6: fmt.Println("4,5,6") default: fmt.Println("Default") &#125; 比较有意思的为，switch后面的表达式甚至不是必须的，比如 123456789Num := 3switch &#123;case 0 &lt;= Num &amp;&amp; Num &lt;= 3: fmt.Println("0-3")case 4 &lt;= Num &amp;&amp; Num &lt;= 6: fmt.Println("4-6")case 7 &lt;= Num &amp;&amp; Num &lt;= 9: fmt.Println("7-9")&#125; 在使用switch结构时,我们需要注意以下几点:  左花括号{必须与switch处于同一行;  条件表达式不限制为常量或者整数;  单个case中,可以出现多个结果选项;  与C语言等规则相反,Go语言不需要用break来明确退出一个case;  只有在case中明确添加fallthrough关键字,才会继续执行紧跟的下一个case; 可以不设定switch之后的条件表达式,在此种情况下,整个switch结构与多个if…else…的逻辑作用等同。 3.循环语句 与多数语言不同，Go语言只支持for关键字，不支持while和do while结构。 1234sum := 0for i := 0; i &lt; 10 ; i++&#123; sum+=i&#125; 可以看到比较大的一个不同在于for后面的条件表达式不需要用圆括号()包含起来。Go语言 还进一步考虑到无限循环的场景,让开发者不用写无聊的for (;;) {} 和 do {} while(1);, 而直接简化为如下的写法: 1234567sum := 0for &#123; sum++ if sum &gt; 100&#123; break &#125;&#125; 在条件表达式中也支持多重赋值,如下所示: 1234a := []int&#123;1, 2, 3, 4, 5, 6&#125;for i, j := 0, len(a) – 1; i &lt; j; i, j = i + 1, j – 1 &#123; a[i], a[j] = a[j], a[i]&#125; 使用循环语句时,需要注意的有以下几点。  左花括号{必须与for处于同一行。  Go语言中的for循环与C语言一样,都允许在循环条件中定义和初始化变量,唯一的区别是,Go语言不支持以逗号为间隔的多个赋值语句,必须使用平行赋值的方式来初始化多个变量。 Go语言的for循环同样支持continue和break来控制循环,但是它提供了一个更高级的 break,可以选择中断哪一个循环,如下例: 12345678for j := 0; j &lt; 5; j++ &#123; for i := 0; i &lt; 10; i++ &#123; if i &gt; 5 &#123; break JLoop &#125; fmt.Println(i) &#125;&#125; JLoop:// ... 本例中,break语句终止的是JLoop标签处的外层循环。 4.跳转语句goto语句被多数语言学者所反对,谆谆告诫不要使用。但对于Go语言这样一个惜关键字如 6金的语言来说,居然仍然支持goto关键字,无疑让某些人跌破眼镜。但就个人一年多来的Go语言编程经验来说,goto还是会在一些场合下被证明是最合适的。 goto语句的语义非常简单,就是跳转到本函数内的某个标签,如: 123456789func myfunc()&#123; i:=0 HERE: fmt.Println(i) i++ if(i&lt;10)&#123; goto HERE &#125;&#125; 函数​ 函数构件了代码执行的逻辑结构。在Go语言中，函数的基本组成为：func关键字、函数名、参数列表、返回值、函数体和返回语句。 1.函数定义前面已经大概的介绍过函数,这里我们使用一个简单的加法函数： 1234567891011121314package mymathimport ( "errors")func Add(a, b int) (ret int, err errors) &#123; if a &lt; 0 || b &lt; 0 &#123; //假设这函数只支持两个非负数的加法 err = errors.New("Should be non-negative numbers!") return &#125; return a + b, nil //支持重返回&#125; 2.不定参数]]></content>
      <categories>
        <category>GoLang</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言学习(三)--顺序编程]]></title>
    <url>%2F2017%2F07%2F09%2Fgo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E4%B8%89-%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[[TOC] 1.变量​ 变量几乎是所有编程语言中最基本的的组成元素。从根本上讲，变量相当于是对一块数据存储空间的命名，程序可以通过定义一个变量来申请一块数据存储空间，之后通过引用变量名来使用这块存储空间。 1.1变量的声明Go语言中的变量定义和其它的编程语言有很大的不同，Go中使用var关键子，而且类型信息放在变量名之后,如下: 12345678910var v1 intvar v2 stringvar v3 [10]int //数组var v4 []int //数组切片var v5 struct &#123; //结构 f int&#125;var v6 *int //指针var v7 map[string]int //map,key为string类型，value为int类型var v8 func(a int) int //函数 每一行结束都不需要使用分号，也就是说Go不是用分号作为语句的结束标记的习惯。 var还有另一种的使用方式－－可以将若干个声明的变量放置在一起，免的程序员需要重复写var关键字，如下: 1234var ( v9 int v10 string) 1.2变量的初始化对于声明变量时需要进行初始化的场景，var关键字可以保留，但是不再是必要元素，如下： 123var v11 int = 10 //正确使用方式一var v12 = 10 //正确使用方式二，编译器可以推导出v12的类型v13 := 10 //正确使用方式三，编译器可以推导出v13的类型 ​ 以上三种用法的效果是完全一致。与第一种用法比较，第三种用法需要输入的字符大大减少，是懒程序员和聪明的程序员的最佳选择。第三种方式是Go语言中引用（冒号和等号的组合:=）,用于明确表达同时变量申明和初始化的工作。 ​ ⚠️ 申明在:=左侧的变量不应该是已经被声明过的，否则会导致编译错误，比如： 12var i inti := 2 ​ 会出现no new variables on left side of := 1.3变量赋值在Go语言中，变量初始化和变量赋值是两个不同的概念。下面为声明一个变量之后的赋值过程： 12var i inti = 123 Go语言的变量赋值与多数语言一致，但Go还提供了一种多重赋值功能，比如下面这个交换i和j变量的语句： 1i,j = j,i 而在不支持多重赋值的语言中，交换两个变量的内容需要引入一个中间变量： 1t = i;i = j;j = t; 1.4匿名变量​ 我们在使用一些传统的强类型编程语言，经常会出现如下情况，即在调用函数时为了获取一个值，却因为该函数返回多个值而不得不定义一堆没有意义的变量。在Go语言中和结合多重返回和匿名变量来避免这种丑陋的写法，让代码看起来更加的优雅。 ​ 假设GetName()函数定义如下，它返回3个值，分别为firstName，lastName和nickName： 123func GetName()(firstName,lastName,nickName string)&#123; return "Mary","Chan","Chibi Maruko"&#125; ​ 若只想获取nickName，则函数的语句可以使用如下方式: 1_,_,nikeName := GetName() ​ 这种用法可以让代码非常清晰,基本上屏蔽掉了可能混淆代码阅读者视线的内容,从而大幅降低沟通的复杂度和代码维护的难度。 2.常量​ 在Go语言中常量表示在编译期间就已知且不可改变的值。常量的类型可以为数值类型（包括整型、浮点型和复数类型）、布尔类型和字符串类型等。 2.1字面常量​ 所谓字面常量（literal），是指程序中硬编码的常量，如: 12345－123.14159265358979323846 //浮点类型的常量3.2 + 12i //复数类型的常量true //布尔类型的常量"foo" //字符串类型的常量 2.2常量的定义​ 通过const关键字，你可以给字面量定义一个友好的名字： 12345678const PI = 3.14159265358979323846 const zero = 0.0const &#123; size int64 = 1024 eof = -1&#125;const u,v float32 = 0, 3const a,b,c = 3,4,"foo" ​ Go中的常量可以限定类型，但不是必须的。 ​ 常量定义的右值也可以是一个在编译期间运算的表达式，比如 1const mask = 1&lt;&lt;3 ​ 由于常量的赋值是一个在编译期间的行为，所有右值不能出现任何需要在运行期才能得出结果的表达式，比如试图以如下方式定义常量就会出现编译错误。 1const Home = os.GetEnv("HOME") ​ 因为os.GetEnv()只有在运行期才知道返回结果，在编译期间并不能确定，所有无法作为常量定义的右值。 2.3 预定义常量​ Go语言中预定义了这些常量：true、false和iota。 ​ iota比较特殊，可以认为是一个可被编译器修改的常量，在每一个const出现时被重置为0，然后在下一个const出现之前，每出现一次iota，其所代表的数值会自动增1. ​ 比如; 1234567891011121314151617181920const ( //iota被重置 c0 = iota //c0 == 0 c1 = iota //c1 == 1 c2 = iota //c2 == 2)const( a = 1 &lt;&lt; iota //a == 1 (iota在每个const开始被重设为0) b = 1 &lt;&lt; iota //b == 2 c = 1 &lt;&lt; iota //c == 4)const( u = iota * 42 // u == 0 v float64= iota * 42 // v == 42.0 w = iota * 42 // w == 84)const x = iota // x == 0 (因为iota又被重置)const y = iota // y == 0 ​ 如果两个const表达式的赋值语句一致，那么可以省略后一个赋值表达式。因此上面的前两个const语句可以简写为： 1234567891011const( c0 = iota c1 c2 )const( a = 1 &lt;&lt; iota b c) 2.4 枚举​ 枚举指一系列相关的常量，比如下面关于一个星期中的每天的定义。 12345678910const( Sunday = iota Monday Tuesday Wednesday Thursday Friday Saturday numberOfDays //这个常量没有导出 ) ​ 同Go语言的其他符号(symbol)一样,以大写字母开头的常量在包外可见。以上例子中numberOfDays为包内私有,其他符号则可被其他包访问。 3.类型​ Go语言内置一下基础类型： 布尔类型:bool 整型:int8、uint8(byte)、int16、int、uint、intptr等 浮点类型:float32、float64 复数类型:complex64、complex128 字符串:string 字符类型:rune 错误类型:error 此外Go语言还支持一下这些符合类型: 指针(pointer) 数组(array) 切片(slice) 字典(map) 通道(chan) 结构体(struct) 接口(interface) 3.1布尔类型​ Go语言中的布尔类型与其他语言基本一致,关键字也为bool,可赋值为预定义的true和 false示例代码如下: 123var v1 boolv1 = truev2 := (1 == 2) // v2也会被推导为bool类型 布尔类型不能接受其他类型的赋值,不支持自动或强制的类型转换。以下的示例是一些错误的用法,会导致编译错误: 123var b boolb=1// 编译错误b = bool(1) // 编译错误 以下的用法才是正确的: 123var b boolb = (1!=0) // 编译正确fmt.Println("Result:", b) // 打印结果为Result: true 3.2整型整型是所有编程语言里最基础的数据类型。Go语言支持如下整型类型。 类型 长度（字节） 范围值 int8 1 -128~127 uint8(byte) 1 0~255 int16 2 -32768~32768 uint16 2 0~65535 int32 4 -2147483648~2147483647 uint32 4 0~4294967295 int64 8 -9223372036854775808~9223372036854775807 uint64 8 0~18446744073709551615 int 平台相关 平台相关 uint 平台相关 平台相关 uintptr 同指针 32位平台下为4字节,64位平台下为8字节 3.2.1整型表示需要注意的是，int和int32在Go语言中被认为是两种不同的类型，编译器也不会帮你自动的转换，比如以下的例子会有编译错误: 123var v1 int32v2 := 32 //v2会被自动推导为int类型v1 = v2 //编译错误 编译错误类似于: cannot use value1 (type int) as type int32 in assignment。 可以使用强制类型转换可以解决： 1v1 = int32(v2) 当然,开发者在做强制类型转换时,需要注意数据长度被截短而发生的数据精度损失(比如浮点数强制转为整数)和值溢出(值超过转换的目标类型的值范围时)问题。 3.2.2数值运算Go语言支持如下常规运算符:+、－、＊、／、％ 分别就为加、减、乘、除、取余。 3.2.3比较运算Go语言支持的比较运算符有:&gt;、&lt; 、== 、&gt;= 、&lt;= 和 !=。这一点与大多数其它语言相同，与c语言完全一致。 1234i,j := 1 ,2if i==j &#123; fmt.Println("i and j are equal.")&#125; 两个不同的类型的整型数不能直接比较，比如int8类型的数和int类型的数不能直接比较，但是各种类型的整形变量与字面量直接比较，比如: 123456789101112var i int32var j int64i,j = 1,2if i==j &#123; //编译错误 fmt.Println("i and j are equal.")&#125;if i==1 || j==2 &#123;//编译通过 fmt.Println("i and j are equal.")&#125; 3.2.4 位运算Go语言支持的位运算符。 运算 含义 样例 x &lt;&lt; y 左移 124 &lt;&lt; 2 //结果为496 x &gt;&gt; y 右移 124 &gt;&gt; 2//结果为31 x ^ y 异或 124 ^ 2//结果为126 x &amp; y 与 124 &amp; 2//结果为0 x \ y 或 124 \ 2//结果为126 ^x 取反 ^2//结果为-3 3.3浮点型​ 浮点型用于表示包含小数点的数据,比如1.234就是一个浮点型数据。Go语言中的浮点类型采用IEEE-754标准的表达方式。 ​ 在Go语言中，定义一个浮点型变量的代码如下. 123var f1 float32f1 = 12f2 := 12.0 //如果不添加小数点，f2会被推导为整型而不是浮点型 ​ 对于以上的例子中f2会被推导为float64，因此对于以上的例子，下面的赋值回导致编译错误 1f1 = f2 ​ 而必须使用强制类型转换: 1f1 = float32(f2) ​ 浮点型的比较－－因为浮点型不是一种精确的表示方式，所以像整型那样直接使用＝＝来判断两个浮点型是否相同是不可行的，这样会导致不稳定的结果。 ​ 下面是一种推荐的方式： 123456import "math"//p为用户自定义的精度，比如0.00000001func IsEqual(f1,f2,p float64)&#123; return math.Fdim(f1,f2)&lt;p&#125; 3.4 复数类型复数实际上由两个实数(在计算机中用浮点数表示)构成,一个表示实部(real),一个表示虚部(imag)。如果了解了数学上的复数是怎么回事,那么Go语言的复数就非常容易理解了。 复数表示复数表示的示例如下: var value1 complex64 123value1 = 3.2 + 12ivalue2 := 3.2 + 12ivalue3 := complex(3.2, 12) 实部与虚部 // 由2个float32构成的复数类型// value2是complex128类型 // value3结果同 value2 对于一个复数z = complex(x, y),就可以通过Go语言内置函数real(z)获得该复数的实部,也就是x,通过imag(z)获得该复数的虚部,也就是y。 更多关于复数的函数,请查阅math/cmplx标准库的文档。 3.5字符串​ 在Go语言中字符串也是基本类型。Go语言中对字符串的声明和初始化非常简单，如下: 12345var str stringstr = "Hello world"ch := str[0]fmt.Printf("The length of \"%s\" is %d \n", str, len(str)) fmt.Printf("The first character of \"%s\" is %c.\n", str, ch) ​ 输出结果为: The length of “Hello world” is 11The first character of “Hello world” is H. ​ 字符串的内容可以通过类似数组下标的方式获取，但是与数组不同的是，字符串的内容不能在初始化后修改，比如以下的例子： 12str := "Hello world!"str[0] = 'x' //编译错误 3.5.1字符串操作平常的字符串操作如下所示: 运算 含义 样例 x + y 字符串链接 “hello”+”123” //结果为hello123 len(s) 字符串的长度 len(“hello”) //结果为5 s[i] 取字符 “Hello”[1] //结果为e ​ 更多的字符串操作请参考标准包strings 3.5.2字符串的遍历​ Go语言支持两种方式的遍历字符串。一种以字节数组的方式遍历： 123456789101112package mainimport "fmt"func main() &#123; str := "Hello,世界" n := len(str) for i := 0; i &lt; n; i++ &#123; ch := str[i] fmt.Println(i, ch) &#125;&#125; 执行结果如下: 0 721 1012 1083 1084 1115 446 2287 1848 1509 23110 14911 140 可以看出这个字符串长度为12。尽管直观上这个字符串只有8个字符,那是每个中文字符在UTF－8中占3个字节，而不是一个字节。 另一种采用Unicode字符遍历： 1234str := "Hello,世界" for i, c := range str &#123; fmt.Println(i, c) &#125; 执行结果: 0 721 1012 1083 1084 1115 446 199909 30028 因为在Unicode字符方式遍历时，每个字符的类型都为rune，而不是byte。 3.6字符类型​ 在Go语言中支持两种类型的字符类型，一个是byte(实际为uint8的别名),代表UTF－8字符串的单个字节的值；另一个是rune，代表单个Unicode字符。 ​ 关于rune的操作可以参考标准库中的unicode包。同时在unicode/utf-8包也提供了UTF－8和Unicode之间的转换。 ​ Go语言中多数的API都假设字符串为UTF－8编码。虽然Unicode在标准库中有支持，但是实际上较少使用。 3.7数组​ 数组是Go语言编程中最常用的数据结构之一。数组为一系列的同一类型数据的集合。数组中包含的每个数据被称为数组的元素（element），一个数组包含的元素个数被称为数组的长度。 ​ 以下为一些常规的数组声明方法： 1234567[32]byte //长度为32的数组，每个元素为一个字节[2*N] struct&#123; //结构类型数组 x,y int32&#125;[1000]*float64 //指针数组[3][5]int //二维数组[2][2][2]float64 //三维数组 ​ 数组的长度在定义后就不能修改了，声明的常量可以为一个常量或一个常量表达式。数组的长度是该数组中的一个内置常量，可以通过len()函数获取。长度不同的数组类型也是不同的比如： 123var a [32]intvar b [12]inta==b //编译错误 mismatched types [32]int and [12]int 3.7.1数组的访问​ 可以使用数组下标访问数组中元素，数组下标从0开始，len(array)-1表示最后一个元素的下标。如： 1234arr := [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;for i := 0; i &lt; len(arr); i++ &#123; fmt.Println(arr[i])&#125; ​ Go语言中还提供了一个range关键字，用于便捷地遍历容器中的元素。当然数组也是range的支持范围。上边的遍历可以简化为 1234arr := [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;for i, e := range arr &#123; fmt.Println("Element:", e, " Index:", i)&#125; ​ 在上面的例子中可以看出range含有两个返回值，第一个返回值表示数组的下标，第二个表示为元素值。 3.7.2值类型​ 需要注意的是，在Go语言中数组为一个值类型（value type）。所有的值类型变量在赋值和参数传递的时候都将产生一次复制动作。如果将数组作为函数的参数，则函数调用的时候将参数进行复制。因此，在函数中对数组进行修改，不会对原始的数组造成影响。 ​ 下面通过一个例子来看看这个特点： 1234567891011121314package mainimport "fmt"func modify(arr [5]int) &#123; arr[0] = 10 //尝试修改第一个元素 fmt.Println("In modify(),arr values:", arr)&#125;func main() &#123; arr := [5]int&#123;1, 2, 3, 4, 5&#125; modify(arr) fmt.Println("In main(),arr values:", arr)&#125; ​ 运行结果: In modify(),arr values: [10 2 3 4 5]In main(),arr values: [1 2 3 4 5] 3.8数组切片​ 前面我们看到数组的特点：数组的长度在定义后无法再次修改；数组是值类型，每次传递都将会产生一个副本。显然这种数据结构无法满足开发者真正的需求。 ​ 那么Go语言提供了切片（slice）这个非常酷的功能来满足数组的不足。 ​ 初看起来，数组就像一个指向数组的指针，实际上它拥有自己的数据结构，而不仅仅是指针。数组切片的数据结构可以抽象为3个变量： 一个指向原生数组的指针 数组切片中的元素的个数 数组切片已分配的存储空间 3.8.1创建数组切片创建数组切片的方法主要有两种－－基于数组和直接创建。 1.基于数组创建​ 数组切片的创建可以基于一个已存在的数组。数组切片可以使用数组的一部分或整个数组来创建，甚至可以创建一个比所基于的数组还要大的数组切片。 下面是一个数组创建切片的实例：slice.go 1234567891011121314151617181920212223package mainimport "fmt"func main() &#123; //先定义一个数组 var myArr [10]int = [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; //基于数组创建一个切片 var mySlice = myArr[:5] fmt.Println("Element of myArray: ") for _, v := range myArr &#123; fmt.Print(v, " ") &#125; fmt.Println("\nElement of mySlice:") for _, v := range mySlice &#123; fmt.Print(v, " ") &#125; fmt.Println()&#125; 运行结果为： Element of myArray:1 2 3 4 5 6 7 8 9 10Element of mySlice:1 2 3 4 5 ​ Go语言中支持myArray[first:last]这样的方式来基于数组生成一个数组切片（左闭右开），而且这个用法还很灵活，比如下面的几种方式都是合法的。 12345678//基于myArray所有元素创建mySlice := myArray[:]//基于myArray的前5个元素创建mySlice := myArray[:5]//基于从第5个元素开始的所有元素创建mySlice := myArray[5:] 2.直接创建​ 切片还可以通过直接创建的方式进行创建，Go语言提供了内置make()函数可以灵活的创建数组切片。下面显示直接创建数组的几种正确的方法。 12345678//创建一个初始元素为5个的切片，元素的初始值为0mySlice := make([]int,5)//创建一个初始元素为5的切片，元素初始值为0，并且预留10个元素的空间mySlice := make([]int,5,10)//直接创建并初始化包含5个元素的数组切片mySlice := []int&#123;1,2,3,4,5&#125; 3.8.2元素遍历​ 操作数组的所有的方法都可以使用在切片上，比如数组切片也可以使用下标读写元素，使用len()获取元素的个数，并可以使用range关键字遍历所有的元素。 123456789//传统的遍历方式如下for i:=0 ; i&lt;len(mySlice) ; i++ &#123; fmt.Println("mySlice[",i,"]=",mySlice[i])&#125;//使用range关键字遍历for i , v := range mySlice &#123; fmt.Println("mySlice[",i,"]=",v)&#125; 3.8.3动态增减元素​ 可动态的增减元素是数组切片比数组更为强大的功能。与数组相比，数组切片多了一个存储能力（capacity）的概念，即元素个数和分配的空间可以是两个不同的概念。合理的分配存储的空间，可以大幅度的降低数组切片内部重新分配内存和搬送内存块的频率，从而大大提高程序的性能。 ​ 数组切片支持Go语言内置的cap()和len()函数，cap()返回为数组切片分配的空间的大小,len()为数组切片中元素的个数。 123456789101112package mainimport ( "fmt")func main() &#123; mySlice := make([]int, 5, 10) fmt.Println("len(mySlice):", len(mySlice)) fmt.Println("cap(mySlice):", cap(mySlice))&#125; 运行结果为: len(mySlice): 5cap(mySlice): 10 ​ 如果需要往上面的mySlice已包含5个元素后面继续添加元素可以使用append()函数。下面的代码可以从尾端给mySlice加上3个元素，从而生成一个新的数组切片 1mySlice = append(mySlice,1,2,3) append()函数的第二个参数为一个不定参数，我们可以按照自己需求添加若干的参数，甚至可以将一个数组切片添加到另一个数组切片中。 12mySlice2 = []int&#123;7,8,9&#125;mySlice = append(mySlice,mySlice2...)//== mySlice = append(mySlice,mySlice2...) 需要注意的是上面的方法中第二个参数后面添加的…不能省略，因为需要将mySlice2打散后在传入。 3.8.4基于数组切片创建数组切片​ 类似数组切片可基于数组创建，数组切片也可以基于另一个数组切片创建。 12oldSlice := []int&#123;1,2,3,4,5&#125;newSlice := oldSlice[:3] //基于oldSlice的前3个元素 ​ 有意思的是，选择的oldSlice元素范围甚至可以超过所包含的元素个数，比如newSlice前6个元素创建，只要这个值不要超过oldSlice的cap值就可以了。 3.8.5内容复制​ 数组切片支持Go语言的另一个内置函数copy(),用于将内容从一个数组切片复制到另一个数组切片。如果加入的两个数组切片大小不一致，就会按照较小那个数组切片的元素个数进行复制。 12345slice1 := []int&#123;1, 2, 3, 4, 5&#125;slice2 := []int&#123;5, 4, 3&#125;copy(slice2, slice1)copy(slice1, slice2) 3.9 map​ 在Go语言中map未排序的健值对的组合。比如以身份证号为唯一主键来识别一个人的信息。 123456789101112131415161718192021222324252627282930package mainimport ( "fmt")type PersonInfo struct &#123; ID string Name string Address string&#125;func main() &#123; //创建map var personDB map[string]PersonInfo personDB = make(map[string]PersonInfo) //给map添加一下数据 personDB["12345"] = PersonInfo&#123;"12345", "Tom", "Room 203,..."&#125; personDB["1"] = PersonInfo&#123;"1", "Jack", "Room 101,..."&#125; //查询key为12345的值 person, ok := personDB["12345"] if ok &#123; fmt.Println("Found person ", person.Name, " with ID 1234.") &#125; else &#123; fmt.Println("Did not find person with ID 1234.") &#125;&#125; ​ 上面这个简单的例子基本上已经覆盖了map的主要用法,下面对其中的关键点进行细述。 变量声明 map的声明基本上没有多余的元素,比如:var myMap map[string] PersonInfo 其中,myMap是声明的map变量名,string是键的类型,PersonInfo则是其中所存放的值类型。 创建 我们可以使用Go语言内置的函数make()来创建一个新map。下面的这个例子创建了一个键类型为string、值类型为PersonInfo的map: myMap = make(map[string] PersonInfo)也可以选择是否在创建时指定该map的初始存储能力,下面的例子创建了一个初始存储能力 为100的map:myMap = make(map[string] PersonInfo, 100) 元素赋值 赋值过程非常简单明了,就是将键和值用下面的方式对应起来即可: 1myMap[&quot;1234&quot;] = PersonInfo&#123;&quot;1&quot;, &quot;Jack&quot;, &quot;Room 101,...&quot;&#125; 4. 元素删除delete(myMap, “1234”)上面的代码将从myMap中删除键为“1234”的键值对。如果“1234”这个键不存在,那么这个 将什么都不发生,也不会有什么副作用。但是如果传入的map变量的值是nil,该调用将导致程序抛出异常(panic)。 5. 元素查找在Go语言中,map的查找功能设计得比较精巧。而在其他语言中,我们要判断能否获取到一个值不是件容易的事情。判断能否从map中获取一个值的常规做法是:(1) 声明并初始化一个变量为空;(2) 试图从map中获取相应键的值到该变量中;(3) 判断该变量是否依旧为空,如果为空则表示map中没有包含该变量。这种用法比较啰唆,而且判断变量是否为空这条语句并不能真正表意(是否成功取到对应的 值),从而影响代码的可读性和可维护性。有些库甚至会设计为因为一个键不存在而抛出异常,让开发者用起来胆战心惊,不得不一层层嵌套try-catch语句,这更是不人性化的设计。在Go语言中,要从map中查找一个特定的键,可以通过下面的代码来实现: value, ok := myMap[“1234”] ifok{// 找到了 // 处理找到的value} 判断是否成功找到特定的键,不需要检查取到的值是否为nil,只需查看第二个返回值ok,这让表意清晰很多。配合:=操作符,让你的代码没有多余成分,看起来非常清晰易懂。​​​​​​​​​​​​​​​ ​​​ ​​​​​​​​​ ​​​​​​]]></content>
      <categories>
        <category>GoLang</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言学习(二)--第一个GO程序]]></title>
    <url>%2F2017%2F07%2F09%2Fgo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%E7%AC%AC%E4%B8%80%E4%B8%AAGO%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[[TOC] 1.第一个Go程序​ 几乎所有的程序开始都是以Hello World小例子作为开始。我们也不面熟（或者说尊重传统），下面我们从一个简单Go语言版本的Hello World来初窥Go这门新语言的模样。 ​ hello.go 1234567package mainimport "fmt" //导入我们需要使用的包 ，我们需要使用里面的Println函数func main() &#123; fmt.Println("Hello, world. 你好， 世界！")&#125; 代码解读：​ 每个Go源码文件的开头都是以一个package开头，表示该Go代码所属的包。包是Go中最基本的分发单位,也会工程管理中依赖关系的体现。要生成可执行文件，必须建立一个名字为main的包，并且在该包中包含一个叫main()的函数（该函数为Go可执行程序的起点，也只能含有一个）。 ​ main()函数定义为不能带参数、返回值。命令行的参数保存在os包中的os.Args中，命令行的参数解析可以通过flag包解析，在后面章节中我们回看到如何使用flag包。 ​ 在包的声明后会含有一系列的import语句，用于导入该程序所依赖的包。（有一点需要注意：⚠️ 在源码文件中不能包含没有使用的包，否则会编译错误） ​ 所有的Go函数都是以func关键字开头一个常规的函数包涵一下格式。 1234567func 函数名(参数列表)(返回值列表)&#123; &#125;//比如func Compute(arg1 int,arg2 float64)(retVal float64,err error)&#123; &#125; ​ 在Go的函数中支持多个函数返回值，比如上面的例子中返回了retVal和error。但是并不是所有的返回值都需要赋值，如果函数返回值没有被明确的赋值都会被设置为对应的类型的零值，比如retVal被设置为0.0，err被设置为nil。 Go中的注释Go的注释和C++保持一致，同时支持一下两种方式： 12345/* 快注释*/// 行注释 ​ ⚠️ 在Go源码文件中不能包含没有使用的包，否则会编译错误。 在Go源码文件中不能使用分号。 同时在含有括号的语句中，左括号({)不能另起一行。syntax error: unexpected semicolon or newline before { 代码的编译与执行12$ go run hello.go #直接执行Hello, world. 你好,世界! 使用如上命令，会将编译、链接和运行3个步骤合并为一步。运行完成后在当前目录下也看不到中间文件和最终的可执行文件。如果需要生成编译结果，不需要自动执行，可以使用build命令： 123$ go build hello.go #编译$ ./helloHello, world. 你好,世界! 工程管理​ 在实际的开发工作中,直接调用编译器进行编译和链接的场景是少而又少,因为在工程中不会简单到只有一个源代码文件,且源文件之间会有相互的依赖关系。如果这样一个文件一个文件逐步编译,那不亚于一场灾难。Go语言的设计者作为行业老将,自然不会忽略这一点。早期Go语言使用makefile作为临时方案,到了Go 1发布时引入了强大无比的Go命令行工具。 ​ Go命令行工具的革命性之处在于彻底消除了工程文件的概念,完全用目录结构和包名来推导工程结构和构建顺序。针对只有一个源文件的情况讨论工程管理看起来会比较多余,因为这可以直接用go run和go build搞定。下面我们将用一个更接近现实的虚拟项目来展示Go语言的基本工程管理方法。 假设有这样一个场景:我们需要开发一个基于命令行的计算器程序。下面为此程序的基本用法: 1234567891011$ cal helpUsage: calc cmmand [args]...The cmmand are:sqrt Square root of non-negative value.add Add of two value$ cal sqrt 4 # 开根号2$ cal add 1 2 # 加法3 我们假设这个工程被分割为两个部分: 可执行程序,名为calc,内部只包含一个calc.go文件; 算法库,名为simplemath,每个command对应于一个同名的go文件,比如add.go。 1则一个正常的工程目录组织应该如下所示: 在上面的结构里,带尖括号的名字表示其为目录。xxx_test.go表示的是一个对于xxx.go的单元测试,这也是Go工程里的命名规则。 为了让读者能够动手实践,这里我们会列出所有的源代码并以注释的方式解释关键内容,需要注意的是,本示例主要用于示范工程管理,并不保证代码达到产品级质量。 cal.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//calc.gopackage mainimport ( "fmt" "gostudy/ch02/calc/simplemath" "os" //用于获取命令行参数os.Args "strconv")func main() &#123; args := os.Args //获取控制台参数 argsLen := len(args) if args == nil || argsLen &lt; 3 &#123; Usage() return &#125; switch args[1] &#123; case "add": if argsLen &lt; 4 &#123; fmt.Println("Usage: calc add &lt;integer1&gt;&lt;integer2&gt;") return &#125; v1, err1 := strconv.Atoi(args[2]) v2, err2 := strconv.Atoi(args[3]) if err1 != nil || err2 != nil &#123; fmt.Println("Usage: calc add &lt;integer1&gt;&lt;integer2&gt;") return &#125; result := simplemath.Add(v1, v2) fmt.Println("Result:", result) case "sqrt": v, err := strconv.Atoi(args[2]) if err != nil &#123; fmt.Println("Usage: calc sqrt &lt;integer&gt;") return &#125; result := simplemath.Sqrt(v) fmt.Println("Result:", result) default: Usage() &#125;&#125;func Usage() &#123; fmt.Println("Usage: calc command [args]...") fmt.Println("The command are:") fmt.Println("sqrt Square root of non-negative value.") fmt.Println("add Add of two value")&#125; add.go 123456//add.gopackage simplemathfunc Add(a int, b int) int &#123; return a + b&#125; add_test.go 123456789101112package simplemathimport ( "testing")func TestAdd1(t *testing.T) &#123; r := Add(1, 2) if r != 3 &#123; t.Errorf("Add(1,2) failed.Got %d,expected 3.", r) &#125;&#125; sqrt.go 12345678910package simplemathimport ( "math")func Sqrt(a int) int &#123; v := math.Sqrt(float64(a)) return int(v)&#125; sort_test.go 123456789101112package simplemathimport ( "testing")func TestSqrt1(t *testing.T) &#123; v := Sqrt(16) if v != 4 &#123; t.Errorf("Sqrt(16) failed. Got %v, expected 4.", v) &#125;&#125; 为了能够构建这个工程,需要先把这个工程的根目录加入到环境变量GOPATH中。 执行测试go test simplemath 生成可执行文件go install calc.go 进入bin ./calc add 1 2 ​​​]]></content>
      <categories>
        <category>GoLang</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言学习(一)--GO语言的环境搭建]]></title>
    <url>%2F2017%2F07%2F08%2Fgo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E4%B8%80-GO%E8%AF%AD%E8%A8%80%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[1.安装git ​ 因为golang是通过git来管理远程包的，所以我们首先要安装git，下载地址：http://www.git-scm.com/download/。本教程主要针对golang环境搭建，git安装请自行baidu。 2.安装Golang ​ 1) 首先到https://golang.org/dl/选择适合你系统的安装包，（墙内：http://golangtc.com/download）。 ​ 2）我这里选择的是：go1.4.2.windows-amd64.msi，下载完成安装到指定目录即可。我这里是(E:\Go)。 ​ 3）安装完成后环境变量已经自动设置好了，可以呼出cmd命令行输入命令查看 1&gt; go env 可以看到，已经出现 go命令 了。如果你的不能出现，那可能是环境变量设置的问题。 ​ 进入我的电脑-&gt;高级设置-&gt;环境变量查看下，GOROOT变量是否存在，以及Path变量中是否也设置了GOROOT。没有的话，新增一个GOROOT变量，路径则输入你刚刚安装完成后Go的根目录，如我的是：E:\Go\。然后编辑Path变量，在最后面新增”;%GOROOT%bin“。 ​ 4）go命令依赖一个环境变量：GOPATH，这不是Go的安装目录，而是你的工作（工程）目录（你的代码都会在该目录下）。GOPATH可以有多个，windows以分号(;)进行区分，Linux系统是冒号(:)，当有多个GOPATH时，默认会将go get的内容放在第一个目录下。这里我们新建一个GOPATH变量，以我的为例：F:\mygo。 3.安装Sublime Text3 ​ 首先也是下载：http://www.sublimetext.com/3，安装也很傻瓜，直接下一步即可。 ​ 注意：sublime是收费软件，不注册也可以正常使用,只是保存次数达到一定的数量的时候会提示购买;忽略后可以正常使用。 ​ 这里需要安装一个sublime的pakcage control功能，用于接下来安装sublime插件。 ​ 1）在打开软件后，按下快捷键 Ctrl+`，（`这个符号为英文半角模式下，按下 Tab 键上方、数字键1左边的那个按键），此时会打开一个命令窗口，复制并输入以下内容，最后回车： 1import urllib.request,os,hashlib; h = &apos;eb2297e1a458f27d836c04bb0cbaf282&apos; + &apos;d0e7a3098092775ccb37ca9d6b2e4b7d&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 如果遇到报错则参考这里安装：https://packagecontrol.io/installation#st3。 2）重启sublime之后，你就可以发现在 Preferences 这个菜单下出现了菜单项 Package Control，如图： 4. 安装GoSublime插件 ​ 1）在sublime中，按住快捷键 shift + ctrl + p，在弹出框中输入install package，如图： ​ 2）回车，会出现如下图（可能需要稍微等待下，可以看sublime最下面的状态）： ​ 3）输入gosublime，回车（可能需要稍微等待下，可以看sublime最下面的状态），如图： ​ 4）gosublime安装完成后，Preferences -&gt; package settings -&gt; GoSublime -&gt; Settings - Uesrs需要配置下GOPATH，GOROOT，如图： ​ 5）在打开的窗口中输入以下内容，路径请自行替换，ctrl+s保存。 123456&#123; &quot;env&quot;: &#123; &quot;GOPATH&quot;: &quot;F:/mygo&quot;, &quot;GOROOT&quot;: &quot;E:/Go&quot; &#125;&#125; ​ 6）重启sublime，在GOPATH中的src新建一个hello.go文件，可以看到代码自动补全已经出来了，:) 至此，sublime text3 + golang 安装完成。 附上我的 sublime text3 的简单配置, Preferences -&gt; Settings User清空复制粘贴即可。 123456789101112131415&#123; &quot;font_size&quot;: 12, &quot;highlight_line&quot;: true, &quot;highlight_modified_tabs&quot;: true, &quot;ignored_packages&quot;: [ &quot;Vintage&quot; ], &quot;soda_classic_tabs&quot;: true, &quot;soda_folder_icons&quot;: true, &quot;tab_size&quot;: 4, &quot;translate_tabs_to_spaces&quot;: true, &quot;update_check&quot;: false, &quot;word_wrap&quot;: true&#125;]]></content>
      <categories>
        <category>GoLang</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java操作XML的五种方式]]></title>
    <url>%2F2017%2F07%2F05%2FJava%E6%93%8D%E4%BD%9CXML%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[[TOC] 1、了解XML​ XML，即可扩展标记语言（Extensible Markup Language），标准通用标记语言的子集，一种用于标记电子文件使其具有结构性的标记语言。它可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 它非常适合万维网传输，提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。它和JSON都是一种数据交换格式。 作用：解析XML文档，创建XML文档。 2、什么是可扩展标记语言？ · 可扩展标记语言是一种很像超文本标记语言的标记语言。 · 它的设计宗旨是传输数据，而不是显示数据。 · 它的标签没有被预定义。您需要自行定义标签。 · 它被设计为具有自我描述性。 · 它是W3C的推荐标准。 3、解析XML文档的五种方式： 五种方法解析XML文档：Dom、SAX、JDOM、dom4j 、degister准备xml文件123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;languages cat="it"&gt; &lt;lang id="1"&gt; &lt;name&gt;Java&lt;/name&gt; &lt;ide&gt;Eclipse&lt;/ide&gt; &lt;/lang&gt; &lt;lang id="2"&gt; &lt;name&gt;Swift&lt;/name&gt; &lt;ide&gt;Xcode&lt;/ide&gt; &lt;/lang&gt; &lt;lang id="3"&gt; &lt;name&gt;c#&lt;/name&gt; &lt;ide&gt;Visual Studio&lt;/ide&gt; &lt;/lang&gt;&lt;/languages&gt; 3.1、DOM第一种：DOM的全称是Document Object Model，也即文档对象模型。在应用程序中，基于DOM的XML分析器将一个XML文档转换成一个对象模型的集合（通常称DOM树），应用程序正是通过对这个对象模型的操作，来实现对XML文档数据的操作。通过DOM接口，应用程序可以在任何时候访问XML文档中的任何一部分数据，因此，这种利用DOM接口的机制也被称作随机访问机制。 3.1.1 dom读取xml文件​ 读取代码如下： 12345678910111213141516171819202122232425262728293031323334public void readXML() throws ParserConfigurationException, IOException, SAXException &#123; //1.获取DocumentBuilder工厂实例 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); //2.获取解析器 DocumentBuilder builder = dbf.newDocumentBuilder(); //3.解析文件 Document document = builder.parse(this.getClass().getClassLoader().getResourceAsStream("xml/languages.xml")); //获取根元素 Element root = document.getDocumentElement(); //获取属性 String cat = root.getAttribute("cat"); System.out.println("根元素为："+root.getNodeName()+" 属性cat:"+cat); //获取所有名字为lang的标签 NodeList langs = root.getElementsByTagName("lang"); int length = langs.getLength(); System.out.println("lang名称的节点长度为："+length); for (int i = 0; i &lt; length; i++) &#123; Node node = langs.item(i); //获取下面所有的子节点 NodeList childNodes = node.getChildNodes(); int len = childNodes.getLength(); System.out.println("第"+(i+1)+"个lang标签子节点长度:"+len);//长度为5（因为含有三个回车） for (int j = 0; j &lt; len; j++) &#123; Node item = childNodes.item(j); //只对节点类型为ELEMENT_NODE的操作 回车的类型为TEXT_NODE if(item.getNodeType()==Node.ELEMENT_NODE)&#123; System.out.println(item.getNodeName()+"="+item.getTextContent()); &#125; &#125; &#125; &#125; 3.1.2 dom方式创建xml创建xml代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public void createXml() throws ParserConfigurationException, TransformerException &#123; //1.获取DocumentBuilder工厂实例 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); //2.获取解析器 DocumentBuilder builder = dbf.newDocumentBuilder(); //3.获取Document Document document = builder.newDocument(); //创建节点 Element root = document.createElement("languages"); //创建属性 root.setAttribute("cat", "it"); //创建lang Element lang = document.createElement("lang"); lang.setAttribute("id", "1"); Element name = document.createElement("name"); name.setTextContent("java");//设置文本内容 Element ide = document.createElement("ide"); ide.setTextContent("Eclipse"); //添加节点 lang.appendChild(name); lang.appendChild(ide); root.appendChild(lang); document.appendChild(root); //输出 TransformerFactory factory = TransformerFactory.newInstance(); Transformer transformer = factory.newTransformer(); transformer.setOutputProperty("encoding", "UTF-8"); //写到字符串 StringWriter out = new StringWriter(); transformer.transform(new DOMSource(document),new StreamResult(out)); System.out.println(out.toString()); //写到文件 transformer.transform(new DOMSource(document), new StreamResult(new File("newxml.xml"))); &#125; 3.2 、SAX​ SAX介绍 SAX的全称是Simple APIs for XML，也即XML简单应用程序接口。 与DOM不同，SAX提供的访问模式是一种顺序模式，这是一种快速读写XML数据的方式。 当使用SAX分析器对XML文档进行分析时，会触发一系列事件，并激活相应的事件处理函数，应用程序通过这些事件处理函数实现对XML文档的访问，因而SAX接口也被称作事件驱动接口。 局限性： 1. SAX分析器在对XML文档进行分析时，触发了一系列的事件，由于事件触发本身是有时序性的，因此，SAX提供的是一种顺序访问机制，对于已经分析过的部分，不能再倒回去重新处理。 即，一旦经过了某个元素，我们没有办法返回去再去访问它。 2. SAX分析器只做了一些简单的工作，大部分工作还要由应用程序自己去做。 也就是说，SAX分析器在实现时，只是顺序地检查XML文档中的字节流，判断当前字节是XML语法中的哪一部分、是否符合XML语法，然后再触发相应的事件，而事件处理函数本身则要由应用程序自己来实现。 同DOM分析器相比，SAX分析器缺乏灵活性。 优势： 然而，由于SAX分析器实现简单，对内存要求比较低，（SAX不必将整个XML文档加载到内存当中，因此它占据内存要比DOM小）， 因此实现效率比较高。 对于大型的XML文档来说，通常会用SAX而不是DOM。 并且对于那些只需要访问XML文档中的数据而不对文档进行更改的应用程序来说，SAX分析器更为合适。 DefaultHandler类： 3.2.1 读取xml文件标签的枚举类如下 1234567891011121314151617181920212223242526272829303132package org.wuqinghua.java.xml.sax;/** * Created by wuqinghua on 17/7/5. */public enum TagName &#123; LANGUAGES("languages"),LANG("lang"), NAME("name"), IDE("ide"),NONE("none"); private String tagName; TagName(String tagName) &#123; this.tagName = tagName; &#125; public String getTagName() &#123; return tagName; &#125; public static TagName transformer(String tagName) &#123; switch (tagName) &#123; case "languages": return LANGUAGES; case "lang": return LANG; case "name": return NAME; case "ide": return IDE; default: return NONE; &#125; &#125;&#125; 将lang标签设计为一个对象 12345678910111213141516171819202122232425262728293031323334353637383940414243package org.wuqinghua.java.xml.sax;/** * Created by wuqinghua on 17/7/5. */public class Lang &#123; private String id; private String name; private String ide; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getIde() &#123; return ide; &#125; public void setIde(String ide) &#123; this.ide = ide; &#125; @Override public String toString() &#123; return "Lang&#123;" + "id='" + id + '\'' + ", name='" + name + '\'' + ", ide='" + ide + '\'' + '&#125;'; &#125;&#125; xml顺序执行的handler 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package org.wuqinghua.java.xml.sax;import org.xml.sax.Attributes;import org.xml.sax.SAXException;import org.xml.sax.helpers.DefaultHandler;import java.util.ArrayList;import java.util.List;/** * Created by wuqinghua on 17/7/5. */public class SaxHandler extends DefaultHandler &#123; private List&lt;Lang&gt; langs = null; private Lang lang = null; private boolean isName = false; private boolean isIde = false; //文档开始触发 @Override public void startDocument() throws SAXException &#123; super.startDocument(); &#125; //文档结束触发 @Override public void endDocument() throws SAXException &#123; super.endDocument(); &#125; //标签开始触发 @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; TagName tagName = TagName.transformer(qName); switch (tagName) &#123; case NONE: break; case LANGUAGES: if (langs == null) langs = new ArrayList&lt;&gt;(); break; case LANG: //解析lang标签 lang = new Lang(); String id = attributes.getValue("id"); lang.setId(id); break; case NAME: //解析name标签 isName = true; break; case IDE: //解析ide标签 isIde = true; break; &#125; &#125; //标签结束触发 @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; if (TagName.transformer(qName).equals(TagName.LANG)) &#123; langs.add(lang); &#125; &#125; //标签中数据触发 @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; if (isName) &#123; lang.setName(new String(ch, start, length)); isName = false; &#125; else if (isIde) &#123; lang.setIde(new String(ch, start, length)); isIde = false; &#125; &#125; public List&lt;Lang&gt; getLangs() &#123; return langs; &#125;&#125; 读取xml 12345678910111213public void readXML() throws ParserConfigurationException, SAXException, IOException &#123; //1.获取SAX解析器的工厂 SAXParserFactory factory = SAXParserFactory.newInstance(); //2.获取SAX解析器 SAXParser saxParser = factory.newSAXParser(); //3.创建顺序读取xml的处理器 SaxHandler handler = new SaxHandler(); //4.解析xml saxParser.parse(this.getClass().getClassLoader().getResourceAsStream("xml/languages" + ".xml"),handler); System.out.println(handler.getLangs());&#125; 3.2.1 创建xml文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public void createXML() throws TransformerConfigurationException, SAXException &#123; //1.获取SAXTransformerFactory实例 SAXTransformerFactory factory = (SAXTransformerFactory) SAXTransformerFactory.newInstance(); //2.创建TransformerHandler实例 TransformerHandler transformerHandler = factory.newTransformerHandler(); //3.创建Transformer对象 Transformer transformer = transformerHandler.getTransformer(); //4、设置输出的xml属性，encoding为编码，indent是确保输出的xml文件能够自动换行 transformer.setOutputProperty(OutputKeys.ENCODING,"UTF-8"); transformer.setOutputProperty(OutputKeys.INDENT,"yes"); //5、创建Result对象，将Result对象加载到TransHandler中 //注意：1、这一步必须在Transformer.setOutputProperty()之后，不然设置的xml属性将不生效 // 2、这一步也必须在TransformerHandler.startDocument()之前，不然会报错。 // 分析源码后发现，startDocument()会先判断result是否为空，为空则报错 Result result = new StreamResult("newxml.xml"); transformerHandler.setResult(result); //6、创建属性Attribute对象 AttributesImpl attr = new AttributesImpl(); //7.开始写文件 transformerHandler.startDocument(); //8.写入根节点 attr.clear(); //设置属性 attr.addAttribute("","","cat","","it"); transformerHandler.startElement("","",TagName.LANGUAGES.getTagName(),attr); //设置lang节点 attr.clear(); attr.addAttribute("","","id","","1"); transformerHandler.startElement("","",TagName.LANG.getTagName(),attr); //设置name节点 attr.clear();; transformerHandler.startElement("","",TagName.NAME.getTagName(),attr); transformerHandler.characters("java".toCharArray(),0,"java".toCharArray().length); transformerHandler.endElement("","",TagName.NAME.getTagName()); //设置ide attr.clear(); transformerHandler.startElement("","",TagName.IDE.getTagName(),attr); transformerHandler.characters("Eclipse".toCharArray(),0,"Eclipse".toCharArray().length); transformerHandler.endElement("","",TagName.IDE.getTagName()); transformerHandler.endElement("","",TagName.LANG.getTagName()); transformerHandler.endElement("","",TagName.LANGUAGES.getTagName()); //9.结束 transformerHandler.endDocument();&#125; 3.3 JDomJDOM是一个开源项目，它基于树型结构，利用Java的技术对XML文档实现解析、生成、序列化以及多种操作，用Java的数据类型来定义操作数据树的各个节点。 JDOM下载 jdom-2.0.4.jar下载： http://www.jdom.org/downloads/ 3.3.1 读取xml文件12345678910111213141516171819202122232425public void readXML() throws JDOMException, IOException &#123; //1.获取JDom的解析器 SAXBuilder saxBuilder = new SAXBuilder(); //2.加载xml Document document = saxBuilder.build(this.getClass().getClassLoader().getResourceAsStream("xml/languages" + ".xml")); //3.获取根元素 Element rootElement = document.getRootElement(); System.out.println("根元素名称:"+rootElement.getName()+" 属性cat:"+rootElement.getAttributeValue ("cat")); //4.获取根元素下的所有的子节点 List&lt;Element&gt; children = rootElement.getChildren(); for (int i = 0; i &lt;children.size() ; i++) &#123; Element element = children.get(i); System.out.println(element.getName()+" id:"+element.getAttribute("id").getValue()); List&lt;Element&gt; child = element.getChildren(); for (int j = 0; j &lt; child.size(); j++) &#123; System.out.println(child.get(j).getName()+"="+child.get(j).getText()); &#125; &#125;&#125; 3.3.2 创建xml文件123456789101112131415161718192021222324252627282930313233343536373839public void createXml() throws TransformerException, IOException &#123; //1.创建文档 Document document = new Document(); //2.添加跟节点 Element root = new Element("languages"); root.setAttribute("cat","it"); document.setRootElement(root); //3.添加子节点 Element lang = new Element("lang"); lang.setAttribute("id","1"); Element name = new Element("name"); name.setText("Java"); Element ide = new Element("ide"); ide.setText("Eclipse"); lang.addContent(name); lang.addContent(ide); root.addContent(lang); //输出// TransformerFactory factory = TransformerFactory.newInstance();// Transformer transformer = factory.newTransformer();// transformer.setOutputProperty(OutputKeys.ENCODING,"UTF-8");// transformer.setOutputProperty(OutputKeys.INDENT,"yes");// transformer.transform(new JDOMSource(document),new StreamResult(new FileWriter("newxml" +// ".xml"))); //输出 Format format = Format.getPrettyFormat(); format.setEncoding("UTF-8"); XMLOutputter out = new XMLOutputter(); out.setFormat(format); out.output(document,new FileWriter("newxml.xml")); &#125; 3.4 DOM4J​ dom4j的项目地址：http://sourceforge.net/projects/dom4j/?source=directory dom4j是一个简单的开源库，用于处理XML、 XPath和XSLT，它基于Java平台，使用Java的集合框架，全面集成了DOM，SAX和JAXP。 3.4.1 读取xml1234567891011121314151617181920212223242526public void readXml() throws DocumentException &#123; //1.说去SAXReader对象 SAXReader reader = new SAXReader(); //2.获取Document对象 Document document = reader.read(this.getClass().getClassLoader().getResourceAsStream("xml/languages.xml")); //3.获取根元素 Element rootElement = document.getRootElement(); System.out.println("根元素名称:"+rootElement.getName()); String cat = rootElement.attributeValue("cat"); System.out.println("属性为cat的值为:"+cat); System.out.println("-------------------------"); //4.获取其下的子元素 List&lt;Element&gt; elements = rootElement.elements(); for (int i = 0; i &lt; elements.size(); i++) &#123; Element element = elements.get(i); System.out.println("第"+i+"个元素的名称:"+element.getName()); System.out.println("属性id为:"+element.attributeValue("id")); List&lt;Element&gt; children = element.elements(); for (int j = 0; j &lt; children.size(); j++) &#123; Element ele = children.get(j); System.out.println(ele.getName()+"="+ele.getText()); &#125; System.out.println("-------------------------"); &#125;&#125; 3.4.2 创建xml12345678910111213141516171819202122232425262728293031public void createXml() throws IOException &#123; //1.获取文档 Document document = DocumentHelper.createDocument(); //2.创建跟节点 Element languages = DocumentHelper.createElement("languages"); languages.addAttribute("cat","it"); document.setRootElement(languages); //3.添加子节点 Element lang = languages.addElement("lang"); lang.addAttribute("id","1"); Element name = lang.addElement("name"); name.setText("Java"); Element ide = lang.addElement("ide"); ide.setText("Eclipse"); //输出 //输出到控制台 XMLWriter writer = new XMLWriter(); writer.write(document); //输出到文件 OutputFormat format = new OutputFormat(" ",true); XMLWriter out = new XMLWriter(new FileOutputStream("newxml.xml"),format); out.write(document);&#125; 3.5 digesterdigester原来为struts中解析xml的方式，由于其比较好，被apache单独拿出变为一个小型框架。 其使用的原理为sax。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十七)--JSP中的九个内置对象]]></title>
    <url>%2F2017%2F07%2F04%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81%E4%B8%83-JSP%E4%B8%AD%E7%9A%84%E4%B9%9D%E4%B8%AA%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[[TOC] 一、JSP运行原理 每个JSP 页面在第一次被访问时，WEB容器都会把请求交给JSP引擎（即一个Java程序）去处理。JSP引擎先将JSP翻译成一个_jspServlet(实质上也是一个servlet) ，然后按照servlet的调用方式进行调用。 由于JSP第一次访问时会翻译成servlet，所以第一次访问通常会比较慢，但第二次访问，JSP引擎如果发现JSP没有变化，就不再翻译，而是直接调用，所以程序的执行效率不会受到影响。 JSP引擎在调用JSP对应的_jspServlet时，会传递或创建9个与web开发相关的对象供_jspServlet使用。JSP技术的设计者为便于开发人员在编写JSP页面时获得这些web对象的引用，特意定义了9个相应的变量，开发人员在JSP页面中通过这些变量就可以快速获得这9大对象的引用。** 二、认识九个内置对象 NO. 内置对象 类型 1 pageContext javax.servlet.jsp.PageContext 2 request javax.servlet.http.HttpServletRequest 3 response javax.servlet.http.HttpServletResponse 4 session javax.servlet.http.HttpSession 5 application javax.servlet.ServletContext 6 config javax.servlet.ServletConfig 7 out javax.servlet.jsp.JspWriter 8 page java.lang.Object 9 exception java.lang.Throwable request，response，session，application，config这些对象在前面都已经作了详细的介绍，这里重点介绍一下剩下的pageContext对象，out对象，page对象。 三、内置对象使用说明3.1、page对象 page对象表示当前一个JSP页面，可以理解为一个对象本身，即：把一个JSP当作一个对象来看待。page对象在开发中几乎不用，了解一下即可 3.2、out对象 out对象用于向客户端发送文本数据。 out对象是通过调用pageContext对象的getOut方法返回的，其作用和用法与ServletResponse.getWriter方法返回的PrintWriter对象非常相似。 JSP页面中的out对象的类型为JspWriter，JspWriter相当于一种带缓存功能的PrintWriter，设置JSP页面的page指令的buffer属性可以调整它的缓存大小，甚至关闭它的缓存。 只有向out对象中写入了内容，且满足如下任何一个条件时，out对象才去调用ServletResponse.getWriter方法，并通过该方法返回的PrintWriter对象将out对象的缓冲区中的内容真正写入到Servlet引擎提供的缓冲区中： 设置page指令的buffer属性关闭了out对象的缓存功能 out对象的缓冲区已满 整个JSP页面结束 out对象的工作原理图 3.3、pageContext对象 pageContext对象是JSP技术中最重要的一个对象，它代表JSP页面的运行环境，这个对象不仅封装了对其它8大隐式对象的引用，它自身还是一个域对象(容器)，可以用来保存数据。并且，这个对象还封装了web开发中经常涉及到的一些常用操作，例如引入和跳转其它资源、检索其它域对象中的属性等。 3.4、通过pageContext获得其他对象 getException方法返回exception隐式对象 getPage方法返回page隐式对象 getRequest方法返回request隐式对象 getResponse方法返回response隐式对象 getServletConfig方法返回config隐式对象 getServletContext方法返回application隐式对象 getSession方法返回session隐式对象 getOut方法返回out隐式对象 3.5、pageContext封装其它8大内置对象的意义 如果在编程过程中，把pageContext对象传递给一个普通java对象，那么这个java对象将可以获取8大隐式对象，此时这个java对象就可以和浏览器交互了，此时这个java对象就成为了一个动态web资源了，这就是pageContext封装其它8大内置对象的意义，把pageContext传递给谁，谁就能成为一个动态web资源，那么什么情况下需要把pageContext传递给另外一个java类呢，什么情况下需要使用这种技术呢，在比较正规的开发中，jsp页面是不允许出现java代码的，如果jsp页面出现了java代码，那么就应该想办法把java代码移除掉，我们可以开发一个自定义标签来移除jsp页面上的java代码，首先围绕自定义标签写一个java类，jsp引擎在执行自定义标签的时候就会调用围绕自定义标签写的那个java类，在调用java类的时候就会把pageContext对象传递给这个java类，由于pageContext对象封装了对其它8大隐式对象的引用，因此在这个java类中就可以使用jsp页面中的8大隐式对象(request，response，config，application，exception，Session，page，out)了，pageContext对象在jsp自定义标签开发中特别重要。 3.6、pageContext作为域对象 pageContext对象可以作为容器来使用，因此可以将一些数据存储在pageContext对象中。 pageContext对象的常用方法 1234public void setAttribute(java.lang.String name,java.lang.Object value)public java.lang.Object getAttribute(java.lang.String name)public void removeAttribute(java.lang.String name)public java.lang.Object findAttribute(java.lang.String name) 重点介绍一下findAttribute方法，这个方法是用来查找各个域中的属性的，查看这个方法的API可以看到关于这个方法的描述： Searches for the named attribute in page, request, session (if valid), and application scope(s) in order and returns the value associated or null. 当要查找某个属性时，findAttribute方法按照查找顺序”page→request→session→application”在这四个对象中去查找，只要找到了就返回属性值，如果四个对象都没有找到要查找的属性，则返回一个null。 范例：使用pageContext的findAttribute方法查找属性值 12345678910111213141516171819202122232425262728293031323334 &lt;%@page contentType="text/html;charset=UTF-8"%&gt; &lt;%@page import="java.util.*"%&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;head&gt; &lt;title&gt;pageContext的findAttribute方法查找属性值&lt;/title&gt; &lt;/head&gt; &lt;% pageContext.setAttribute("name1", "孤傲苍狼"); request.setAttribute("name2", "白虎神皇"); session.setAttribute("name3", "玄天邪帝"); application.setAttribute("name4", "灭世魔尊");%&gt;&lt;% //使用pageContext的findAttribute方法查找属性，由于取得的值为Object类型，因此必须使用String强制向下转型，转换成String类型 //查找name1属性，按照顺序"page→request→session→application"在这四个对象中去查找 String refName1 = (String)pageContext.findAttribute("name1"); String refName2 = (String)pageContext.findAttribute("name2"); String refName3 = (String)pageContext.findAttribute("name3"); String refName4 = (String)pageContext.findAttribute("name4"); String refName5 = (String)pageContext.findAttribute("name5");//查找一个不存在的属性%&gt;&lt;h1&gt;pageContext.findAttribute方法查找到的属性值：&lt;/h1&gt;&lt;h3&gt;pageContext对象的name1属性：&lt;%=refName1%&gt;&lt;/h3&gt;&lt;h3&gt;request对象的name2属性：&lt;%=refName2%&gt;&lt;/h3&gt;&lt;h3&gt;session对象的name3属性：&lt;%=refName3%&gt;&lt;/h3&gt;&lt;h3&gt;application对象的name4属性：&lt;%=refName4%&gt;&lt;/h3&gt;&lt;h3&gt;查找不存在的name5属性：&lt;%=refName5%&gt;&lt;/h3&gt;&lt;hr/&gt;&lt;h1&gt;使用EL表达式进行输出：&lt;/h1&gt;&lt;h3&gt;pageContext对象的name1属性：$&#123;name1&#125;&lt;/h3&gt;&lt;h3&gt;request对象的name2属性：$&#123;name2&#125;&lt;/h3&gt;&lt;h3&gt;session对象的name3属性：$&#123;name3&#125;&lt;/h3&gt;&lt;h3&gt;application对象的name4属性：$&#123;name4&#125;&lt;/h3&gt;&lt;h3&gt;不存在的name5属性：$&#123;name5&#125;&lt;/h3&gt; 运行结果： EL表达式语句在执行时，会调用pageContext.findAttribute方法，用标识符为关键字，分别从page、request、 session、application四个域中查找相应的对象，找到则返回相应对象，找不到则返回”” （注意，不是null，而是空字符串）。 pageContext对象中封装了访问其它域的方法 123public java.lang.Object getAttribute(java.lang.String name,int scope)public void setAttribute(java.lang.String name, java.lang.Object value,int scope)public void removeAttribute(java.lang.String name,int scope) 代表各个域的常量 1234PageContext.APPLICATION_SCOPEPageContext.SESSION_SCOPEPageContext.REQUEST_SCOPEPageContext.PAGE_SCOPE 范例：pageContext访问其它域 123456789101112131415161718192021 &lt;%@page contentType="text/html;charset=UTF-8"%&gt; &lt;%@page import="java.util.*"%&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;head&gt; &lt;title&gt;pageContext访问其它域&lt;/title&gt; &lt;/head&gt; &lt;% //此时相当于往session对象中存放了一个name属性，等价于 session.setAttribute("name","孤傲苍狼"); pageContext.setAttribute("name","孤傲苍狼",PageContext.SESSION_SCOPE);%&gt;&lt;% //取得session对象的属性，使用pageContext对象获取 String refName1 = (String)pageContext.getAttribute("name",PageContext.SESSION_SCOPE); //由于取得的值为Object类型，因此必须使用String强制向下转型，转换成String类型 String refName2 = (String)session.getAttribute("name"); %&gt;&lt;h1&gt;取出存放在session对象中的属性值：&lt;/h1&gt;&lt;p&gt;第一种做法：使用pageContext.getAttribute("attributeName",PageContext.SESSION_SCOPE);去取出session对象中值&lt;/p&gt;&lt;h3&gt;姓名：&lt;%=refName1%&gt;&lt;/h3&gt;&lt;p&gt;第二种做法：使用session.getAttribute("attributeName");去取出session对象中值&lt;/p&gt;&lt;h3&gt;姓名：&lt;%=refName2%&gt;&lt;/h3&gt; 3.7、PageContext引入和跳转到其他资源 PageContext类中定义了一个forward方法(用来跳转页面)和两个include方法(用来引入页面)来分别简化和替代RequestDispatcher.forward方法和include方法。 方法接收的资源如果以“/”开头， “/”代表当前web应用。 范例：使用pageContext的forward方法跳转到其他页面 12345678910111213 &lt;%@page contentType="text/html;charset=UTF-8"%&gt; &lt;%@page import="java.util.*"%&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;head&gt; &lt;title&gt;使用pageContext的forward方法跳转页面&lt;/title&gt; &lt;/head&gt; &lt;% //使用pageContext的forward方法跳转到pageContextDemo05.jsp页面，/代表了当前的web应用 pageContext.forward("/pageContextDemo05.jsp"); //使用pageContext.forward(relativeUrlPath)替代RequestDispatcher.forward(relativeUrlPath) //使用RequestDispatcher的forward方法实现的跳转方式 //pageContext.getRequest().getRequestDispatcher("/pageContextDemo05.jsp").forward(request, response);%&gt; 运行结果如下： 11 pageContext.forward(&quot;/pageContextDemo05.jsp&quot;); 这种写法是用来简化和替代pageContext.getRequest().getRequestDispatcher(“/pageContextDemo05.jsp”).forward(request, response);这种写法的。在实际开发中，使用pageContext.forward(relativeUrlPath)方法跳转页面用得不多，主要是因为要在Jsp页面中嵌套java代码，所以这种做法简单了解一下即可，在开发中，要想从一个Jsp页面采用服务器端跳转的方式跳转到另一个Jsp页面，那么一般会使用标签，标签用于把请求转发给另外一个资源。 范例：使用pageContext的include方法引入资源 123456789101112131415161718 &lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;head&gt; &lt;title&gt;使用pageContext的include方法引入资源&lt;/title&gt; &lt;/head&gt; &lt;% pageContext.include("/jspfragments/head.jsp"); %&gt; 使用pageContext的include方法引入资源&lt;% pageContext.include("/jspfragments/foot.jsp");%&gt;&lt;hr/&gt;&lt;%--&lt;jsp:include page="/jspfragments/head.jsp"/&gt;使用jsp:include标签引入资源&lt;jsp:include page="/jspfragments/foot.jsp"/&gt;--%&gt; 运行结果： 在实际开发中，使用pageContext的include方法引入页面这种做法也很少用，一般都使用jsp:include标签引入资源，因此这种做法了解一下即可。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十五)--JSP基础语法]]></title>
    <url>%2F2017%2F07%2F04%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81%E4%BA%94-JSP%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[TOC] 任何语言都有自己的语法，JAVA中有，JSP虽然是在JAVA上的一种应用，但是依然有其自己扩充的语法，而且在JSP中，所有的JAVA语句都可以使用。 一、JSP模版元素 JSP页面中的HTML内容称之为JSP模版元素。 JSP模版元素定义了网页的基本骨架，即定义了页面的结构和外观。 二、JSP表达式 JSP脚本表达式（expression）用于将程序数据输出到客户端​ 语法：&lt;%= 变量或表达式 %&gt;​ 举例：输出当前系统时间: 1&lt;%= new java.util.Date() %&gt; JSP引擎在翻译脚本表达式时，会将程序数据转成字符串，然后在相应位置用out.print(…) 将数据输给客户端。 JSP脚本表达式中的变量或表达式后面不能有分号（;）。 三、JSP脚本片断 JSP脚本片断(scriptlet)用于在JSP页面中编写多行Java代码。语法： &lt;% 多行java代码 %&gt; 在&lt;% %&gt;中可以定义变量、编写语句，不能定义方法。 范例：在Scriptlet中定义变量、编写语句 123456789&lt;% int sum=0;//声明变量 /*编写语句*/ for (int i=1;i&lt;=100;i++)&#123; sum+=i; &#125; out.println("&lt;h1&gt;Sum="+sum+"&lt;/h1&gt;");%&gt; 注意事项： JSP脚本片断中只能出现java代码，不能出现其它模板元素， JSP引擎在翻译JSP页面中，会将JSP脚本片断中的Java代码将被原封不动地放到Servlet的_jspService方法中。 JSP脚本片断中的Java代码必须严格遵循Java语法，例如，每执行语句后面必须用分号（;）结束。 在一个JSP页面中可以有多个脚本片断，在两个或多个脚本片断之间可以嵌入文本、HTML标记和其他JSP元素。 ​ 举例： 123456789&lt;% int x = 10; out.println(x);%&gt;&lt;p&gt;这是JSP页面文本&lt;/p&gt;&lt;% int y = 20; out.println(y);%&gt; 多个脚本片断中的代码可以相互访问，犹如将所有的代码放在一对&lt;%%&gt;之中的情况。如：out.println(x); 单个脚本片断中的Java语句可以是不完整的，但是，多个脚本片断组合后的结果必须是完整的Java语句，例如： 12345678&lt;% for (int i=1; i&lt;5; i++) &#123;%&gt; &lt;H1&gt;http://localhost:8080/JavaWeb_Jsp_Study_20140603/&lt;/H1&gt;&lt;% &#125;%&gt; 四、JSP声明 JSP页面中编写的所有代码，默认会翻译到servlet的service方法中， 而Jsp声明中的java代码被翻译到_jspService方法的外面。语法： &lt;%！ java代码 %&gt; 所以，JSP声明可用于定义JSP页面转换成的Servlet程序的静态代码块、成员变量和方法 。 多个静态代码块、变量和函数可以定义在一个JSP声明中，也可以分别单独定义在多个JSP声明中。 JSP隐式对象的作用范围仅限于Servlet的_jspService方法，所以在JSP声明中不能使用这些隐式对象。 JSP声明案例： 1234567891011121314151617&lt;%!static &#123; System.out.println("loading Servlet!"); &#125;private int globalVar = 0;public void jspInit()&#123; System.out.println("initializing jsp!");&#125;%&gt;&lt;%!public void jspDestroy()&#123; System.out.println("destroying jsp!");&#125;%&gt; 五、JSP注释在JSP中，注释有两大类： 显式注释：直接使用HTML风格的注释：&lt;!- - **注释内容**- -&gt; 隐式注释：直接使用JAVA的注释：//、/***……*/** **JSP自己的注释：&lt;%- - 注释内容- -%&gt;** 这三种注释的区别 1234567891011&lt;!--这个注释可以看见--&gt;&lt;% //JAVA中的单行注释 /* JAVA中的多行注释 */%&gt;&lt;%--JSP自己的注释--%&gt; HTML的注释在浏览器中查看源文件的时候是可以看得到的，而JAVA注释和JSP注释在浏览器中查看源文件时是看不到注释的内容的，这就是这三种注释的区别。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十四)--JSP原理]]></title>
    <url>%2F2017%2F07%2F04%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81%E5%9B%9B-JSP%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[[TOC] 一、什么是JSP？ JSP全称是Java Server Pages，它和servle技术一样，都是SUN公司定义的一种用于开发动态web资源的技术。 JSP这门技术的最大的特点在于，写jsp就像在写html，但它相比html而言，html只能为用户提供静态数据，而Jsp技术允许在页面中嵌套java代码，为用户提供动态数据。 二、JSP原理2.1、Web服务器是如何调用并执行一个jsp页面的？ 浏览器向服务器发请求，不管访问的是什么资源，其实都是在访问Servlet，所以当访问一个jsp页面时，其实也是在访问一个Servlet，服务器在执行jsp的时候，首先把jsp翻译成一个Servlet，所以我们访问jsp时，其实不是在访问jsp，而是在访问jsp翻译过后的那个Servlet，例如下面的代码： 3.jsp 123456789101112131415161718192021222324&lt;%-- Created by IntelliJ IDEA. User: wuqinghua Date: 17/7/4 Time: 上午11:20 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";%&gt;&lt;html&gt;&lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% out.print("Hello Jsp"); %&gt;&lt;/body&gt;&lt;/html&gt; 当我们通过浏览器访问3.jsp时，服务器首先将index.jsp翻译成一个_3_jsp.class，在Tomcat服务器的work\Catalina\localhost\项目名\org\apache\jsp目录下可以看到_3_jsp.class的源代码文件index_jsp.java，index_jsp.java的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150/* * Generated by the Jasper component of Apache Tomcat * Version: Apache Tomcat/8.0.41 * Generated at: 2017-07-04 03:25:11 UTC * Note: The last modified time of this file was set to * the last modified time of the source file after * generation to assist with modification tracking. */package org.apache.jsp;import javax.servlet.*;import javax.servlet.http.*;import javax.servlet.jsp.*;public final class _3_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent, org.apache.jasper.runtime.JspSourceImports &#123; private static final javax.servlet.jsp.JspFactory _jspxFactory = javax.servlet.jsp.JspFactory.getDefaultFactory(); private static java.util.Map&lt;java.lang.String,java.lang.Long&gt; _jspx_dependants; private static final java.util.Set&lt;java.lang.String&gt; _jspx_imports_packages; private static final java.util.Set&lt;java.lang.String&gt; _jspx_imports_classes; static &#123; _jspx_imports_packages = new java.util.HashSet&lt;&gt;(); _jspx_imports_packages.add("javax.servlet"); _jspx_imports_packages.add("javax.servlet.http"); _jspx_imports_packages.add("javax.servlet.jsp"); _jspx_imports_classes = null; &#125; private volatile javax.el.ExpressionFactory _el_expressionfactory; private volatile org.apache.tomcat.InstanceManager _jsp_instancemanager; public java.util.Map&lt;java.lang.String,java.lang.Long&gt; getDependants() &#123; return _jspx_dependants; &#125; public java.util.Set&lt;java.lang.String&gt; getPackageImports() &#123; return _jspx_imports_packages; &#125; public java.util.Set&lt;java.lang.String&gt; getClassImports() &#123; return _jspx_imports_classes; &#125; public javax.el.ExpressionFactory _jsp_getExpressionFactory() &#123; if (_el_expressionfactory == null) &#123; synchronized (this) &#123; if (_el_expressionfactory == null) &#123; _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory(); &#125; &#125; &#125; return _el_expressionfactory; &#125; public org.apache.tomcat.InstanceManager _jsp_getInstanceManager() &#123; if (_jsp_instancemanager == null) &#123; synchronized (this) &#123; if (_jsp_instancemanager == null) &#123; _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig()); &#125; &#125; &#125; return _jsp_instancemanager; &#125; public void _jspInit() &#123; &#125; public void _jspDestroy() &#123; &#125; public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException &#123;final java.lang.String _jspx_method = request.getMethod();if (!"GET".equals(_jspx_method) &amp;&amp; !"POST".equals(_jspx_method) &amp;&amp; !"HEAD".equals(_jspx_method) &amp;&amp; !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) &#123;response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSPs only permit GET POST or HEAD");return;&#125; final javax.servlet.jsp.PageContext pageContext; javax.servlet.http.HttpSession session = null; final javax.servlet.ServletContext application; final javax.servlet.ServletConfig config; javax.servlet.jsp.JspWriter out = null; final java.lang.Object page = this; javax.servlet.jsp.JspWriter _jspx_out = null; javax.servlet.jsp.PageContext _jspx_page_context = null; try &#123; response.setContentType("text/html;charset=UTF-8"); pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; out.write('\n'); out.write('\n'); String path = request.getContextPath(); String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/"; out.write("\n"); out.write("&lt;html&gt;\n"); out.write("&lt;head&gt;\n"); out.write(" &lt;base href=\""); out.print(basePath); out.write("\"&gt;\n"); out.write(" &lt;title&gt;Title&lt;/title&gt;\n"); out.write("&lt;/head&gt;\n"); out.write("&lt;body&gt;\n"); out.write(" "); out.print("Hello Jsp"); out.write("\n"); out.write("&lt;/body&gt;\n"); out.write("&lt;/html&gt;\n"); &#125; catch (java.lang.Throwable t) &#123; if (!(t instanceof javax.servlet.jsp.SkipPageException))&#123; out = _jspx_out; if (out != null &amp;&amp; out.getBufferSize() != 0) try &#123; if (response.isCommitted()) &#123; out.flush(); &#125; else &#123; out.clearBuffer(); &#125; &#125; catch (java.io.IOException e) &#123;&#125; if (_jspx_page_context != null) _jspx_page_context.handlePageException(t); else throw new ServletException(t); &#125; &#125; finally &#123; _jspxFactory.releasePageContext(_jspx_page_context); &#125; &#125;&#125; 2.3、Jsp页面中的java代码服务器是如何执行的？ 在jsp中编写的java代码会被翻译到_jspService方法中去，当执行_jspService方法处理请求时，就会执行在jsp编写的java代码了，所以Jsp页面中的java代码服务器是通过调用_jspService方法处理请求时执行的。 2.4、Web服务器在调用jsp时，会给jsp提供一些什么java对象？ 查看_jspService方法可以看到，Web服务器在调用jsp时，会给Jsp提供如下的8个java对象 12345678PageContext pageContext;HttpSession session;ServletContext application;ServletConfig config;JspWriter out;Object page = this;HttpServletRequest request, HttpServletResponse response 其中page对象，request和response已经完成了实例化，而其它5个没有实例化的对象通过下面的方式实例化 12345pageContext = _jspxFactory.getPageContext(this, request, response,null, true, 8192, true);application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); 8个java对象可以直接使用 12345678910111213&lt;% session.setAttribute("name", "session对象");//使用session对象，设置session对象属性 out.print(session.getAttribute("name") + "&lt;br /&gt;");//获取session对象的属性 pageContext.setAttribute("name", "pageContext对象");//使用pageContext对象 out.print(pageContext.getAttribute("name") + "&lt;br /&gt;");//获取pageContext对象 application.setAttribute("name", "application对象");//使用application对象,设置application对象的属性 out.print(application.getAttribute("name") + "&lt;br/&gt;");//获取application对象的属性 out.print("Hello Jsp" + "&lt;br/&gt;");//使用out对象 out.print("服务器调用index.jsp页面时翻译成的类的名字是：" + page.getClass() + "&lt;br/&gt;");//使用page对象 out.print("处理请求的Servlet的名字是：" + config.getServletName().toString() + "&lt;br/&gt;");//使用config对象 out.print(response.getContentType() + "&lt;br/&gt;");//使用response对象 out.print(request.getContextPath() + "&lt;br/&gt;");//使用request对象%&gt; 运行结果如下： 2.5、Jsp最佳实践 Jsp最佳实践就是jsp技术在开发中该怎么去用。 不管是JSP还是Servlet，虽然都可以用于开发动态web资源。但由于这2门技术各自的特点，在长期的软件实践中，人们逐渐把servlet作为web应用中的控制器组件来使用，而把JSP技术作为数据显示模板来使用。其原因为，程序的数据通常要美化后再输出：让jsp既用java代码产生动态数据，又做美化会导致页面难以维护。让servlet既产生数据，又在里面嵌套html代码美化数据，同样也会导致程序可读性差，难以维护。因此最好的办法就是根据这两门技术的特点，让它们各自负责各的，servlet只负责响应请求产生数据，并把数据通过转发技术带给jsp，数据的显示jsp来做。 2.6、Tomcat服务器的执行流程 第一次执行： 客户端通过电脑连接服务器，因为是请求是动态的，所以所有的请求交给WEB容器来处理 在容器中找到需要执行的*.jsp文件 之后.jsp文件通过转换变为.java文件 .java文件经过编译后，形成.class文件 最终服务器要执行形成的*.class文件 第二次执行： 因为已经存在了*.class文件，所以不在需要转换和编译的过程 修改后执行： ​ 1.源文件已经被修改过了，所以需要重新转换，重新编译。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十三)--使用session防止表单重复提交]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81%E4%B8%89-%E4%BD%BF%E7%94%A8session%E9%98%B2%E6%AD%A2%E8%A1%A8%E5%8D%95%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[[TOC] 在平时开发中，如果网速比较慢的情况下，用户提交表单后，发现服务器半天都没有响应，那么用户可能会以为是自己没有提交表单，就会再点击提交按钮重复提交表单，我们在开发中必须防止表单重复提交。 一、表单重复提交的常见应用场景有如下的form.jsp页面 12345678910111213141516171819&lt;%-- Created by IntelliJ IDEA. User: wuqinghua Date: 17/7/4 Time: 上午8:33 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Form表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="$&#123;pageContext.request.contextPath&#125;/repeatSubmitServlet" method="post"&gt; 用户名：&lt;input type="text" name="username" /&gt; &lt;input type="submit" value="提交" id="submit" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 后台servlet 12345678910111213141516171819202122232425262728package org.wuqinghua.java.ch06;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.concurrent.TimeUnit;/** * Created by wuqinghua on 17/7/4. */@WebServlet(urlPatterns = "/repeatSubmitServlet")public class RepeatSubmitServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding("UTF-8"); String username = req.getParameter("username"); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("向数据库中添加数据："+username); &#125;&#125; 如果没有进行form表单重复提交处理，那么在网络延迟的情况下下面的操作将会导致form表单重复提交多次 1.1、场景一：在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交 演示动画如下所示： 1.2、场景二：表单提交后用户点击【刷新】按钮导致表单重复提交演示动画如下所示： 点击浏览器的刷新按钮，就是把浏览器上次做的事情再做一次，因为这样也会导致表单重复提交。 1.3、场景三：用户提交表单后，点击浏览器的【后退】按钮回退到表单页面后进行再次提交演示动画如下所示： 二、利用JavaScript防止表单重复提交 既然存在上述所说的表单重复提交问题，那么我们就要想办法解决，比较常用的方法是采用JavaScript来防止表单重复提交，具体做法如下： 修改form.jsp页面，添加如下的JavaScript代码来防止表单重复提交 12345678910111213141516171819202122232425262728293031&lt;%-- Created by IntelliJ IDEA. User: wuqinghua Date: 17/7/4 Time: 上午8:33 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Form表单&lt;/title&gt; &lt;script&gt; var isCommitted = false;//表单 function doSubmit()&#123; if (!isCommitted)&#123; isCommitted=true; return true; &#125;else&#123; return false; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="$&#123;pageContext.request.contextPath&#125;/repeatSubmitServlet" method="post" onsubmit="return doSubmit()"&gt; 用户名：&lt;input type="text" name="username" /&gt; &lt;input type="submit" value="提交" id="submit" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 我们看看使用了JavaScript来防止表单提交重复是否可以成功，运行效果如下： 可以看到，针对”在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交“这个应用场景，使用JavaScript是可以解决这个问题的，解决的做法就是“用JavaScript控制Form表单只能提交一次“。 除了用这种方式之外，经常见的另一种方式就是表单提交之后，将提交按钮设置为不可用，让用户没有机会点击第二次提交按钮，代码如下： 12345678function dosubmit()&#123; //获取表单提交按钮 var btnSubmit = document.getElementById("submit"); //将表单提交按钮设置为不可用，这样就可以避免用户再次点击提交按钮 btnSubmit.disabled= "disabled"; //返回true让表单可以正常提交 return true;&#125; 运行效果如下： 另外还有一种做法就是提交表单后，将提交按钮隐藏起来，这种做法和将提交按钮设置为不可用是差不多的，个人觉得将提交按钮隐藏影响到页面布局的美观，并且可能会让用户误以为是bug(怎么我一点击按钮，按钮就不见了呢？用户可能会有这样的疑问)，我个人在开发中用得比较多的是表单提交后，将提交按钮设置为不可用，反正使用JavaScript防止表单重复提交的做法都是差不多的，目的都是让表单只能提交一次，这样就可以做到表单不重复提交了。 使用JavaScript防止表单重复提交的做法只对上述提交到导致表单重复提交的三种场景中的【场景一】有效，而对于【场景二】和【场景三】是没有用，依然无法解决表单重复提交问题。 三、利用Session防止表单重复提交 对于【场景二】和【场景三】导致表单重复提交的问题，既然客户端无法解决，那么就在服务器端解决，在服务器端解决就需要用到session了。 具体的做法：在服务器端生成一个唯一的随机标识号，专业术语称为Token(令牌)，同时在当前用户的Session域中保存这个Token。然后将Token发送到客户端的Form表单中，在Form表单中使用隐藏域来存储这个Token，表单提交的时候连同这个Token一起提交到服务器端，然后在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致，如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。如果相同则处理表单提交，处理完后清除当前用户的Session域中存储的标识号。 在下列情况下，服务器程序将拒绝处理用户提交的表单请求： 存储Session域中的Token(令牌)与表单提交的Token(令牌)不同。 当前用户的Session中不存在Token(令牌)。 用户提交的表单数据中没有Token(令牌)。 看具体的范例： 1.创建FormServlet，用于生成Token(令牌)和跳转到form.jsp页面 1234567891011121314151617181920&lt;%-- Created by IntelliJ IDEA. User: wuqinghua Date: 17/7/4 Time: 上午8:33 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Form表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="$&#123;pageContext.request.contextPath&#125;/repeatSubmitServlet" method="post"&gt; 用户名：&lt;input type="text" name="username" /&gt; &lt;input type="hidden" name="token" value="$&#123;token&#125;"/&gt; &lt;input type="submit" value="提交" id="submit" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package org.wuqinghua.java.ch06;import org.wuqinghua.java.repeat.TokenProccessor;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.concurrent.TimeUnit;/** * Created by wuqinghua on 17/7/4. */@WebServlet(urlPatterns = "/repeatSubmitServlet")public class RepeatSubmitServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String token = TokenProccessor.getInstance().makeToken(); req.getSession().setAttribute("token", token); req.getRequestDispatcher("form.jsp").forward(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding("UTF-8"); if (!isRepeat(req)) &#123; String username = req.getParameter("username"); System.out.println("向数据库中添加数据：" + username); &#125; &#125; private boolean isRepeat(HttpServletRequest req) &#123; String token = req.getParameter("token"); if (token == null || "".equals(token)) &#123; return true; &#125; String sessionToken = (String) req.getSession().getAttribute("token"); if (sessionToken == null || "".equals(sessionToken)) &#123; return true; &#125; if (!token.equals(sessionToken)) &#123; return true; &#125; req.getSession().removeAttribute("token"); return false; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package org.wuqinghua.java.ch06;import org.wuqinghua.java.repeat.TokenProccessor;import sun.misc.BASE64Encoder;import sun.plugin2.message.Message;import javax.xml.crypto.dsig.DigestMethod;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Base64;import java.util.Random;/** * Created by wuqinghua on 17/7/4. */public class TokenProcessor &#123; /** * 单例设计模式 * 1.把类的构造方法设计为私有的 * 2.自己创建一个类的对象 * 3.对外提供一个公共的方法，返回类的对象 */ private static TokenProccessor instance = new TokenProccessor(); private TokenProcessor()&#123;&#125; public static TokenProccessor getInstance()&#123; return instance; &#125; public String makeToken()&#123; String token = (System.currentTimeMillis()+new Random().nextInt(999999999))+""; try &#123; MessageDigest md5 = MessageDigest.getInstance("md5"); byte[] digest = md5.digest(token.getBytes()); BASE64Encoder base64Encoder = new BASE64Encoder(); return base64Encoder.encode(digest); &#125; catch (NoSuchAlgorithmException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 首先访问FormServlet，在FormServlet中生成Token之后再重定向到form.jsp页面，这次是在服务器端处理表单重复提交的，运行效果如下： 从运行效果中可以看到，通过这种方式处理表单重复提交，可以解决上述的场景二和场景三中出现的表单重复提交问题。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十二)--Session]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81%E4%BA%8C-Session%2F</url>
    <content type="text"><![CDATA[[TOC] 一、Session简单介绍 在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。 二、Session和Cookie的主要区别 Cookie是把用户的数据写给用户的浏览器。 Session技术把用户的数据写到用户独占的session中。 Session对象由服务器创建，开发人员可以调用request对象的getSession方法得到session对象。 三、session实现原理3.1、服务器是如何实现一个session为一个用户浏览器服务的？ 服务器创建session出来后，会把session的id号，以cookie的形式回写给客户机，这样，只要客户机的浏览器不关，再去访问服务器时，都会带着session的id号去，服务器发现客户机浏览器带session id过来了，就会使用内存中与之对应的session为之服务。可以用如下的代码证明： 123456789101112131415161718192021222324252627282930313233343536package org.wuqinghua.java.ch03;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/sessionDemo01")public class SessionDemo01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding("UTF-8"); resp.setContentType("text/html;charset=UTF-8"); HttpSession session = req.getSession();//获取session //将数据存储进去 session.setAttribute("data","孤傲苍狼"); //获取session的id String sessionId = session.getId(); //判断session是否为新的 if(session.isNew())&#123; resp.getWriter().print("session创建成功！sessionId为:"+sessionId); &#125;else&#123; resp.getWriter().print("服务器已经存在该session了,sessionId为:"+sessionId); &#125; &#125;&#125; 第一次访问时，服务器会创建一个新的sesion，并且把session的Id以cookie的形式发送给客户端浏览器，如下图所示： 点击刷新按钮，再次请求服务器，此时就可以看到浏览器再请求服务器时，会把存储到cookie中的session的Id一起传递到服务器端了，如下图所示： 我猜想request.getSession()方法内部新创建了Session之后一定是做了如下的处理 1234567//获取session的IdString sessionId = session.getId();//将session的Id存储到名字为JSESSIONID的cookie中Cookie cookie = new Cookie("JSESSIONID", sessionId);//设置cookie的有效路径cookie.setPath(request.getContextPath());response.addCookie(cookie); 四、浏览器禁用Cookie后的session处理4.1、IE8禁用cookie1 工具-&gt;internet选项-&gt;隐私-&gt;设置-&gt;将滑轴拉到最顶上（阻止所有cookies） 4.2、解决方案：URL重写 response.encodeRedirectURL(java.lang.String url) 用于对sendRedirect方法后的url地址进行重写。 response.encodeURL(java.lang.String url)用于对表单action和超链接的url地址进行重写 4.3、范例：禁用Cookie后servlet共享Session中的数据IndexServlet 12345678910111213141516171819202122232425262728293031323334353637package org.wuqinghua.java.ch03;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.Map;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/index")public class IndexServlet extends HttpServlet&#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding("UTF-8"); resp.setContentType("text/html;charset=UTF-8"); PrintWriter out = resp.getWriter(); //创建session req.getSession(); out.print("本网站有如下图书:&lt;br /&gt;"); Map&lt;String,Book&gt; books = DB.getAll(); for (Map.Entry&lt;String,Book&gt; book: books.entrySet()) &#123; Book b = book.getValue(); String url = req.getContextPath()+"/buyServlet?id="+b.getId(); url = resp.encodeURL(url);//对于表单的action和超链接使用此方法重写 out.print(b.getName()+"&lt;a href='"+url+"'&gt;购买&lt;/a&gt;&lt;br /&gt;"); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829package org.wuqinghua.java.ch03;import java.util.HashMap;import java.util.Map;import java.util.StringJoiner;/** * Created by wuqinghua on 17/6/30. * 模拟数据库 */public class DB &#123; private static Map&lt;String, Book&gt; map = new HashMap&lt;&gt;(); static &#123; map.put("1", new Book("1", "javaweb开发")); map.put("2", new Book("2", "spring开发")); map.put("3", new Book("3", "hibernate开发")); map.put("4", new Book("4", "struts开发")); map.put("5", new Book("5", "ajax开发")); &#125; public static Map&lt;String,Book&gt; getAll()&#123; return map; &#125; public static Book get(String id)&#123; return map.get(id); &#125;&#125; 123456789101112131415161718192021222324252627282930313233package org.wuqinghua.java.ch03;/** * Created by wuqinghua on 17/6/30. */public class Book &#123; private String id; private String name; public Book() &#123; &#125; public Book(String id, String name) &#123; this.id = id; this.name = name; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package org.wuqinghua.java.ch03;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/buyServlet")public class BuyServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String id = req.getParameter("id"); Book book = DB.get(id);//得到想要购买的书 HttpSession session = req.getSession(); List&lt;Book&gt; books = (List&lt;Book&gt;) session.getAttribute("books"); if(books==null)&#123; books = new ArrayList&lt;&gt;(); session.setAttribute("books",books); &#125; books.add(book); String url = resp.encodeRedirectURL(req.getContextPath()+"/listCartServlet"); System.out.println(url); resp.sendRedirect(url); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940package org.wuqinghua.java.ch03;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;import java.io.PrintWriter;import java.util.List;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/listCartServlet")public class ListCartServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding("UTF-8"); resp.setContentType("text/html;charset=UTF-8"); PrintWriter out = resp.getWriter(); HttpSession session = req.getSession(); List&lt;Book&gt; books = (List&lt;Book&gt;) session.getAttribute("books"); if(books==null || books.size()==0)&#123; out.print("对不起，您没有购买任何产品。"); return; &#125; //显示用户的购买纪录 out.write("您买过如下产品:&lt;br /&gt;"); for (Book book: books) &#123; out.write(book.getName()+"&lt;br /&gt;"); &#125; &#125;&#125; 在禁用了cookie的IE8下的运行效果如下： 通过查看IndexServlet生成的html代码可以看到，每一个超链接后面都带上了session的Id，如下所示 12345本网站有如下书：&lt;br/&gt;javaweb开发 &lt;a href='/JavaWeb_Session_Study_20140720/servlet/BuyServlet;jsessionid=96BDFB9D87A08D5AB1EAA2537CDE2DB2?id=1'&gt;购买&lt;/a&gt;&lt;br/&gt;spring开发 &lt;a href='/JavaWeb_Session_Study_20140720/servlet/BuyServlet;jsessionid=96BDFB9D87A08D5AB1EAA2537CDE2DB2?id=2'&gt;购买&lt;/a&gt;&lt;br/&gt;hibernate开发 &lt;a href='/JavaWeb_Session_Study_20140720/servlet/BuyServlet;jsessionid=96BDFB9D87A08D5AB1EAA2537CDE2DB2?id=3'&gt;购买&lt;/a&gt;&lt;br/&gt;struts开发 &lt;a href='/JavaWeb_Session_Study_20140720/servlet/BuyServlet;jsessionid=96BDFB9D87A08D5AB1EAA2537CDE2DB2?id=4'&gt;购买&lt;/a&gt;&lt;br/&gt;ajax开发 &lt;a href='/JavaWeb_Session_Study_20140720/servlet/BuyServlet;jsessionid=96BDFB9D87A08D5AB1EAA2537CDE2DB2?id=5'&gt;购买&lt;/a&gt;&lt;br/&gt; 所以，当浏览器禁用了cookie后，就可以用URL重写这种解决方案解决Session数据共享问题。而且response. encodeRedirectURL(java.lang.String url) 和response. encodeURL(java.lang.String url)是两个非常智能的方法，当检测到浏览器没有禁用cookie时，那么就不进行URL重写了。我们在没有禁用cookie的火狐浏览器下访问，效果如下： 从演示动画中可以看到，浏览器第一次访问时，服务器创建Session，然后将Session的Id以Cookie的形式发送回给浏览器，response. encodeURL(java.lang.String url)方法也将URL进行了重写，当点击刷新按钮第二次访问，由于火狐浏览器没有禁用cookie，所以第二次访问时带上了cookie，此时服务器就可以知道当前的客户端浏览器并没有禁用cookie，那么就通知response. encodeURL(java.lang.String url)方法不用将URL进行重写了。 五、session对象的创建和销毁时机5.1、session对象的创建时机 在程序中第一次调用request.getSession()方法时就会创建一个新的Session，可以用isNew()方法来判断Session是不是新创建的 范例：创建session 12345678910//使用request对象的getSession()获取session，如果session不存在则创建一个HttpSession session = request.getSession();//获取session的IdString sessionId = session.getId();//判断session是不是新创建的if (session.isNew()) &#123; response.getWriter().print("session创建成功，session的id是："+sessionId);&#125;else &#123; response.getWriter().print("服务器已经存在session，session的id是："+sessionId);&#125; 5.2、session对象的销毁时机 session对象默认30分钟没有使用，则服务器会自动销毁session，在web.xml文件中可以手工配置session的失效时间，例如： 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; &lt;display-name&gt;&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 设置Session的有效时间:以分钟为单位--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt; 当需要在程序中手动设置Session失效时，可以手工调用session.invalidate方法，摧毁session。 123 HttpSession session = request.getSession();//手工调用session.invalidate方法，摧毁session session.invalidate();]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十一)--使用Cookie进行会话管理]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81%E4%B8%80-%E4%BD%BF%E7%94%A8Cookie%E8%BF%9B%E8%A1%8C%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[[TOC] 一、会话的概念 会话可简单理解为：用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。 有状态会话：一个同学来过教室，下次再来教室，我们会知道这个同学曾经来过，这称之为有状态会话。 二、会话过程中要解决的一些问题？ 每个用户在使用浏览器与服务器进行会话的过程中，不可避免各自会产生一些数据，程序要想办法为每个用户保存这些数据。 三、保存会话数据的两种技术3.1、Cookie Cookie是客户端技术，程序把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。这样，web资源处理的就是用户各自的数据了。 3.2、Session Session是服务器端技术，利用这个技术，服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象，由于session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户再去访问服务器中的其它web资源时，其它web资源再从用户各自的session中取出数据为用户服务。 四、Java提供的操作Cookie的API Java中的javax.servlet.http.Cookie类用于创建一个Cookie Cookie类的主要方法 No. 方法 类型 描述 1 Cookie(String name, String value) 构造方法 实例化Cookie对象，传入cooke名称和cookie的值 2 public String getName() 普通方法 取得Cookie的名字 3 public String getValue() 普通方法 取得Cookie的值 4 public void setValue(String newValue) 普通方法 设置Cookie的值 5 public void setMaxAge(int expiry) 普通方法 设置Cookie的最大保存时间，即cookie的有效期，当服务器给浏览器回送一个cookie时，如果在服务器端没有调用setMaxAge方法设置cookie的有效期，那么cookie的有效期只在一次会话过程中有效，用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一次会话，当用户关闭浏览器，会话就结束了，此时cookie就会失效，如果在服务器端使用setMaxAge方法设置了cookie的有效期，比如设置了30分钟，那么当服务器把cookie发送给浏览器时，此时cookie就会在客户端的硬盘上存储30分钟，在30分钟内，即使浏览器关了，cookie依然存在，在30分钟内，打开浏览器访问服务器时，浏览器都会把cookie一起带上，这样就可以在服务器端获取到客户端浏览器传递过来的cookie里面的信息了，这就是cookie设置maxAge和不设置maxAge的区别，不设置maxAge，那么cookie就只在一次会话中有效，一旦用户关闭了浏览器，那么cookie就没有了，那么浏览器是怎么做到这一点的呢，我们启动一个浏览器，就相当于启动一个应用程序，而服务器回送的cookie首先是存在浏览器的缓存中的，当浏览器关闭时，浏览器的缓存自然就没有了，所以存储在缓存中的cookie自然就被清掉了，而如果设置了cookie的有效期，那么浏览器在关闭时，就会把缓存中的cookie写到硬盘上存储起来，这样cookie就能够一直存在了。 6 public int getMaxAge() 普通方法 获取Cookies的有效期 7 public void setPath(String uri) 普通方法 设置cookie的有效路径，比如把cookie的有效路径设置为”/xdp”，那么浏览器访问”xdp”目录下的web资源时，都会带上cookie，再比如把cookie的有效路径设置为”/xdp/gacl”，那么浏览器只有在访问”xdp”目录下的”gacl”这个目录里面的web资源时才会带上cookie一起访问，而当访问”xdp”目录下的web资源时，浏览器是不带cookie的 8 public String getPath() 普通方法 获取cookie的有效路径 9 public void setDomain(String pattern) 普通方法 设置cookie的有效域 10 public String getDomain() 普通方法 获取cookie的有效域 response接口也中定义了一个addCookie方法，它用于在其响应头中增加一个相应的Set-Cookie头字段。 同样，request接口中也定义了一个getCookies方法，它用于获取客户端提交的Cookie。 五、Cookie使用范例5.1、使用cookie记录用户上一次访问的时间123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package org.wuqinghua.java.ch02;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.Date;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = &#123;"/cookieDemo01"&#125;)public class CookieDemo01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置服务器以UTF－8编码进行输出 resp.setCharacterEncoding("utf-8"); //设置浏览器以UTF－8进行接受，解决乱码问题 resp.setContentType("text/html;charset=UTF-8"); PrintWriter writer = resp.getWriter(); //获取浏览器访问服务器时传递的cookie Cookie[] cookies = req.getCookies(); //如果是第一次访问那么cookies为null if (cookies!=null)&#123; writer.print("您上次访问的时间为:"); for (Cookie cookie: cookies) &#123; if(cookie.getName().equals("lastAccessTime"))&#123; long lastAccessTime = Long.parseLong(cookie.getValue()); Date date = new Date(lastAccessTime); writer.write(date.toLocaleString()); &#125; &#125; &#125;else&#123; writer.write("您是第一次访问本站."); &#125; //用户访问之后重新设置用户的访问时间,存储到cookie中，然后在发送给浏览器 Cookie cookie = new Cookie("lastAccessTime",System.currentTimeMillis()+""); //将cookie添加到resp对象中 resp.addCookie(cookie); &#125;&#125; 第一次访问时这个Servlet时，效果如下所示： 点击浏览器的刷新按钮，进行第二次访问，此时就服务器就可以通过cookie获取浏览器上一次访问的时间了，效果如下： 在上面的例子中，在程序代码中并没有使用setMaxAge方法设置cookie的有效期，所以当关闭浏览器之后，cookie就失效了，要想在关闭了浏览器之后，cookie依然有效，那么在创建cookie时，就要为cookie设置一个有效期。如下所示： 123456//用户访问之后重新设置用户的访问时间,存储到cookie中，然后在发送给浏览器 Cookie cookie = new Cookie("lastAccessTime",System.currentTimeMillis()+""); //设置Cookie有效期为一天 cookie.setMaxAge(24*60*60); //将cookie添加到resp对象中 resp.addCookie(cookie); 用户第一次访问时，服务器发送给浏览器的cookie就存储到了硬盘上，如下所示： 这样即使关闭了浏览器，下次再访问时，也依然可以通过cookie获取用户上一次访问的时间。 六、Cookie注意细节 一个Cookie只能标识一种信息，它至少含有一个标识该信息的名称（NAME）和设置值（VALUE）。 一个WEB站点可以给一个WEB浏览器发送多个Cookie，一个WEB浏览器也可以存储多个WEB站点提供的Cookie。 浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB。 如果创建了一个cookie，并将他发送到浏览器，默认情况下它是一个会话级别的cookie（即存储在浏览器的内存中），用户退出浏览器之后即被删除。若希望浏览器将该cookie存储在磁盘上，则需要使用maxAge，并给出一个以秒为单位的时间。将最大时效设为0则是命令浏览器删除该cookie。 6.1、删除Cookie注意：删除cookie时，path必须一致，否则不会删除 12345678910111213141516171819202122232425package org.wuqinghua.java.ch02;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/cookieDemo02")public class CookieDemo02 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //创建一个名字为lastAccessTime的cookie Cookie cookie = new Cookie("lastAccessTime",System.currentTimeMillis()+""); //将cookie的有效期设置为0，命令浏览器删除该cookie cookie.setMaxAge(0); resp.addCookie(cookie); &#125;&#125; 6.2、cookie中存取中文 要想在cookie中存储中文，那么必须使用URLEncoder类里面的encode(String s, String enc)方法进行中文转码，例如： 1Cookie cookie = new Cookie("userName", URLEncoder.encode("孤傲苍狼", "UTF-8")); response.addCookie(cookie); 在获取cookie中的中文数据时，再使用URLDecoder类里面的decode(String s, String enc)进行解码，例如： 1URLDecoder.decode(cookies[i].getValue(), "UTF-8")]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十)--HttpServletRequest]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81-HttpServletRequest%2F</url>
    <content type="text"><![CDATA[[TOC] 一、HttpServletRequest介绍 HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中，通过这个对象提供的方法，可以获得客户端请求的所有信息。 二、Request常用方法2.1、获得客户机信息 getRequestURL方法返回客户端发出请求时的完整URL。 getRequestURI方法返回请求行中的资源名部分。 getQueryString 方法返回请求行中的参数部分。 getPathInfo方法返回请求URL中的额外路径信息。额外路径信息是请求URL中的位于Servlet的路径之后和查询参数之前的内容，它以“/”开头。 getRemoteAddr方法返回发出请求的客户机的IP地址。 getRemoteHost方法返回发出请求的客户机的完整主机名。 getRemotePort方法返回客户机所使用的网络端口号。 getLocalAddr方法返回WEB服务器的IP地址。 getLocalName方法返回WEB服务器的主机名。 范例：通过request对象获取客户端请求信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package org.wuqinghua.java.ch05;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * Created by wuqinghua on 17/7/3. */@WebServlet(urlPatterns = "/requestDemo01")public class RequestDemo01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; /** * 获取客户端信息 */ String requestUrl = req.getRequestURL().toString();//获取请求的url地址 String requestURI = req.getRequestURI();//获取请求的资源 String queryString = req.getQueryString();//获取请求参数中附带的参数 String remoteAddr = req.getRemoteAddr();//获取来访的ip String remoteHost = req.getRemoteHost(); int remotePort = req.getRemotePort();//获取来访的端口 String remoteUser = req.getRemoteUser(); String method = req.getMethod();//得到请求url使用的方法 String pathInfo = req.getPathInfo(); String localAddr = req.getLocalAddr();//获取服务器的ip地址 String localName = req.getLocalName();//获取服务器的主机名称 resp.setCharacterEncoding("UTF-8"); resp.setContentType("text/html;charset=UTF-8"); PrintWriter out = resp.getWriter(); out.print("获取到的客户机信息如下:"); out.print("&lt;hr /&gt;"); out.print("请求的url：" + requestUrl); out.print("&lt;br /&gt;"); out.print("请求的资源:" + requestURI); out.print("&lt;br /&gt;"); out.print("附带的参数:" + queryString); out.print("&lt;br /&gt;"); out.print("来访者的ip地址:" + remoteAddr); out.print("&lt;br /&gt;"); out.print("来访者的主机名称:" + remoteHost); out.print("&lt;br /&gt;"); out.print("来访者的端口:" + remotePort); out.print("&lt;br /&gt;"); out.print("remoteUser:" + remoteUser); out.print("&lt;br /&gt;"); out.print("请求方法:" + method); out.print("&lt;br /&gt;"); out.print("pathInfo:" + pathInfo); out.print("&lt;br /&gt;"); out.print("服务器的ip:" + localAddr); out.print("&lt;br /&gt;"); out.print("服务器的主机:" + localName); &#125;&#125; 运行结果： 2.2、获得客户机请求头 getHeader(string name)方法:String getHeaders(String name)方法:Enumeration getHeaderNames()方法 范例：通过request对象获取客户端请求头信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package org.wuqinghua.java.ch05;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.Enumeration;/** * Created by wuqinghua on 17/7/3. */@WebServlet(urlPatterns = "/requestDemo02")public class ResquestDemo02 extends HttpServlet&#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding("utf-8"); resp.setContentType("text/html;charset=utf-8"); PrintWriter out = resp.getWriter(); Enumeration&lt;String&gt; headerNames = req.getHeaderNames();//获取所有的头部 out.print("获取客户端请求头部如下:"); out.print("&lt;hr /&gt;"); while (headerNames.hasMoreElements())&#123; String headName = headerNames.nextElement(); String headerValue = req.getHeader(headName);//根据头部名称获取头部值 out.print(headName+":"+headerValue); out.print("&lt;br /&gt;"); &#125; out.write("&lt;br/&gt;"); out.write("获取到的客户端Accept-Encoding请求头的值："); out.write("&lt;hr/&gt;"); String value = req.getHeader("Accept-Encoding");//获取Accept-Encoding请求头对应的值 out.write(value); Enumeration&lt;String&gt; e = req.getHeaders("Accept-Encoding"); while (e.hasMoreElements()) &#123; String string = e.nextElement(); System.out.println(string); &#125; &#125;&#125; 运行结果如下： 2.3、获得客户机请求参数(客户端提交的数据) getParameter(String)方法(常用) getParameterValues(String name)方法(常用) getParameterNames()方法(不常用) getParameterMap()方法(编写框架时常用) 比如现在有如下的form表单 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Html的Form表单元素&lt;/title&gt;&lt;/head&gt;&lt;fieldset style="width:500px;"&gt; &lt;legend&gt;Html的Form表单元素&lt;/legend&gt; &lt;!--form表单的action属性规定当提交表单时，向何处发送表单数据，method属性指明表单的提交方式，分为get和post，默认为get--&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/servlet/RequestDemo03" method="post"&gt; &lt;!--输入文本框，SIZE表示显示长度，maxlength表示最多输入长度--&gt; 编&amp;nbsp;&amp;nbsp;号(文本框)： &lt;input type="text" name="userid" value="NO." size="2" maxlength="2"&gt;&lt;br&gt; &lt;!--输入文本框，通过value指定其显示的默认值--&gt; 用户名(文本框)：&lt;input type="text" name="username" value="请输入用户名"&gt;&lt;br&gt; &lt;!--密码框，其中所有输入的内容都以密文的形式显示--&gt; 密&amp;nbsp;&amp;nbsp;码(密码框)： &lt;!--&amp;nbsp;表示的是一个空格--&gt; &lt;input type="password" name="userpass" value="请输入密码"&gt;&lt;br&gt; &lt;!--单选按钮，通过checked指定默认选中，名称必须一样，其中value为真正需要的内容--&gt; 性&amp;nbsp;&amp;nbsp;别(单选框)： &lt;input type="radio" name="sex" value="男" checked&gt;男 &lt;input type="radio" name="sex" value="女"&gt;女&lt;br&gt; &lt;!--下拉列表框，通过&lt;option&gt;元素指定下拉的选项--&gt; 部&amp;nbsp;&amp;nbsp;门(下拉框)： &lt;select name="dept"&gt; &lt;option value="技术部"&gt;技术部&lt;/option&gt; &lt;option value="销售部" SELECTED&gt;销售部&lt;/option&gt; &lt;option value="财务部"&gt;财务部&lt;/option&gt; &lt;/select&gt;&lt;br&gt; &lt;!--复选框，可以同时选择多个选项，名称必须一样，其中value为真正需要的内容--&gt; 兴&amp;nbsp;&amp;nbsp;趣(复选框)： &lt;input type="checkbox" name="inst" value="唱歌"&gt;唱歌 &lt;input type="checkbox" name="inst" value="游泳"&gt;游泳 &lt;input type="checkbox" name="inst" value="跳舞"&gt;跳舞 &lt;input type="checkbox" name="inst" value="编程" checked&gt;编程 &lt;input type="checkbox" name="inst" value="上网"&gt;上网 &lt;br&gt; &lt;!--大文本输入框，宽度为34列，高度为5行--&gt; 说&amp;nbsp;&amp;nbsp;明(文本域)： &lt;textarea name="note" cols="34" rows="5"&gt; &lt;/textarea&gt; &lt;br&gt; &lt;!--隐藏域，在页面上无法看到，专门用来传递参数或者保存参数--&gt; &lt;input type="hidden" name="hiddenField" value="hiddenvalue"/&gt; &lt;!--提交表单按钮，当点击提交后，所有填写的表单内容都会被传输到服务器端--&gt; &lt;input type="submit" value="提交(提交按钮)"&gt; &lt;!--重置表单按钮，当点击重置后，所有表单恢复原始显示内容--&gt; &lt;input type="reset" value="重置(重置按钮)"&gt;&lt;/form&gt;&lt;!--表单结束--&gt;&lt;/fieldset&gt;&lt;/body&gt;&lt;!--完结标记--&gt;&lt;/html&gt;&lt;!--完结标记--&gt; 在Form表单中填写数据，然后提交到RequestDemo03这个Servlet进行处理，填写的表单数据如下： 在服务器端使用getParameter方法和getParameterValues方法接收表单参数，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package gacl.request.study;import java.io.IOException;import java.text.MessageFormat;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author gacl * 获取客户端通过Form表单提交上来的参数 */public class RequestDemo03 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //客户端是以UTF-8编码提交表单数据的，所以需要设置服务器端以UTF-8的编码进行接收，否则对于中文数据就会产生乱码 request.setCharacterEncoding("UTF-8"); /** * 编&amp;nbsp;&amp;nbsp;号(文本框)： &lt;input type="text" name="userid" value="NO." size="2" maxlength="2"&gt; */ String userid = request.getParameter("userid");//获取填写的编号，userid是文本框的名字，&lt;input type="text" name="userid"&gt; /** * 用户名(文本框)：&lt;input type="text" name="username" value="请输入用户名"&gt; */ String username = request.getParameter("username");//获取填写的用户名 /** * 密&amp;nbsp;&amp;nbsp;码(密码框)：&lt;input type="password" name="userpass" value="请输入密码"&gt; */ String userpass = request.getParameter("userpass");//获取填写的密码 String sex = request.getParameter("sex");//获取选中的性别 String dept = request.getParameter("dept");//获取选中的部门 //获取选中的兴趣，因为可以选中多个值，所以获取到的值是一个字符串数组，因此需要使用getParameterValues方法来获取 String[] insts = request.getParameterValues("inst"); String note = request.getParameter("note");//获取填写的说明信息 String hiddenField = request.getParameter("hiddenField");//获取隐藏域的内容 String instStr=""; /** * 获取数组数据的技巧，可以避免insts数组为null时引发的空指针异常错误！ */ for (int i = 0; insts!=null &amp;&amp; i &lt; insts.length; i++) &#123; if (i == insts.length-1) &#123; instStr+=insts[i]; &#125;else &#123; instStr+=insts[i]+","; &#125; &#125; String htmlStr = "&lt;table&gt;" + "&lt;tr&gt;&lt;td&gt;填写的编号：&lt;/td&gt;&lt;td&gt;&#123;0&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;填写的用户名：&lt;/td&gt;&lt;td&gt;&#123;1&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;填写的密码：&lt;/td&gt;&lt;td&gt;&#123;2&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;选中的性别：&lt;/td&gt;&lt;td&gt;&#123;3&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;选中的部门：&lt;/td&gt;&lt;td&gt;&#123;4&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;选中的兴趣：&lt;/td&gt;&lt;td&gt;&#123;5&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;填写的说明：&lt;/td&gt;&lt;td&gt;&#123;6&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;隐藏域的内容：&lt;/td&gt;&lt;td&gt;&#123;7&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;/table&gt;"; htmlStr = MessageFormat.format(htmlStr, userid,username,userpass,sex,dept,instStr,note,hiddenField); response.setCharacterEncoding("UTF-8");//设置服务器端以UTF-8编码输出数据到客户端 response.setContentType("text/html;charset=UTF-8");//设置客户端浏览器以UTF-8编码解析数据 response.getWriter().write(htmlStr);//输出htmlStr里面的内容到客户端浏览器显示 &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 运行结果如下： 在服务器端使用getParameterNames方法接收表单参数，代码如下： 123456Enumeration&lt;String&gt; paramNames = request.getParameterNames();//获取所有的参数名 while (paramNames.hasMoreElements()) &#123; String name = paramNames.nextElement();//得到参数名 String value = request.getParameter(name);//通过参数名获取对应的值 System.out.println(MessageFormat.format("&#123;0&#125;=&#123;1&#125;", name,value)); &#125; 运行结果如下： 在服务器端使用getParameterMap方法接收表单参数，代码如下： 123456789101112131415//request对象封装的参数是以Map的形式存储的 Map&lt;String, String[]&gt; paramMap = request.getParameterMap(); for(Map.Entry&lt;String, String[]&gt; entry :paramMap.entrySet())&#123; String paramName = entry.getKey(); String paramValue = ""; String[] paramValueArr = entry.getValue(); for (int i = 0; paramValueArr!=null &amp;&amp; i &lt; paramValueArr.length; i++) &#123; if (i == paramValueArr.length-1) &#123; paramValue+=paramValueArr[i]; &#125;else &#123; paramValue+=paramValueArr[i]+","; &#125; &#125; System.out.println(MessageFormat.format("&#123;0&#125;=&#123;1&#125;", paramName,paramValue)); &#125; 运行结果如下： 三、request接收表单提交中文参数乱码问题3.1、以POST方式提交表单中文参数的乱码问题例如有如下的form表单页面： 12345678910111213141516171819&lt;%-- Created by IntelliJ IDEA. User: wuqinghua Date: 17/7/3 Time: 下午9:13 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;request接受正文参数乱码&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="&lt;%=request.getContextPath()%&gt;/requestDemo04" method="post"&gt; 用户名： &lt;input type="text" name="userName"/&gt; &lt;input type="submit" value="post方式提交"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 代码如下: 1234567891011121314151617181920package org.wuqinghua.java.ch05;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/7/3. */@WebServlet(urlPatterns = "/requestDemo04")public class RequestDemo04 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String userName = req.getParameter("userName"); System.out.println("userName:"+userName); &#125;&#125; 运行结果为： 3.2、post方式提交中文数据乱码产生的原因和解决办法 可以看到，之所以会产生乱码，就是因为服务器和客户端沟通的编码不一致造成的，因此解决的办法是：在客户端和服务器之间设置一个统一的编码，之后就按照此编码进行数据的传输和接收。 由于客户端是以UTF-8字符编码将表单数据传输到服务器端的，因此服务器也需要设置以UTF-8字符编码进行接收，要想完成此操作，服务器可以直接使用从ServletRequest接口继承而来的”setCharacterEncoding(charset)”方法进行统一的编码设置。修改后的代码如下： 1234567891011121314151617181920212223242526package org.wuqinghua.java.ch05;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/7/3. */@WebServlet(urlPatterns = "/requestDemo04")public class RequestDemo04 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; /** * 客户端是以utf-8的编码提交到后台的，所以需要设置服务器端以utf－8的编码进行接收，否则对于中文数据就会产生乱码 */ req.setCharacterEncoding("UTF-8"); String userName = req.getParameter("userName"); System.out.println("userName:"+userName); &#125;&#125; 3.3、以GET方式提交表单中文参数的乱码问题12345678910public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * * 对于以get方式传输的数据，request即使设置了以指定的编码接收数据也是无效的，默认的还是使用ISO8859-1这个字符编码来接收数据 */ String name = request.getParameter("name");//接收数据 name =new String(name.getBytes("ISO8859-1"), "UTF-8") ;//获取request对象以ISO8859-1字符编码接收到的原始数据的字节数组，然后通过字节数组以指定的编码构建字符串，解决乱码问题 System.out.println("name："+name); &#125; 3.6、提交中文数据乱码问题总结 1、如果提交方式为post，想不乱码，只需要在服务器端设置request对象的编码即可，客户端以哪种编码提交的，服务器端的request对象就以对应的编码接收，比如客户端是以UTF-8编码提交的，那么服务器端request对象就以UTF-8编码接收(request.setCharacterEncoding(“UTF-8”)) 2、如果提交方式为get，设置request对象的编码是无效的，request对象还是以默认的ISO8859-1编码接收数据，因此要想不乱码，只能在接收到数据后再手工转换，步骤如下： 1).获取获取客户端提交上来的数据，得到的是乱码字符串,data=”???è?????” String data = request.getParameter(“paramName”); 2).查找ISO8859-1码表，得到客户机提交的原始数据的字节数组 byte[] source = data.getBytes(“ISO8859-1”); 3).通过字节数组以指定的编码构建字符串，解决乱码 data = new String(source, “UTF-8”); 通过字节数组以指定的编码构建字符串，这里指定的编码是根据客户端那边提交数据时使用的字符编码来定的，如果是GB2312，那么就设置成data = new String(source, “GB2312”)，如果是UTF-8，那么就设置成data = new String(source, “UTF-8”) 四、Request对象实现请求转发4.1、请求转发的基本概念 请求转发：指一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理。 请求转发的应用场景：MVC设计模式 在Servlet中实现请求转发的两种方式： 1、通过ServletContext的getRequestDispatcher(String path)方法，该方法返回一个RequestDispatcher对象，调用这个对象的forward方法可以实现请求转发。 例如：将请求转发的test.jsp页面 121 RequestDispatcher reqDispatcher =this.getServletContext().getRequestDispatcher(&quot;/test.jsp&quot;);2 reqDispatcher.forward(request, response); 2、通过request对象提供的getRequestDispatche(String path)方法，该方法返回一个RequestDispatcher对象，调用这个对象的forward方法可以实现请求转发。 例如：将请求转发的test.jsp页面 11 request.getRequestDispatcher(&quot;/test.jsp&quot;).forward(request, response); request对象同时也是一个域对象(Map容器)，开发人员通过request对象在实现转发时，把数据通过request对象带给其它web资源处理。 request对象作为一个域对象(Map容器)使用时，主要是通过以下的四个方法来操作 setAttribute(String name,Object o)方法，将数据作为request对象的一个属性存放到request对象中，例如：request.setAttribute(“data”, data); getAttribute(String name)方法，获取request对象的name属性的属性值，例如：request.getAttribute(“data”) removeAttribute(String name)方法，移除request对象的name属性，例如：request.removeAttribute(“data”) getAttributeNames方法，获取request对象的所有属性名，返回的是一个，例如：Enumeration attrNames = request.getAttributeNames(); 4.2、请求重定向和请求转发的区别 一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理，称之为请求转发/307。 一个web资源收到客户端请求后，通知浏览器去访问另外一个web资源进行处理，称之为请求重定向/302。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(九)--通过Servlet生成验证码]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B9%9D-%E9%80%9A%E8%BF%87Servlet%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[[TOC] 一、BufferedImage类介绍生成验证码图片主要用到了一个BufferedImage类，如下： 创建一个DrawImage Servlet，用来生成验证码图片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193package org.wuqinghua.java.ch04;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;/** * Created by wuqinghua on 17/7/3. */@WebServlet(urlPatterns = "/drawImage")public class DrawImage extends HttpServlet &#123; public static final int WIDTH = 120;//生成的图片的宽度 public static final int HEIGHT = 30;//生成的图片的高度 @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String createTypeFlag = req.getParameter("createTypeFlag"); //1.在内存中创建一个图片 BufferedImage image = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB); //2.获取到画笔 Graphics2D g = (Graphics2D) image.getGraphics(); //3.设置图片的背景颜色 setBackground(g, Color.WHITE); //4.设置边框 setBorder(g, Color.BLUE); //5.在图片上设置干扰线 drawRandomLine(g, Color.GREEN, 5); //6.在图片上生成随机验证码 String code = drawRandomCode(g, Color.RED, ImageType.getImageType(createTypeFlag)); //7.将验证码存入到session req.getSession().setAttribute("code", code); //8.设置响应头 resp.setHeader("content-type", "image/jpeg"); //9.不要缓存 resp.setDateHeader("expries", -1); resp.setHeader("Cache-Control", "no-cache"); resp.setHeader("Pragma", "no-cache"); //10.将图片写入浏览器 ImageIO.write(image,"jpg",resp.getOutputStream()); &#125; /** * 生成随机验证码 * * @param g * @param color * @param imageType * @return */ private String drawRandomCode(Graphics2D g, Color color, ImageType imageType) &#123; g.setColor(color); //设置字体 g.setFont(new Font("宋体", Font.BOLD, 20)); //常用的中国汉字 String baseChineseChar = "\u7684\u4e00\u4e86\u662f\u6211\u4e0d\u5728\u4eba\u4eec\u6709\u6765\u4ed6\u8fd9\u4e0a\u7740\u4e2a\u5730\u5230\u5927\u91cc\u8bf4\u5c31\u53bb\u5b50\u5f97\u4e5f\u548c\u90a3\u8981\u4e0b\u770b\u5929\u65f6\u8fc7\u51fa\u5c0f\u4e48\u8d77\u4f60\u90fd\u628a\u597d\u8fd8\u591a\u6ca1\u4e3a\u53c8\u53ef\u5bb6\u5b66\u53ea\u4ee5\u4e3b\u4f1a\u6837\u5e74\u60f3\u751f\u540c\u8001\u4e2d\u5341\u4ece\u81ea\u9762\u524d\u5934\u9053\u5b83\u540e\u7136\u8d70\u5f88\u50cf\u89c1\u4e24\u7528\u5979\u56fd\u52a8\u8fdb\u6210\u56de\u4ec0\u8fb9\u4f5c\u5bf9\u5f00\u800c\u5df1\u4e9b\u73b0\u5c71\u6c11\u5019\u7ecf\u53d1\u5de5\u5411\u4e8b\u547d\u7ed9\u957f\u6c34\u51e0\u4e49\u4e09\u58f0\u4e8e\u9ad8\u624b\u77e5\u7406\u773c\u5fd7\u70b9\u5fc3\u6218\u4e8c\u95ee\u4f46\u8eab\u65b9\u5b9e\u5403\u505a\u53eb\u5f53\u4f4f\u542c\u9769\u6253\u5462\u771f\u5168\u624d\u56db\u5df2\u6240\u654c\u4e4b\u6700\u5149\u4ea7\u60c5\u8def\u5206\u603b\u6761\u767d\u8bdd\u4e1c\u5e2d\u6b21\u4eb2\u5982\u88ab\u82b1\u53e3\u653e\u513f\u5e38\u6c14\u4e94\u7b2c\u4f7f\u5199\u519b\u5427\u6587\u8fd0\u518d\u679c\u600e\u5b9a\u8bb8\u5feb\u660e\u884c\u56e0\u522b\u98de\u5916\u6811\u7269\u6d3b\u90e8\u95e8\u65e0\u5f80\u8239\u671b\u65b0\u5e26\u961f\u5148\u529b\u5b8c\u5374\u7ad9\u4ee3\u5458\u673a\u66f4\u4e5d\u60a8\u6bcf\u98ce\u7ea7\u8ddf\u7b11\u554a\u5b69\u4e07\u5c11\u76f4\u610f\u591c\u6bd4\u9636\u8fde\u8f66\u91cd\u4fbf\u6597\u9a6c\u54ea\u5316\u592a\u6307\u53d8\u793e\u4f3c\u58eb\u8005\u5e72\u77f3\u6ee1\u65e5\u51b3\u767e\u539f\u62ff\u7fa4\u7a76\u5404\u516d\u672c\u601d\u89e3\u7acb\u6cb3\u6751\u516b\u96be\u65e9\u8bba\u5417\u6839\u5171\u8ba9\u76f8\u7814\u4eca\u5176\u4e66\u5750\u63a5\u5e94\u5173\u4fe1\u89c9\u6b65\u53cd\u5904\u8bb0\u5c06\u5343\u627e\u4e89\u9886\u6216\u5e08\u7ed3\u5757\u8dd1\u8c01\u8349\u8d8a\u5b57\u52a0\u811a\u7d27\u7231\u7b49\u4e60\u9635\u6015\u6708\u9752\u534a\u706b\u6cd5\u9898\u5efa\u8d76\u4f4d\u5531\u6d77\u4e03\u5973\u4efb\u4ef6\u611f\u51c6\u5f20\u56e2\u5c4b\u79bb\u8272\u8138\u7247\u79d1\u5012\u775b\u5229\u4e16\u521a\u4e14\u7531\u9001\u5207\u661f\u5bfc\u665a\u8868\u591f\u6574\u8ba4\u54cd\u96ea\u6d41\u672a\u573a\u8be5\u5e76\u5e95\u6df1\u523b\u5e73\u4f1f\u5fd9\u63d0\u786e\u8fd1\u4eae\u8f7b\u8bb2\u519c\u53e4\u9ed1\u544a\u754c\u62c9\u540d\u5440\u571f\u6e05\u9633\u7167\u529e\u53f2\u6539\u5386\u8f6c\u753b\u9020\u5634\u6b64\u6cbb\u5317\u5fc5\u670d\u96e8\u7a7f\u5185\u8bc6\u9a8c\u4f20\u4e1a\u83dc\u722c\u7761\u5174\u5f62\u91cf\u54b1\u89c2\u82e6\u4f53\u4f17\u901a\u51b2\u5408\u7834\u53cb\u5ea6\u672f\u996d\u516c\u65c1\u623f\u6781\u5357\u67aa\u8bfb\u6c99\u5c81\u7ebf\u91ce\u575a\u7a7a\u6536\u7b97\u81f3\u653f\u57ce\u52b3\u843d\u94b1\u7279\u56f4\u5f1f\u80dc\u6559\u70ed\u5c55\u5305\u6b4c\u7c7b\u6e10\u5f3a\u6570\u4e61\u547c\u6027\u97f3\u7b54\u54e5\u9645\u65e7\u795e\u5ea7\u7ae0\u5e2e\u5566\u53d7\u7cfb\u4ee4\u8df3\u975e\u4f55\u725b\u53d6\u5165\u5cb8\u6562\u6389\u5ffd\u79cd\u88c5\u9876\u6025\u6797\u505c\u606f\u53e5\u533a\u8863\u822c\u62a5\u53f6\u538b\u6162\u53d4\u80cc\u7ec6"; //数字和字母的组合 String baseNumLetter = "0123456789ABCDEFGHJKLMNOPQRSTUVWXYZ"; //纯数字 String baseNum = "0123456789"; //纯字母 String baseLetter = "ABCDEFGHJKLMNOPQRSTUVWXYZ"; switch (imageType) &#123; case CH://汉字 return createRandomChar(g, baseChineseChar); case NL://数字和字母 return createRandomChar(g, baseNumLetter); case L: return createRandomChar(g, baseLetter); default: return createRandomChar(g, baseNum); &#125; &#125; /** * 根据基础字符生成随机字符串 * * @param g * @param baseChar * @return */ private String createRandomChar(Graphics2D g, String baseChar) &#123; StringBuffer buffer = new StringBuffer(); int x = 5; String ch = ""; //控制字数 for (int i = 0; i &lt; 4; i++) &#123; //设置字体的旋转角度 int degree = new Random().nextInt() % 30; ch = baseChar.charAt(new Random().nextInt(baseChar.length())) + ""; buffer.append(ch); //正向角度 g.rotate(degree * Math.PI / 180, x, 20); g.drawString(ch, x, 20); //反向角度 g.rotate(-degree * Math.PI / 180, x, 20); x += 30; &#125; return buffer.toString(); &#125; /** * 设置干扰线 * * @param g */ private void drawRandomLine(Graphics2D g, Color color, int lineCount) &#123; g.setColor(color); for (int i = 0; i &lt; lineCount; i++) &#123; int x1 = new Random().nextInt(WIDTH); int y1 = new Random().nextInt(HEIGHT); int x2 = new Random().nextInt(WIDTH); int y2 = new Random().nextInt(HEIGHT); g.drawLine(x1, y1, x2, y2); &#125; &#125; /** * 设置边框 * * @param g * @param color */ private void setBorder(Graphics2D g, Color color) &#123; g.setColor(color); g.drawRect(1, 1, WIDTH - 2, HEIGHT - 2); &#125; /** * 设置背景颜色 * * @param g */ private void setBackground(Graphics2D g, Color color) &#123; g.setColor(color); g.fillRect(0, 0, WIDTH, HEIGHT); &#125; private enum ImageType &#123; CH("ch"), NL("nl"), N("n"), L("l"); private String createTypeFlag = null; ImageType(String createTypeFlag) &#123; this.createTypeFlag = createTypeFlag; &#125; public static ImageType getImageType(String createTypeFlag) &#123; if (createTypeFlag.equals("ch")) &#123; return CH; &#125; else if (createTypeFlag.equals("nl")) &#123; return NL; &#125; else if (createTypeFlag.equals("L")) &#123; return L; &#125; else &#123; return N; &#125; &#125; String getValue() &#123; return this.createTypeFlag; &#125; &#125;&#125; 运行结果如下： 二、在Form表单中使用验证码图片1234567891011121314151617181920212223&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;在Form表单中使用验证码&lt;/title&gt; &lt;script type="text/javascript"&gt; //刷新验证码 function changeImg()&#123; document.getElementById("validateCodeImg").src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?"+Math.random(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/servlet/CheckServlet" method="post"&gt; 验证码：&lt;input type="text" name="validateCode"/&gt; &lt;img alt="验证码看不清，换一张" src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage" id="validateCodeImg" onclick="changeImg()"&gt; &lt;a href="javascript:void(0)" onclick="changeImg()"&gt;看不清，换一张&lt;/a&gt; &lt;br/&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 运行结果： DrawImage Servlet除了可以生成的字母和数字的组合的验证码图片之外，还可以生成汉字，纯数字，纯字母的验证码图片，只需要向DrawImage Servlet传递约定好的生成标识符参数即可，如下所示： 12345678910111213141516171819202122232425262728293031&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;在Form表单中使用验证码&lt;/title&gt; &lt;script type="text/javascript"&gt; //刷新验证码 function changeImg(obj,createTypeFlag)&#123; document.getElementById(obj.id).src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?createTypeFlag="+createTypeFlag+"&amp;"+Math.random(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/servlet/CheckServlet" method="post"&gt; 数字字母混合验证码：&lt;input type="text" name="validateCode"/&gt; &lt;img alt="验证码看不清，换一张" src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage" id="validateCodeImg1" onclick="changeImg(this,'nl')"&gt; &lt;br/&gt; 中文验证码：&lt;input type="text" name="validateCode"/&gt; &lt;img alt="验证码看不清，换一张" src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?createTypeFlag=ch" id="validateCodeImg2" onclick="changeImg(this,'ch')"&gt; &lt;br/&gt; 英文验证码：&lt;input type="text" name="validateCode"/&gt; &lt;img alt="验证码看不清，换一张" src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?createTypeFlag=l" id="validateCodeImg3" onclick="changeImg(this,'l')"&gt; &lt;br/&gt; 数字验证码：&lt;input type="text" name="validateCode"/&gt; &lt;img alt="验证码看不清，换一张" src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?createTypeFlag=n" id="validateCodeImg4" onclick="changeImg(this,'n')"&gt; &lt;br/&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 运行结果如下： 三、服务器端对form表单提交上来的验证码处理12345678910111213141516171819202122232425262728package gacl.response.study;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author gacl * 服务器端接收到验证码后的处理 */public class CheckServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String clientCheckcode = request.getParameter("validateCode");//接收客户端浏览器提交上来的验证码 String serverCheckcode = (String) request.getSession().getAttribute("checkcode");//从服务器端的session中取出验证码 if (clientCheckcode.equals(serverCheckcode)) &#123;//将客户端验证码和服务器端验证比较，如果相等，则表示验证通过 System.out.println("验证码验证通过！"); &#125;else &#123; System.out.println("验证码验证失败！"); &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(七)--HttpServletResponse(二)]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B8%83-HttpServletResponse-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 一、HttpServletResponse常见应用——生成验证码1.1、生成随机图片用作验证码 生成图片主要用到了一个BufferedImage类， 生成随机图片范例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package org.wuqinghua.java.ch04;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;/** * Created by wuqinghua on 17/7/2. */@WebServlet(urlPatterns = "/responseDemo05")public class ResponseDemo05 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置浏览器每隔5秒刷新一次 resp.setHeader("refresh", "5"); //1.在内存中创建一张图片 BufferedImage image = new BufferedImage(100, 25, BufferedImage.TYPE_INT_RGB); //2.绘制图片 获取画笔 Graphics2D g = (Graphics2D) image.getGraphics(); g.setColor(Color.WHITE);//设置图片的背景色 g.fillRect(0, 0, 100, 25);//填充背景 //3.向图片上写数值 g.setColor(Color.BLUE); g.setFont(new Font(null, Font.BOLD, 20)); g.drawString(makeNum(),0,20); //4.设置浏览器以图片方式打开 resp.setHeader("content-type","image/jpeg"); //5.设置浏览器不缓存图片 resp.setDateHeader("expries",-1); resp.setHeader("Cache-Control","no-cache"); resp.setHeader("Pragma","no-cache"); //6.将图片写到浏览器 ImageIO.write(image,"jpg",resp.getOutputStream()); &#125; private String makeNum() &#123; Random random = new Random(); String num = random.nextInt(9999999) + ""; StringBuffer buffer = new StringBuffer(); for (int i = 0; i &lt; 7 - num.length(); i++) &#123; buffer.append("0"); &#125; num = buffer.toString() + num; return num; &#125;&#125; 运行结果如下： 二、HttpServletResponse常见应用——设置响应头控制浏览器的行为2.1、设置http响应头控制浏览器禁止缓存当前文档内容123response.setDateHeader("expries", -1);response.setHeader("Cache-Control", "no-cache");response.setHeader("Pragma", "no-cache"); 2.2、设置http响应头控制浏览器定时刷新网页(refresh)1response.setHeader("refresh", "5");//设置refresh响应头控制浏览器每隔5秒钟刷新一次 2.3、通过response实现请求重定向 请求重定向指：一个web资源收到客户端请求后，通知客户端去访问另外一个web资源，这称之为请求重定向。 应用场景：用户登陆，用户首先访问登录页面，登录成功后，就会跳转到某个页面，这个过程就是一个请求重定向的过程 实现方式：response.sendRedirect(String location)，即调用response对象的sendRedirect方法实现请求重定向 sendRedirect内部的实现原理：使用response设置**302状态码和设置location响应头实现重定向** 例如： 1234567891011121314151617181920212223242526272829package gacl.response.study;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ResponseDemo04 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * 1.调用sendRedirect方法实现请求重定向, * sendRedirect方法内部调用了 * response.setHeader("Location", "/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"); * response.setStatus(HttpServletResponse.SC_FOUND);//设置302状态码，等同于response.setStatus(302); */ response.sendRedirect("/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"); //2.使用response设置302状态码和设置location响应头实现重定向实现请求重定向 //response.setHeader("Location", "/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"); //response.setStatus(HttpServletResponse.SC_FOUND);//设置302状态码，等同于response.setStatus(302); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 三、response细节问题 getOutputStream和getWriter方法分别用于得到输出二进制数据、输出文本数据的ServletOuputStream、Printwriter对象。 getOutputStream和getWriter这两个方法互相排斥，调用了其中的任何一个方法后，就不能再调用另一方法。 Servlet程序向ServletOutputStream或PrintWriter对象中写入的数据将被Servlet引擎从response里面获取，Servlet引擎将这些数据当作响应消息的正文，然后再与响应状态行和各响应头组合后输出到客户端。 Serlvet的service方法结束后，Servlet引擎将检查getWriter或getOutputStream方法返回的输出流对象是否已经调用过close方法，如果没有，Servlet引擎将调用close方法关闭该输出流对象。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(七)--HttpServletResponse(一)]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B8%83-HttpServletResponse-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[[TOC] Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对象。request和response对象即然代表请求和响应，那我们要获取客户机提交过来的数据，只需要找request对象就行了。要向客户机输出数据，只需要找response对象就行了。 一、HttpServletResponse对象介绍 HttpServletResponse对象代表服务器的响应。这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法。查看HttpServletResponse的API，可以看到这些相关的方法。 1.1、负责向客户端(浏览器)发送数据的相关方法 1.2、负责向客户端(浏览器)发送响应头的相关方法 1.3、负责向客户端(浏览器)发送响应状态码的相关方法 1.4、响应状态码的常量 HttpServletResponse定义了很多状态码的常量(具体可以查看Servlet的API)，当需要向客户端发送响应状态码时，可以使用这些常量，避免了直接写数字，常见的状态码对应的常量： 状态码404对应的常量 状态码200对应的常量 状态码500对应的常量 二、HttpServletResponse对象常见应用2.1、使用OutputStream流向客户端浏览器输出中文数据使用OutputStream流输出中文注意问题： 在服务器端，数据是以哪个码表输出的，那么就要控制客户端浏览器以相应的码表打开，比如：outputStream.write(“中国”.getBytes(“UTF-8”));使用OutputStream流向客户端浏览器输出中文，以UTF-8的编码进行输出，此时就要控制客户端浏览器以UTF-8的编码打开，否则显示的时候就会出现中文乱码，那么在服务器端如何控制客户端浏览器以以UTF-8的编码显示数据呢？可以通过设置响应头控制浏览器的行为，例如：response.setHeader(“content-type”, “text/html;charset=UTF-8”);通过设置响应头控制浏览器以UTF-8的编码显示数据。 范例：使用OutputStream流向客户端浏览器输出”中国”这两个汉字 123456789101112131415161718192021222324252627282930313233package org.wuqinghua.java.ch04;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.nio.charset.Charset;/** * Created by wuqinghua on 17/7/1. */@WebServlet(urlPatterns = "/responseDemo01")public class ResponseDemo01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String data = "中国"; ServletOutputStream outputStream = resp.getOutputStream();//获取输出流 resp.setContentType("text/html;charset=UTF-8");//通过响应头告诉浏览器需要使用utf-8显示数据 /** * data.getBytes()是一个将字符串转换为字节数组的过程，这个过程一定会查询码表， * 如果是中文操作系统，默认就会查询GB2312的码表， * 将字符串转换成字节数组的过程就是将中文字符转换为GB2312上对应的数字 * 比如： "中" 在GB2312上对应的数字为98 * "国" 为99 */ byte[] bytes = data.getBytes(Charset.forName("UTF-8")); outputStream.write(bytes); &#125;&#125; 运行结果如下： 客户端浏览器接收到数据后，就按照响应头上设置的字符编码来解析数据，如下所示： 2.2、使用PrintWriter流向客户端浏览器输出中文数据使用PrintWriter流输出中文注意问题： 在获取PrintWriter输出流之前首先使用”response.setCharacterEncoding(charset)”设置字符以什么样的编码输出到浏览器，如：response.setCharacterEncoding(“UTF-8”);设置将字符以”UTF-8”编码输出到客户端浏览器，然后再使用response.getWriter();获取PrintWriter输出流，这两个步骤不能颠倒，如下： 123456response.setCharacterEncoding("UTF-8");//设置将字符以"UTF-8"编码输出到客户端浏览器/*** PrintWriter out = response.getWriter();这句代码必须放在response.setCharacterEncoding("UTF-");之后* 否则response.setCharacterEncoding("UTF-8")这行代码的设置将无效，浏览器显示的时候还是乱码*/PrintWriter out = response.getWriter();//获取PrintWriter输出流 然后再使用response.setHeader(“content-type”, “text/html;charset=字符编码”);设置响应头，控制浏览器以指定的字符编码编码进行显示，例如： 12//通过设置响应头控制浏览器以UTF-8的编码显示数据，如果不加这句话，那么浏览器显示的将是乱码response.setHeader("content-type", "text/html;charset=UTF-8"); 除了可以使用response.setHeader(“content-type”, “text/html;charset=字符编码”);设置响应头来控制浏览器以指定的字符编码编码进行显示这种方式之外，还可以用如下的方式来模拟响应头的作用 123456/*** 多学一招：使用HTML语言里面的&lt;meta&gt;标签来控制浏览器行为，模拟通过设置响应头控制浏览器行为 *response.getWriter().write("&lt;meta http-equiv='content-type' content='text/html;charset=UTF-8'/&gt;");* 等同于response.setHeader("content-type", "text/html;charset=UTF-8");*/response.getWriter().write("&lt;meta http-equiv='content-type' content='text/html;charset=UTF-8'/&gt;"); 范例：使用PrintWriter流向客户端浏览器输出”中国”这两个汉字 123456789101112131415161718192021222324252627package org.wuqinghua.java.ch04;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * Created by wuqinghua on 17/7/2. */@WebServlet(urlPatterns = "/responseDemo02")public class ResponseDemo02 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String data = "中国"; resp.setCharacterEncoding("UTF-8"); resp.setContentType("text/html;charset=utf-8"); PrintWriter out = resp.getWriter(); out.print(data); &#125;&#125; 当需要向浏览器输出字符数据时，使用PrintWriter比较方便，省去了将字符转换成字节数组那一步。 2.3、使用OutputStream或者PrintWriter向客户端浏览器输出数字比如有如下的代码： 123456789101112131415161718192021222324package org.wuqinghua.java.ch04;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.OutputStream;/** * Created by wuqinghua on 17/7/2. */@WebServlet(urlPatterns = "/responseDemo03")public class ResponseDemo03 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setHeader("content-type","text/html;charset=utf-8"); OutputStream outputStream = resp.getOutputStream(); outputStream.write("使用outputStream向界面输出1:".getBytes("UTF-8")); outputStream.write(1); &#125;&#125; 运行上面代码显示的结果如下： 运行的结果和我们想象中的不一样，数字1没有输出来，下面我们修改一下上面的outputOneByOutputStream方法的代码，修改后的代码如下： 12345678910111213141516171819202122232425package org.wuqinghua.java.ch04;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.OutputStream;/** * Created by wuqinghua on 17/7/2. */@WebServlet(urlPatterns = "/responseDemo03")public class ResponseDemo03 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setHeader("content-type","text/html;charset=utf-8"); OutputStream outputStream = resp.getOutputStream(); outputStream.write("使用outputStream向界面输出1:".getBytes("UTF-8"));// outputStream.write(1); outputStream.write((1+"").getBytes("UTF-8")); &#125;&#125; 1+””这一步是将数字1和一个空字符串相加，这样处理之后，数字1就变成了字符串1了，然后再将字符串1转换成字节数组使用OutputStream进行输出，此时看到的结果如下： 这次可以看到输出来的1了，这说明了一个问题：在开发过程中，如果希望服务器输出什么浏览器就能看到什么，那么在服务器端都要以字符串的形式进行输出。 如果使用PrintWriter流输出数字，那么也要先将数字转换成字符串后再输出，如下： 12345678910111213/** * 使用PrintWriter流输出数字1 * @param request * @param response * @throws IOException */ public void outputOneByPrintWriter(HttpServletResponse response) throws IOException&#123; response.setHeader("content-type", "text/html;charset=UTF-8"); response.setCharacterEncoding("UTF-8"); PrintWriter out = response.getWriter();//获取PrintWriter输出流 out.write("使用PrintWriter流输出数字1："); out.write(1+""); &#125; 2.4、文件下载 文件下载功能是web开发中经常使用到的功能，使用HttpServletResponse对象就可以实现文件的下载 文件下载功能的实现思路： 1.获取要下载的文件的绝对路径 2.获取要下载的文件名 3.设置content-disposition响应头控制浏览器以下载的形式打开文件 4.获取要下载的文件输入流 5.创建数据缓冲区 6.通过response对象获取OutputStream流 7.将FileInputStream流写入到buffer缓冲区 8.使用OutputStream将缓冲区的数据输出到客户端浏览器 范例：使用Response实现文件下载 123456789101112131415161718192021222324252627282930313233343536373839package org.wuqinghua.java.ch04;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;/** * Created by wuqinghua on 17/7/2. */@WebServlet(urlPatterns = "/responseDemo04")public class ResponseDemo04 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取绝对路径 String realPath = this.getServletContext().getRealPath("/img/WP_20131005_002.jpg"); //2.获取文件的名称 String filename = realPath.substring(realPath.lastIndexOf("\\") + 1); //3.设置响应头content-disposition控制浏览器以下载的方式打开文件 resp.setHeader("content-disposition","attachment;filename="+filename); //4.获取文件的输入流 InputStream in = new FileInputStream(realPath); //5.获取输出流 OutputStream outputStream = resp.getOutputStream(); //6.将输入流写入到输出流中 byte[] buffer = new byte[4096]; int len = -1; while ((len=in.read(buffer,0,4096))!=-1)&#123; outputStream.write(buffer,0,len); &#125; outputStream.close(); &#125;&#125; 运行结果如下所示： 范例：**使用Response实现中文文件下载** 下载中文文件时，需要注意的地方就是中文文件名要使用URLEncoder.encode方法进行编码(URLEncoder.encode(fileName, “字符编码”))，否则会出现文件名乱码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package gacl.response.study;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.PrintWriter;import java.net.URLEncoder;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author gacl * 文件下载 */public class ResponseDemo02 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; downloadChineseFileByOutputStream(response);//下载中文文件 &#125; /** * 下载中文文件,中文文件下载时，文件名要经过URL编码，否则会出现文件名乱码 * @param response * @throws FileNotFoundException * @throws IOException */ private void downloadChineseFileByOutputStream(HttpServletResponse response) throws FileNotFoundException, IOException &#123; String realPath = this.getServletContext().getRealPath("/download/张家界国家森林公园.JPG");//获取要下载的文件的绝对路径 String fileName = realPath.substring(realPath.lastIndexOf("\\")+1);//获取要下载的文件名 //设置content-disposition响应头控制浏览器以下载的形式打开文件，中文文件名要使用URLEncoder.encode方法进行编码，否则会出现文件名乱码 response.setHeader("content-disposition", "attachment;filename="+URLEncoder.encode(fileName, "UTF-8")); InputStream in = new FileInputStream(realPath);//获取文件输入流 int len = 0; byte[] buffer = new byte[1024]; OutputStream out = response.getOutputStream(); while ((len = in.read(buffer)) &gt; 0) &#123; out.write(buffer,0,len);//将缓冲区的数据输出到客户端浏览器 &#125; in.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 运行结果如下所示： 文件下载注意事项：编写文件下载功能时推荐使用OutputStream流，避免使用PrintWriter流，因为OutputStream流是字节流，可以处理任意类型的数据，而PrintWriter流是字符流，只能处理字符数据，如果用字符流处理字节数据，会导致数据丢失。 范例：使用PrintWriter流下载文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package gacl.response.study;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.PrintWriter;import java.net.URLEncoder;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author gacl * 文件下载 */public class ResponseDemo02 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; downloadFileByPrintWriter(response);//下载文件，通过PrintWriter流 &#125; /** * 下载文件，通过PrintWriter流，虽然也能够实现下载，但是会导致数据丢失，因此不推荐使用PrintWriter流下载文件 * @param response * @throws FileNotFoundException * @throws IOException */ private void downloadFileByPrintWriter(HttpServletResponse response) throws FileNotFoundException, IOException &#123; String realPath = this.getServletContext().getRealPath("/download/张家界国家森林公园.JPG");//获取要下载的文件的绝对路径 String fileName = realPath.substring(realPath.lastIndexOf("\\")+1);//获取要下载的文件名 //设置content-disposition响应头控制浏览器以下载的形式打开文件，中文文件名要使用URLEncoder.encode方法进行编码 response.setHeader("content-disposition", "attachment;filename="+URLEncoder.encode(fileName, "UTF-8")); FileReader in = new FileReader(realPath); int len = 0; char[] buffer = new char[1024]; PrintWriter out = response.getWriter(); while ((len = in.read(buffer)) &gt; 0) &#123; out.write(buffer,0,len);//将缓冲区的数据输出到客户端浏览器 &#125; in.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 运行结果如下： 正常弹出下载框，此时我们点击【保存】按钮将文件下载下来，如下所示： 可以看到，只下载了5.25MB，而这张图片的原始大小却是 这说明在下载的时候数据丢失了，所以下载不完全，所以这张图片虽然能够正常下载下来，但是却是无法打开的，因为丢失掉了部分数据，如下所示： 所以使用PrintWriter流处理字节数据，会导致数据丢失，这一点千万要注意，因此在编写下载文件功能时，要使用OutputStream流，避免使用PrintWriter流，因为OutputStream流是字节流，可以处理任意类型的数据，而PrintWriter流是字符流，只能处理字符数据，如果用字符流处理字节数据，会导致数据丢失。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(六)--Servlet开发(二)]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%85%AD-Servlet%E5%BC%80%E5%8F%91-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 一、ServletConfig讲解1.1、通过ServletConfig获取Servlet的初始化参数 当servlet配置了初始化参数后，web容器在创建servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时，将ServletConfig对象传递给servlet。进而，我们通过ServletConfig对象就可以得到当前servlet的初始化参数信息。 ​ 例如: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package org.wuqinghua.java.ch01;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.annotation.WebInitParam;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Enumeration;/** * Created by wuqinghua on 17/6/30. */@WebServlet(name = "servletConfigDemo01",urlPatterns = &#123;"/servletConfigDemo01"&#125;,initParams =&#123;@WebInitParam(name = "name",value = "gacl"),@WebInitParam(name = "password",value = "123"),@WebInitParam(name = "charset",value = "UTF-8")&#125; )public class ServletConfigDemo01 extends HttpServlet &#123; //定义ServletConfig对象来接受配置的初始化参数 private ServletConfig servletConfig; /** *当servlet配置了初始化参数后，web容器在创建servlet实例对象时， * 会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时， * 将servletConfig对象传递给servlet。进而，通过ServletConfig对象就可以得到初始化数据 */ @Override public void init(ServletConfig config) throws ServletException &#123; this.servletConfig = config; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取配置的参数 String paramVal = this.servletConfig.getInitParameter("name"); resp.getWriter().print(paramVal); resp.getWriter().print("&lt;hr /&gt;"); //获取所有初始化参数 Enumeration&lt;String&gt; e = this.servletConfig.getInitParameterNames(); while (e.hasMoreElements())&#123; String name = e.nextElement(); String value = this.servletConfig.getInitParameter(name); resp.getWriter().print(name+"-"+value+"&lt;br /&gt;"); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 运行结果如下： 二、ServletContext对象 WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用。 ServletConfig对象中维护了ServletContext对象的引用，开发人员在编写servlet时，可以通过ServletConfig.getServletContext方法获得ServletContext对象。 由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。 三、ServletContext的应用 3.1、多个Servlet通过ServletContext对象实现数据共享 范例：ServletContextDemo1和ServletContextDemo2通过ServletContext对象实现数据共享 1234567891011121314151617181920212223242526272829303132333435package org.wuqinghua.java.ch01;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebInitParam;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/servletContextDemo01",initParams = @WebInitParam(name = "name",value = "hello"))public class ServletContextDemo01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String data = "xdp_gacl"; /** * 获取ServletContext */ ServletContext servletContext = this.getServletConfig().getServletContext(); ServletContext servletContext1 = this.getServletContext(); System.out.println(servletContext == servletContext1); System.out.println(this.getServletConfig().getInitParameter("name")); servletContext.setAttribute("data", data); &#125;&#125; 1234567891011121314151617181920212223package org.wuqinghua.java.ch01;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/servletContextDemo02")public class ServletContextDemo02 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext servletContext = this.getServletContext(); String data = (String) servletContext.getAttribute("data"); resp.getWriter().print("data="+data); &#125;&#125; 先运行ServletContextDemo1，将数据data存储到ServletContext对象中，然后运行ServletContextDemo2就可以从ServletContext对象中取出数据了，这样就实现了数据共享，如下图所示： 3.2、获取WEB应用的初始化参数 在web.xml文件中使用标签配置WEB应用的初始化参数，如下所示： 1234&lt;context-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql://localhost:3306/test&lt;/param-value&gt;&lt;/context-param&gt; 获取参数代码： 1234567891011121314151617181920212223package org.wuqinghua.java.ch01;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet("/servletContextDemo03")public class ServletContextDemo03 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取servletContext ServletContext servletContext = this.getServletContext(); String url = servletContext.getInitParameter("url"); resp.getWriter().print(url); &#125;&#125; 运行结果： 3.3、用servletContext实现请求转发1234567891011121314151617181920212223242526package org.wuqinghua.java.ch01;import javax.servlet.RequestDispatcher;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = &#123;"/servletContextDemo04"&#125;)public class ServletContextDemo04 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String data = "&lt;h1&gt;&lt;font color='red'&gt;abcdefghijkl&lt;/font&gt;&lt;/h1&gt;"; resp.getOutputStream().write(data.getBytes()); ServletContext servletContext = this.getServletContext(); RequestDispatcher rd = servletContext.getRequestDispatcher("/servletContextDemo05"); rd.forward(req,resp); &#125;&#125; 12345678910111213141516171819package org.wuqinghua.java.ch01;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/servletContextDemo05")public class ServletContextDemo05 extends HttpServlet&#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.getOutputStream().write("servletContextDemo05".getBytes()); &#125;&#125; 运行结果： 访问的是ServletContextDemo4，浏览器显示的却是ServletContextDemo5的内容，这就是使用ServletContext实现了请求转发 3.4、利用ServletContext对象读取资源文件项目目录结构如下： 代码范例：使用servletContext读取资源文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137package gacl.servlet.study;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.text.MessageFormat;import java.util.Properties;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 使用servletContext读取资源文件 * * @author gacl * */public class ServletContextDemo6 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * response.setContentType("text/html;charset=UTF-8");目的是控制浏览器用UTF-8进行解码； * 这样就不会出现中文乱码了 */ response.setHeader("content-type","text/html;charset=UTF-8"); readSrcDirPropCfgFile(response);//读取src目录下的properties配置文件 response.getWriter().println("&lt;hr/&gt;"); readWebRootDirPropCfgFile(response);//读取WebRoot目录下的properties配置文件 response.getWriter().println("&lt;hr/&gt;"); readPropCfgFile(response);//读取src目录下的db.config包中的db3.properties配置文件 response.getWriter().println("&lt;hr/&gt;"); readPropCfgFile2(response);//读取src目录下的gacl.servlet.study包中的db4.properties配置文件 &#125; /** * 读取src目录下的gacl.servlet.study包中的db4.properties配置文件 * @param response * @throws IOException */ private void readPropCfgFile2(HttpServletResponse response) throws IOException &#123; InputStream in = this.getServletContext().getResourceAsStream("/WEB-INF/classes/gacl/servlet/study/db4.properties"); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty("driver"); String url = prop.getProperty("url"); String username = prop.getProperty("username"); String password = prop.getProperty("password"); response.getWriter().println("读取src目录下的gacl.servlet.study包中的db4.properties配置文件："); response.getWriter().println( MessageFormat.format( "driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;", driver,url, username, password)); &#125; /** * 读取src目录下的db.config包中的db3.properties配置文件 * @param response * @throws FileNotFoundException * @throws IOException */ private void readPropCfgFile(HttpServletResponse response) throws FileNotFoundException, IOException &#123; //通过ServletContext获取web资源的绝对路径 String path = this.getServletContext().getRealPath("/WEB-INF/classes/db/config/db3.properties"); InputStream in = new FileInputStream(path); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty("driver"); String url = prop.getProperty("url"); String username = prop.getProperty("username"); String password = prop.getProperty("password"); response.getWriter().println("读取src目录下的db.config包中的db3.properties配置文件："); response.getWriter().println( MessageFormat.format( "driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;", driver,url, username, password)); &#125; /** * 通过ServletContext对象读取WebRoot目录下的properties配置文件 * @param response * @throws IOException */ private void readWebRootDirPropCfgFile(HttpServletResponse response) throws IOException &#123; /** * 通过ServletContext对象读取WebRoot目录下的properties配置文件 * “/”代表的是项目根目录 */ InputStream in = this.getServletContext().getResourceAsStream("/db2.properties"); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty("driver"); String url = prop.getProperty("url"); String username = prop.getProperty("username"); String password = prop.getProperty("password"); response.getWriter().println("读取WebRoot目录下的db2.properties配置文件："); response.getWriter().print( MessageFormat.format( "driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;", driver,url, username, password)); &#125; /** * 通过ServletContext对象读取src目录下的properties配置文件 * @param response * @throws IOException */ private void readSrcDirPropCfgFile(HttpServletResponse response) throws IOException &#123; /** * 通过ServletContext对象读取src目录下的db1.properties配置文件 */ InputStream in = this.getServletContext().getResourceAsStream("/WEB-INF/classes/db1.properties"); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty("driver"); String url = prop.getProperty("url"); String username = prop.getProperty("username"); String password = prop.getProperty("password"); response.getWriter().println("读取src目录下的db1.properties配置文件："); response.getWriter().println( MessageFormat.format( "driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;", driver,url, username, password)); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 运行结果如下： 代码范例：使用类装载器读取资源文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package gacl.servlet.study;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.text.MessageFormat;import java.util.Properties;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 用类装载器读取资源文件 * 通过类装载器读取资源文件的注意事项:不适合装载大文件，否则会导致jvm内存溢出 * @author gacl * */public class ServletContextDemo7 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * response.setContentType("text/html;charset=UTF-8");目的是控制浏览器用UTF-8进行解码； * 这样就不会出现中文乱码了 */ response.setHeader("content-type","text/html;charset=UTF-8"); test1(response); response.getWriter().println("&lt;hr/&gt;"); test2(response); response.getWriter().println("&lt;hr/&gt;"); //test3(); test4(); &#125; /** * 读取类路径下的资源文件 * @param response * @throws IOException */ private void test1(HttpServletResponse response) throws IOException &#123; //获取到装载当前类的类装载器 ClassLoader loader = ServletContextDemo7.class.getClassLoader(); //用类装载器读取src目录下的db1.properties配置文件 InputStream in = loader.getResourceAsStream("db1.properties"); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty("driver"); String url = prop.getProperty("url"); String username = prop.getProperty("username"); String password = prop.getProperty("password"); response.getWriter().println("用类装载器读取src目录下的db1.properties配置文件："); response.getWriter().println( MessageFormat.format( "driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;", driver,url, username, password)); &#125; /** * 读取类路径下面、包下面的资源文件 * @param response * @throws IOException */ private void test2(HttpServletResponse response) throws IOException &#123; //获取到装载当前类的类装载器 ClassLoader loader = ServletContextDemo7.class.getClassLoader(); //用类装载器读取src目录下的gacl.servlet.study包中的db4.properties配置文件 InputStream in = loader.getResourceAsStream("gacl/servlet/study/db4.properties"); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty("driver"); String url = prop.getProperty("url"); String username = prop.getProperty("username"); String password = prop.getProperty("password"); response.getWriter().println("用类装载器读取src目录下的gacl.servlet.study包中的db4.properties配置文件："); response.getWriter().println( MessageFormat.format( "driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;", driver,url, username, password)); &#125; /** * 通过类装载器读取资源文件的注意事项:不适合装载大文件，否则会导致jvm内存溢出 */ public void test3() &#123; /** * 01.avi是一个150多M的文件，使用类加载器去读取这个大文件时会导致内存溢出： * java.lang.OutOfMemoryError: Java heap space */ InputStream in = ServletContextDemo7.class.getClassLoader().getResourceAsStream("01.avi"); System.out.println(in); &#125; /** * 读取01.avi,并拷贝到e:\根目录下 * 01.avi文件太大，只能用servletContext去读取 * @throws IOException */ public void test4() throws IOException &#123; // path=G:\Java学习视频\JavaWeb学习视频\JavaWeb\day05视频\01.avi // path=01.avi String path = this.getServletContext().getRealPath("/WEB-INF/classes/01.avi"); /** * path.lastIndexOf("\\") + 1是一个非常绝妙的写法 */ String filename = path.substring(path.lastIndexOf("\\") + 1);//获取文件名 InputStream in = this.getServletContext().getResourceAsStream("/WEB-INF/classes/01.avi"); byte buffer[] = new byte[1024]; int len = 0; OutputStream out = new FileOutputStream("e:\\" + filename); while ((len = in.read(buffer)) &gt; 0) &#123; out.write(buffer, 0, len); &#125; out.close(); in.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 运行结果如下： 四、在客户端缓存Servlet的输出 对于不经常变化的数据，在servlet中可以为其设置合理的缓存时间值，以避免浏览器频繁向服务器发送请求，提升服务器的性能。例如： 1234567891011121314151617181920212223242526272829package gacl.servlet.study;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ServletDemo5 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String data = "abcddfwerwesfasfsadf"; /** * 设置数据合理的缓存时间值，以避免浏览器频繁向服务器发送请求，提升服务器的性能 * 这里是将数据的缓存时间设置为1天 */ response.setDateHeader("expires",System.currentTimeMillis() + 24 * 3600 * 1000); response.getOutputStream().write(data.getBytes()); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(五)--Servlet开发(一)]]></title>
    <url>%2F2017%2F06%2F29%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%BA%94-Servlet%E5%BC%80%E5%8F%91-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[[TOC] 一、Servlet简介 Servlet是sun公司提供的一门用于开发动态web资源的技术。 Sun公司在其API中提供了一个servlet接口，用户若想用发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤： 1、编写一个Java类，实现servlet接口。 2、把开发好的Java类部署到web服务器中。 按照一种约定俗成的称呼习惯，通常我们也把实现了servlet接口的java程序，称之为Servlet 二、Servlet的运行过程Servlet程序是由WEB服务器调用，web服务器收到客户端的Servlet访问请求后： ①Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第②步。 ②装载并创建该Servlet的一个实例对象。 ③调用Servlet实例对象的init()方法。 ④创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。 ⑤WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。 三、Servlet调用图 四、在Eclipse中开发Servlet 在eclipse中新建一个web project工程，eclipse会自动创建下图所示目录结构： 4.1、Servlet接口实现类 Servlet接口SUN公司定义了两个默认实现类，分别为：GenericServlet、HttpServlet。 HttpServlet指能够处理HTTP请求的servlet，它在原有Servlet接口上添加了一些与HTTP协议处理方法，它比Servlet接口的功能更为强大。因此开发人员在编写Servlet时，通常应继承这个类，而避免直接去实现Servlet接口。 HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。因此，开发人员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法。 4.2、通过Eclipse创建和编写Servlet 选中gacl.servlet.study包，右键→New→Servlet，如下图所示： 这样，我们就通过Eclipse帮我们创建好一个名字为ServletDemo1的Servlet，创建好的ServletDemo01里面会有如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 package gacl.servlet.study; import java.io.IOException; import java.io.PrintWriter; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;public class ServletDemo1 extends HttpServlet &#123; /** * The doGet method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to get. * * @param request the request send by the client to the server * @param response the response send by the server to the client * @throws ServletException if an error occurred * @throws IOException if an error occurred */ public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html"); PrintWriter out = response.getWriter(); out.println("&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;"); out.println("&lt;HTML&gt;"); out.println(" &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;"); out.println(" &lt;BODY&gt;"); out.print(" This is "); out.print(this.getClass()); out.println(", using the GET method"); out.println(" &lt;/BODY&gt;"); out.println("&lt;/HTML&gt;"); out.flush(); out.close(); &#125; /** * The doPost method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to post. * * @param request the request send by the client to the server * @param response the response send by the server to the client * @throws ServletException if an error occurred * @throws IOException if an error occurred */ public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html"); PrintWriter out = response.getWriter(); out.println("&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;"); out.println("&lt;HTML&gt;"); out.println(" &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;"); out.println(" &lt;BODY&gt;"); out.print(" This is "); out.print(this.getClass()); out.println(", using the POST method"); out.println(" &lt;/BODY&gt;"); out.println("&lt;/HTML&gt;"); out.flush(); out.close(); &#125;&#125; 这些代码都是Eclipse自动生成的，而web.xml文件中也多了和两对标签，这两对标签是配置ServletDemo1的，如下图所示： 然后我们就可以通过浏览器访问ServletDemo1这个Servlet，如下图所示： 五、Servlet开发注意细节5.1、Servlet访问URL映射配置 由于客户端是通过URL地址访问web服务器中的资源，所以Servlet程序若想被外界访问，必须把servlet程序映射到一个URL地址上，这个工作在web.xml文件中使用元素和元素完成。 元素用于注册Servlet，它包含有两个主要的子元素：和，分别用于设置Servlet的注册名称和Servlet的完整类名。一个元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：和，分别用于指定Servlet的注册名称和Servlet的对外访问路径。例如： 123456789&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;gacl.servlet.study.ServletDemo1&lt;/servlet-class&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/ServletDemo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 同一个Servlet可以被映射到多个URL上，即多个元素的子元素的设置值可以是同一个Servlet的注册名。 例如： 12345678910111213141516171819202122232425 &lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;gacl.servlet.study.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/ServletDemo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/1.htm&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/2.jsp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/3.php&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/4.ASPX&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 通过上面的配置，当我们想访问名称是ServletDemo1的Servlet，可以使用如下的几个地址去访问： http://localhost:8080/JavaWeb_Servlet_Study_20140531**/servlet/ServletDemo1** http://localhost:8080/JavaWeb_Servlet_Study_20140531**/1.htm** http://localhost:8080/JavaWeb_Servlet_Study_20140531**/2.jsp** http://localhost:8080/JavaWeb_Servlet_Study_20140531**/3.php** http://localhost:8080/JavaWeb_Servlet_Study_20140531**/4.ASPX** ServletDemo1被映射到了多个URL上。 5.2、Servlet访问URL使用*通配符映射 在Servlet映射到的URL中也可以使用*通配符，但是只能有两种固定的格式：一种格式是”.扩展名”，另一种格式是以正斜杠（/）开头并以”/“结尾。例如： 12345678&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;gacl.servlet.study.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; *可以匹配任意的字符，所以此时可以用任意的URL去访问ServletDemo1这个Servlet，如下图所示： 对于如下的一些映射关系： Servlet1 映射到 /abc/ Servlet2 映射到 / Servlet3 映射到 /abc Servlet4 映射到 .do问题： 当请求URL为“/abc/a.html”，“/abc/”和“/”都匹配，哪个servlet响应​ Servlet引擎将调用Servlet1。 当请求URL为“/abc”时，“/abc/”和“/abc”都匹配，哪个servlet响应​ Servlet引擎将调用Servlet3。 当请求URL为“/abc/a.do”时，“/abc/”和“.do”都匹配，哪个servlet响应​ Servlet引擎将调用Servlet1。 当请求URL为“/a.do”时，“/”和“.do”都匹配，哪个servlet响应​ Servlet引擎将调用Servlet2。 当请求URL为“/xxx/yyy/a.do”时，“/”和“.do”都匹配，哪个servlet响应​ Servlet引擎将调用Servlet2。 匹配的原则就是”谁长得更像就找谁” 5.3、Servlet与普通Java类的区别 Servlet是一个供其他Java程序（Servlet引擎）调用的Java类，它不能独立运行，它的运行完全由Servlet引擎来控制和调度。 针对客户端的多次Servlet请求，通常情况下，服务器只会创建一个Servlet实例对象，也就是说Servlet实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至web容器退出，servlet实例对象才会销毁。 在Servlet的整个生命周期内，Servlet的init方法只被调用一次。而对一个Servlet的每次访问请求都导致Servlet引擎调用一次servlet的service方法。对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。 如果在元素中配置了一个元素，那么WEB应用程序在启动时，就会装载并创建Servlet的实例对象、以及调用Servlet实例对象的init()方法。​ 举例：​ ​ invoker​ ​ org.apache.catalina.servlets.InvokerServlet​ ​ 1​ 用途：为web应用写一个InitServlet，这个servlet配置为启动时装载，为整个web应用创建必要的数据库表和数据。 5.4、缺省Servlet 如果某个Servlet的映射路径仅仅为一个正斜杠（/），那么这个Servlet就成为当前Web应用程序的缺省Servlet。 凡是在web.xml文件中找不到匹配的元素的URL，它们的访问请求都将交给缺省Servlet处理，也就是说，缺省Servlet用于处理所有其他Servlet都不处理的访问请求。 例如： 1234567891011&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo2&lt;/servlet-name&gt; &lt;servlet-class&gt;gacl.servlet.study.ServletDemo2&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 将ServletDemo2配置成缺省Servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo2&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 当访问不存在的Servlet时，就使用配置的默认Servlet进行处理，如下图所示： 在\conf\web.xml文件中，注册了一个名称为org.apache.catalina.servlets.DefaultServlet的Servlet，并将这个Servlet设置为了缺省Servlet。 12345678910111213141516171819 &lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- The mapping for the default servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 当访问Tomcat服务器中的某个静态HTML文件和图片时，实际上是在访问这个缺省Servlet。 5.5、Servlet的线程安全问题 当多个客户端并发访问同一个Servlet时，web服务器会为每一个客户端的访问请求创建一个线程，并在这个线程上调用Servlet的service方法，因此service方法内如果访问了同一个资源的话，就有可能引发线程安全问题。例如下面的代码： 不存在线程安全问题的代码： 12345678910111213141516171819202122232425262728293031323334 package gacl.servlet.study; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ServletDemo3 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * 当多线程并发访问这个方法里面的代码时，会存在线程安全问题吗 * i变量被多个线程并发访问，但是没有线程安全问题，因为i是doGet方法里面的局部变量， * 当有多个线程并发访问doGet方法时，每一个线程里面都有自己的i变量， * 各个线程操作的都是自己的i变量，所以不存在线程安全问题 * 多线程并发访问某一个方法的时候，如果在方法内部定义了一些资源(变量，集合等) * 那么每一个线程都有这些东西，所以就不存在线程安全问题了 */ int i=1; i++; response.getWriter().write(i); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 存在线程安全问题的代码： 123456789101112131415161718192021222324252627282930package gacl.servlet.study; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ServletDemo3 extends HttpServlet &#123; int i=1; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; i++; try &#123; Thread.sleep(1000*4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; response.getWriter().write(i+""); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 把i定义成全局变量，当多个线程并发访问变量i时，就会存在线程安全问题了，如下图所示：同时开启两个浏览器模拟并发访问同一个Servlet，本来正常来说，第一个浏览器应该看到2，而第二个浏览器应该看到3的，结果两个浏览器都看到了3，这就不正常。 线程安全问题只存在多个线程并发操作同一个资源的情况下，所以在编写Servlet的时候，如果并发访问某一个资源(变量，集合等)，就会存在线程安全问题，那么该如何解决这个问题呢？ 先看看下面的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041 package gacl.servlet.study; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ServletDemo3 extends HttpServlet &#123; int i=1; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * 加了synchronized后，并发访问i时就不存在线程安全问题了， * 为什么加了synchronized后就没有线程安全问题了呢？ * 假如现在有一个线程访问Servlet对象，那么它就先拿到了Servlet对象的那把锁 * 等到它执行完之后才会把锁还给Servlet对象，由于是它先拿到了Servlet对象的那把锁， * 所以当有别的线程来访问这个Servlet对象时，由于锁已经被之前的线程拿走了，后面的线程只能排队等候了 * */ synchronized (this) &#123;//在java中，每一个对象都有一把锁，这里的this指的就是Servlet对象 i++; try &#123; Thread.sleep(1000*4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; response.getWriter().write(i+""); &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 现在这种做法是给Servlet对象加了一把锁，保证任何时候都只有一个线程在访问该Servlet对象里面的资源，这样就不存在线程安全问题了，如下图所示： 这种做法虽然解决了线程安全问题，但是编写Servlet却万万不能用这种方式处理线程安全问题，假如有9999个人同时访问这个Servlet，那么这9999个人必须按先后顺序排队轮流访问。 针对Servlet的线程安全问题，Sun公司是提供有解决方案的：让Servlet去实现一个SingleThreadModel接口，如果某个Servlet实现了SingleThreadModel接口，那么Servlet引擎将以单线程模式来调用其service方法。 查看Sevlet的API可以看到，SingleThreadModel接口中没有定义任何方法和常量，在Java中，把没有定义任何方法和常量的接口称之为标记接口，经常看到的一个最典型的标记接口就是”Serializable“，这个接口也是没有定义任何方法和常量的，标记接口在Java中有什么用呢？主要作用就是给某个对象打上一个标志，告诉JVM，这个对象可以做什么，比如实现了”Serializable“接口的类的对象就可以被序列化，还有一个”Cloneable”接口，这个也是一个标记接口，在默认情况下，Java中的对象是不允许被克隆的，就像现实生活中的人一样，不允许克隆，但是只要实现了”Cloneable”接口，那么对象就可以被克隆了。 让Servlet实现了SingleThreadModel接口，只要在Servlet类的定义中增加实现SingleThreadModel接口的声明即可。 对于实现了SingleThreadModel接口的Servlet，Servlet引擎仍然支持对该Servlet的多线程并发访问，其采用的方式是产生多个Servlet实例对象，并发的每个线程分别调用一个独立的Servlet实例对象。 实现SingleThreadModel接口并不能真正解决Servlet的线程安全问题，因为Servlet引擎会创建多个Servlet实例对象，而真正意义上解决多线程安全问题是指一个Servlet实例对象被多个线程同时调用的问题。事实上，在Servlet API 2.4中，已经将SingleThreadModel标记为Deprecated（过时的）。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(四)--Http协议]]></title>
    <url>%2F2017%2F06%2F28%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%9B%9B-Http%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[[TOC] 一、什么是HTTP协议 HTTP是hypertext transfer protocol（超文本传输协议）的简写，它是TCP/IP协议的一个应用层协议，用于定义WEB浏览器与WEB服务器之间交换数据的过程。客户端连上web服务器后，若想获得web服务器中的某个web资源，需遵守一定的通讯格式，HTTP协议用于定义客户端与web服务器通迅的格式。 二、HTTP协议的版本 HTTP协议的版本：HTTP/1.0、HTTP/1.1 三、HTTP1.0和HTTP1.1的区别 在HTTP1.0协议中，客户端与web服务器建立连接后，只能获得一个web资源。 在HTTP1.1协议，允许客户端与web服务器建立连接后，在一个连接上获取多个web资源。 四、HTTP请求4.1、HTTP请求包括的内容 客户端连上服务器后，向服务器请求某个web资源，称之为客户端向服务器发送了一个HTTP请求。 一个完整的HTTP请求包括如下内容：一个请求行、若干消息头、以及实体内容范例： 4.2、HTTP请求的细节——请求行 请求行中的GET称之为请求方式，请求方式有：POST、GET、HEAD、OPTIONS、DELETE、TRACE、PUT，常用的有： GET、 POST 用户如果没有设置，默认情况下浏览器向服务器发送的都是get请求，例如在浏览器直接输地址访问，点超链接访问等都是get，用户如想把请求方式改为post，可通过更改表单的提交方式实现。 不管POST或GET，都用于向服务器请求某个WEB资源，这两种方式的区别主要表现在数据传递上：如果请求方式为GET方式，则可以在请求的URL地址后以?的形式带上交给服务器的数据，多个数据之间以&amp;进行分隔，例如：GET /mail/1.html?name=abc&amp;password=xyz HTTP/1.1 GET方式的特点：在URL地址后附带的参数是有限制的，其数据容量通常不能超过1K。 如果请求方式为POST方式，则可以在请求的实体内容中向服务器发送数据，Post方式的特点：传送的数据量无限制。 4.3、HTTP请求的细节——消息头 HTTP请求中的常用消息头 accept:浏览器通过这个头告诉服务器，它所支持的数据类型 Accept-Charset: 浏览器通过这个头告诉服务器，它支持哪种字符集 Accept-Encoding：浏览器通过这个头告诉服务器，支持的压缩格式 Accept-Language：浏览器通过这个头告诉服务器，它的语言环境 Host：浏览器通过这个头告诉服务器，想访问哪台主机 If-Modified-Since: 浏览器通过这个头告诉服务器，缓存数据的时间 Referer：浏览器通过这个头告诉服务器，客户机是哪个页面来的 防盗链 Connection：浏览器通过这个头告诉服务器，请求完后是断开链接还是何持链接 例如： 12345678Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*Referer: http://localhost:8080/JavaWebDemoProject/Web/2.jspAccept-Language: zh-CNUser-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; InfoPath.3)Accept-Encoding: gzip, deflateHost: localhost:8080Connection: Keep-Alive 五、HTTP响应5.1、HTTP响应包括的内容 一个HTTP响应代表服务器向客户端回送的数据，它包括： 一个状态行、若干消息头、以及实体内容 。 范例： 1234567891011121314 HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Content-Type: text/html;charset=ISO-8859-1 Content-Length: 105 Date: Tue, 27 May 2014 16:23:28 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello World JSP&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello World! &lt;/body&gt;&lt;/html&gt; 5.2、HTTP响应的细节——状态行 状态行格式： HTTP版本号 状态码 原因叙述​ 举例：HTTP/1.1 200 OK 状态码用于表示服务器对请求的处理结果，它是一个三位的十进制数。响应状态码分为5类，如下所示： 5.3、HTTP响应细节——常用响应头 HTTP响应中的常用响应头(消息头) Location: 服务器通过这个头，来告诉浏览器跳到哪里 Server：服务器通过这个头，告诉浏览器服务器的型号 Content-Encoding：服务器通过这个头，告诉浏览器，数据的压缩格式 Content-Length: 服务器通过这个头，告诉浏览器回送数据的长度 Content-Language: 服务器通过这个头，告诉浏览器语言环境 Content-Type：服务器通过这个头，告诉浏览器回送数据的类型 Refresh：服务器通过这个头，告诉浏览器定时刷新 Content-Disposition: 服务器通过这个头，告诉浏览器以下载方式打数据 Transfer-Encoding：服务器通过这个头，告诉浏览器数据是以分块方式回送的 Expires: -1 控制浏览器不要缓存 Cache-Control: no-cache Pragma: no-cache 六、在服务端设置响应头来控制客户端浏览器###6.1、设置Location响应头，实现请求重定向 123456789101112131415161718192021222324252627package org.wuqinghua.java.ch01;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/27. * 设置Location响应头，实现请求重定向 */public class ServletDemo01 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setStatus(302);//设置服务器的响应状态码 /** *设置响应头，服务器通过Location这个头，来告诉浏览器跳到哪里，这就是所谓的请求的重定向 */ resp.setHeader("Location","/JavaWeb_HttpProtocol_Study_20140528/1.jsp"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 当在浏览器中使用URL地址”http://localhost:8080/JavaWeb_HttpProtocol_Study_20140528/servlet/ServletDemo01&quot;访问ServletDemo01时，就可以看到服务器作出响应后发送到浏览器的状态码和响应头信息，如下图所示： 服务器返回一个302状态码告诉浏览器，你要的资源我没有，但是我通过Location响应头告诉你哪里有，而浏览器解析响应头Location后知道要跳转到/JavaWeb_HttpProtocol_Study_20140528/1.jsp页面，所以就会自动跳转到1.jsp，如下图所示： 6.2、设置Content-Encoding响应头，告诉浏览器数据的压缩格式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package org.wuqinghua.java.ch01;import com.sun.xml.internal.messaging.saaj.util.ByteOutputStream;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.zip.GZIPOutputStream;/** * Created by wuqinghua on 17/6/29. * 这个程序主要两个知识点 * 1.使用GZIPOutputStream流来压缩数据 * 2.通过响应头Content-Encoding来告诉浏览器，服务器端发送的数据压缩格式 */public class ServletDemo02 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String data = "abcdabcdabcdabcdabcdabcdab" + "cdabcdabcdabcdabcdabcdabcdabcdabc" + "dabcdabcdabcdabcdabcdabcdabcdabc" + "dabcdabcdabcdabcdabcdabcdabcdabcdab" + "cdabcdabcdabcdabcdabcdabcdabcdabcdab" + "cdabcdabcdabcdabcdabcdabcdabcdabcdab" + "cdabcdabcdabcdabcdabcdabcdabcdabcdab" + "cdabcdabcdabcdabcdabcdabcdabcdabcdabcd"; System.out.println("原始数据大小:"+data.getBytes().length); ByteOutputStream bout = new ByteOutputStream(); GZIPOutputStream gout = new GZIPOutputStream(bout); gout.write(data.getBytes()); gout.close(); //获取压缩后的数据 byte[] g = bout.toByteArray(); resp.setHeader("Content-Encoding","gzip"); resp.setHeader("Content-Length",g.length+""); resp.getOutputStream().write(g); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 服务器发给浏览器的响应信息如下： 浏览器支持的压缩格式有： 6.3、设置Content-type响应头，指定回送数据类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546package org.wuqinghua.java.ch01;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;/** * Created by wuqinghua on 17/6/29. */public class ServletDemo03 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; /** * 浏览器能接收(Accept)的数据类型有: * application/x-ms-application, * image/jpeg, * application/xaml+xml, * image/gif, * image/jpeg, * application/x-ms-xbap, * application/vnd.ms-excel, * application/vnd.ms-powerpoint, * application/msword, */ resp.setHeader("Content-type", "image/jpeg");//使用content-type响应头指定发送给浏览器的数据类型为image/jpeg //读入图片 InputStream in = this.getServletContext().getResourceAsStream("/img/WP_20131005_002.jpg"); byte buffer[] = new byte[1024]; int len = -1; OutputStream out = resp.getOutputStream(); while ((len = in.read(buffer, 0, buffer.length)) != -1) &#123; out.write(buffer, 0, len); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 服务器发给浏览器的响应信息如下： ServletDemo03的运行结果如下图所示： 在浏览器中显示出了图片 6.4、设置refresh响应头，让浏览器定时刷新1234567891011121314151617181920212223242526272829303132package org.wuqinghua.java.ch01;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/29. */@WebServlet(name = "servletDemo04",urlPatterns = &#123;"/servletDemo04"&#125;)public class ServletDemo04 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; /** * 设置refresh响应头，让浏览器每隔3秒定时刷新 */// resp.setHeader("refresh","3"); /** * 设置refresh响应头，让浏览器3秒后跳转到http://www.baidu.com */ resp.setHeader("refresh", "3;url='http://www.baidu.com'"); resp.getWriter().write("gacl"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 6.5、设置content－disposition响应头，让浏览器下载 123456789101112131415161718192021222324252627282930313233343536package org.wuqinghua.java.ch01;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;/** * Created by wuqinghua on 17/6/29. */@WebServlet(name = "servletDemo05", urlPatterns = &#123;"/servletDemo05"&#125;)public class ServletDemo05 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; /** * 设置content－disposition响应头，让浏览器下载文件 */ resp.setHeader("content-disposition", "attachment;filename=xxx.jpg"); InputStream in = this.getServletContext().getResourceAsStream("/img/WP_20131005_002.jpg"); byte buffer[] = new byte[1024]; int len = -1; OutputStream out = resp.getOutputStream(); while ((len = in.read(buffer, 0, buffer.length)) != -1) &#123; out.write(buffer, 0, len); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 在浏览器中访问ServletDemo05就会弹出文件下载框，如下图所示：]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(三)——Tomcat服务器学习和使用(二)]]></title>
    <url>%2F2017%2F06%2F27%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B8%89-Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 一、打包JavaWeb应用 在Java中，使用”jar”命令来对将JavaWeb应用打包成一个War包，jar命令的用法如下： 范例：将JavaWebDemoProject这个JavaWeb应用打包成war包 执行完之后，就可以得到一个文件，平时开发完JavaWeb应用后，一般都会将JavaWeb应用打包成一个war包，然后将这个war包放到Tomcat服务器的webapps目录下，当Tomcat服务器启动时，就会自动将webapps目录下的war包解压。 比如现在将放到放到Tomcat服务器的webapps目录下 Tomcat服务器启动后会自动”Deploying web application”，将这个war文件解压缩，如下图所示： 二、Tomcat的体系结构 Tomcat服务器的启动是基于一个server.xml文件的，Tomcat启动的时候首先会启动一个Server，Server里面就会启动Service，Service里面就会启动多个”Connector(连接器)”，每一个连接器都在等待客户机的连接，当有用户使用浏览器去访问服务器上面的web资源时，首先是连接到Connector(连接器)，Connector(连接器)是不处理用户的请求的，而是将用户的请求交给一个Engine(引擎)去处理，Engine(引擎)接收到请求后就会解析用户想要访问的Host，然后将请求交给相应的Host，Host收到请求后就会解析出用户想要访问这个Host下面的哪一个Web应用,一个web应用对应一个Context。 1234567891011121314151617181920212223242526&lt;?xml version='1.0' encoding='utf-8'?&gt; &lt;Server port="8005" shutdown="SHUTDOWN"&gt; &lt;Service name="Catalina"&gt; &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; &lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11Protocol" maxThreads="150" SSLEnabled="true" scheme="https" secure="true" clientAuth="false" sslProtocol="TLS" keystoreFile="conf/.keystore" keystorePass="123456"/&gt; &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt; &lt;Engine name="Catalina" defaultHost="localhost"&gt; &lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log." suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;/Host&gt; &lt;Host name="www.gacl.cn" appBase="F:\JavaWebApps"&gt; &lt;Context path="" docBase="F:\JavaWebApps\JavaWebDemo1"/&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; 三、互联网上的加密原理 Tomcat服务器启动时候会启动多个Connector(连接器)，而Tomcat服务器的连接器又分为加密连接器和非加密连机器，比如： 这里访问的就是使用8080端口的那个连接器 123&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 这个Connector是一个没有加密的连接器，使用”http://localhost:8080/JavaWebDemoProject/Web/1.jsp&quot;去请求服务器上的web资源的这个过程中，我们的请求是不加密的，要是想以一种加密的方式来访问Tomcat服务器，那么就要在Tomcat里面配置一个加密的Connector。要配置一个加密连接器，首先应该把互联网上的加密原理弄清楚。 3.1、对称加密 采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。 需要对加密和解密使用相同密钥的加密算法。由于其速度快，对称性加密通常在消息发送方需要加密大量数据时使用。对称性加密也称为密钥加密。 所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。 加密的安全性不仅取决于加密算法本身，密钥管理的安全性更是重要。因为加密和解密都使用同一个密钥，如何把密钥安全地传递到解密者手上就成了必须要解决的问题。 常用的对称加密有：DES、IDEA、RC2、RC4、SKIPJACK、RC5、AES算法等 3.2、非对称加密 非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。另一方面，甲方可以使用乙方的公钥对机密信息进行签名后再发送给乙方；乙方再用自己的私匙对数据进行验签。 非对称加密工作原理 1.A要向B发送信息，A和B都要产生一对用于加密和解密的公钥和私钥。 2.A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。 3.A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。 4.A将这个消息发给B（已经用B的公钥加密消息）。 5.B收到这个消息后，B用自己的私钥解密A的消息。其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥 发送方使用接收方的公钥对数据加密，而接收方则使用自己的私钥解密，这样，信息就可以安全无误地到达目的地了，即使被第三方截获，由于没有相应的私钥，也无法进行解密。通过数字的手段保证加密过程是一个不可逆过程，即只有用私有密钥才能解密。 非对称性加密依然没有解决数据传输的安全性问题，比如A想向B发数据，B首先生成一对密钥(公钥和私钥)，然后将公钥发给A，A拿到B发给他的公钥有就可以使用公钥加密数据后发给B，然而在B公钥发送给A的这个过程中，很有可能会被第三方C截获，C截获到B的公钥后，也使用B的公钥加密数据，然后发给B，B接收到数据后就晕了，因为搞不清楚接收到的数据到底是A发的还是C发的，这是其中一个问题，另一个问题就是，C截获到B发的公钥后，C可以自己生成一对密钥(公钥和私钥)，然后发给A，A拿到公钥后就以为是B发给他的，然后就使用公钥加密数据发给B，发送给B的过程中被C截获下来，由于A是用C发给他的公钥加密数据的，而C有私钥，因此就可以解密A加密过后的内容了，而B接收到A发给他的数据后反而解不开了，因为数据是用C的公钥加密的，B没有C的私钥，所以就无法解密。所以，非对称性加密存在一个问题：A想向B发数据，A如何确定拿到的公钥一定是B发的呢？那么如何解决这个问题呢？只能靠一个第三方机构(CA机构，即证书授权中心(Certificate Authority )，或称证书授权机构)来担保。A想向B发数据，B首先将公钥发给CA机构，CA机构拿到B的公钥后跑到B的家里问：这是你发的公钥吗？B确认过后说是：没错，是我发的！那么此时CA机构就会为B的公钥做担保，生成一份数字证书给B，数字证书包含了CA的担保认证签名和B的公钥，B拿到CA的这份数字证书后，就发给A，A拿到数字证书后，看到上面有CA的签名，就可以确定当前拿到的公钥是B发的，那么就可以放心大胆地使用公钥加密数据，然后发给B了。 四、https连接器 明白了互联网上的加密原理之后，下面来看看浏览器与服务器交互时，浏览器想将数据加密后再发送给服务器，那么该怎么做呢？服务器首先要向浏览器出示一份数字证书，浏览器看到数字证书后，就可以使用数字证书里面的公钥加密数据，所以要想做浏览器和服务器的加密数据传输，那么首先得针对服务器生成一份数字证书。然后再配置一下服务器，让服务器收到浏览器的请求之后，会向浏览器出示它的数字证书。 4.1、生成Tomcat服务器的数字证书 SUN公司提供了制作证书的工具keytool， 在JDK 1.4以后的版本中都包含了这一工具，它的位置为\bin\keytool.exe 1keytool -genkey -alias tomcat -keyalg RSA 使用keytool生成一个名字为tomcat的证书，存放在.keystore这个密钥库中 命令执行完之后，操作系统的用户文件夹下面就会生成一个.keystore文件，如下图所示： 使用命令：keytool -list -keystore .keystore查看.keystore密钥库里面的所有证书 4.2、配置https连接器 将生成的.keystore密钥库文件拷贝到Tomcat服务器的conf目录下，如下图所示： 修改server.xml文件，配置https连接器，代码如下： 1234&lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11Protocol" maxThreads="150" SSLEnabled="true" scheme="https" secure="true" clientAuth="false" sslProtocol="TLS" keystoreFile="conf/.keystore" keystorePass="123456"/&gt; 在server.xml文件中配置了一个端口是8443的加密连接器，浏览器访问8443端口的连接器时，将会以加密的方式来访问web服务器，这个连接器收到浏览器的请求后，将会向浏览器出示一份数字证书，浏览器再用数字证书里面的公钥来加密数据，keystoreFile=”conf/.keystore” 用来指明密钥库文件的所在路径，服务器从密钥库中提取证书时需要密码，keystorePass=”123456”指明密钥库的访问密码。 使用”https://localhost:8443/&quot;访问8443的加密连接器 由于密钥库里面的证书是我们手工生成的，没有经过CA的认证，所以使用”https://localhost:8443/“ 访问8443的加密连接器，浏览器会出现”证书错误，导航已阻止”，浏览器认为当前要访问的这个主机是不安全的，不推荐继续访问，点击就可以继续访问了，如下图所示： 4.3、安装数字证书 为了让浏览器信任我们生成的数字证书，需要将数字证书安装到浏览器中，以IE8浏览器为例进行证书安装说明，安装步骤如下： 证书安装成功后，重启IE浏览器，使用”https://localhost:8443/&quot;访问8443的加密连接器，此时浏览器就不再提示证书错误了，如下图所示： 4.4、删除数字证书 以IE8为例进行说明，操作步骤如下：工具—–&gt;Internet选项 删除之后重启浏览器即可]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(二)--Tomcat服务器学习使用(一)]]></title>
    <url>%2F2017%2F06%2F27%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%BA%8C-Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[[TOC] 一、Tomcat服务器端口的配置 Tomcat的所有配置都放在conf文件夹之中，里面的server.xml文件是配置的核心文件。 如果想修改Tomcat服务器的启动端口，则可以在server.xml配置文件中的Connector节点进行的端口修改 例如：将Tomcat服务器的启动端口由默认的8080改成8081端口 Tomcat服务器启动端口默认配置 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 将Tomcat服务器启动端口修改成8081端口 123&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 这样就把原来默认Tomcat默认的的8080端口改成了8081端口了，需要注意的是，一旦服务器中的*.xml文件改变了，则Tomcat服务器就必须重新启动，重新启动之后将重新读取新的配置信息。因为已经在server.xml文件中将Tomcat的启动端口修改成了8081，所以Tomcat服务器启动时就以8081端口启动了，如下图所示： 访问Tomcat服务器也必须以新的访问端口去访问：http://localhost:8081/，如下图所示： 二、Tomcat服务器虚拟目录的映射方式 Web应用开发好后，若想供外界访问，需要把web应用所在目录交给web服务器管理，这个过程称之为虚似目录的映射。那么在Tomcat服务器中，如何进行虚拟目录的映射呢？总共有如下的几种方式： 2.1、虚拟目录的映射方式一：在server.xml文件的host元素中配置找到server.xml文件的host元素，如下图所示： 在这对标签加上即可将在F盘下的JavaWebDemoProject这个JavaWeb应用映射到JavaWebApp这个虚拟目录上，JavaWebApp这个虚拟目录是由Tomcat服务器管理的，JavaWebApp是一个硬盘上不存在的目录，是我们自己随便写的一个目录，也就是虚拟的一个目录，所以称之为”虚拟目录”，代码如下： 123456&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;Context path=&quot;/JavaWebApp&quot; docBase=&quot;F:\JavaWebDemoProject&quot; /&gt; &lt;/Host&gt; 其中，Context表示上下文，代表的就是一个JavaWeb应用，Context元素有两个属性， Ⅰ.path：用来配置虚似目录，必须以”/“开头。 Ⅱ.docBase：配置此虚似目录对应着硬盘上的Web应用所在目录。 使用浏览器访问”/JavaWebApp”这个虚拟目录下的1.jsp这个web资源，访问结果如下： 1.jsp可以正常访问，这说明我们已经成功地将将在F盘下的JavaWebDemoProject这个JavaWeb应用映射到JavaWebApp这个虚拟目录上了，访问”/JavaWebApp/1.jsp”就相当于访问”F:\JavaWebDemoProject\1.jsp” 注意：在Tomcat6之后中，不再建议在server.xml文件中使用配置context元素的方式来添加虚拟目录的映射，因为每次修改server.xml文件后，Tomcat服务器就必须要重新启动后才能重新加载server.xml文件。在Tomcat服务器的文档http://localhost:8080/docs/config/context.html中有这样的说明： It is NOT recommended to place elements directly in the server.xml file. This is because it makes modifying the Context configuration more invasive since the main conf/server.xml file cannot be reloaded without restarting Tomcat. Individual Context elements may be explicitly defined: In an individual file at /META-INF/context.xml inside the application files. Optionally (based on the Host’s copyXML attribute) this may be copied to $CATALINA_BASE/conf/[enginename]/[hostname]/ and renamed to application’s base file name plus a “.xml” extension. In individual files (with a “.xml” extension) in the $CATALINA_BASE/conf/[enginename]/[hostname]/ directory. The context path and version will be derived from the base name of the file (the file name less the .xml extension). This file will always take precedence over any context.xml file packaged in the web application’s META-INF directory. Inside a Host element in the main conf/server.xml. 2.2、虚拟目录的映射方式二：让tomcat服务器自动映射 tomcat服务器会自动管理webapps目录下的所有web应用，并把它映射成虚似目录。换句话说，tomcat服务器webapps目录中的web应用，外界可以直接访问。 例如：把F盘下的JavaWebDemoProject这个JavaWeb应用直接copy到tomcat服务器webapps目录中，如下图所示： 此时Tomcat服务器就会自动为JavaWebDemoProject这个JavaWeb应用映射一个同名的虚拟目录”/JavaWebDemoProject”，然后就可以使用浏览器访问这个JavaWeb应用的资源了，如下图所示： 2.3、虚拟目录的映射方式三 参考Tomcat服务器文档： In individual files (with a “.xml” extension) in the $CATALINA_BASE/conf/[enginename]/[hostname]/ directory. The context path and version will be derived from the base name of the file (the file name less the .xml extension). This file will always take precedence over any context.xml file packaged in the web application’s META-INF directory. 意思就是：在tomcat服务器的\conf\Catalina\localhost目录下添加一个以xml作为扩展名的文件，xml文件的名字可以任意取，比如下面的aa.xml，注意这一句话”The context path and version will be derived from the base name of the file“，这一句话的意思翻译过来就是”context元素的path属性源自于是这个xml文件的名字”，上面提到过，Context元素的path属性是用来配置虚似目录的名称的，所以虚似目录的名称就是这个xml文件的名称。 $CATALINA_BASE指的就是tomcat服务器根目录，[enginename]指的是Tomcat服务器使用的引擎名称，Tomcat使用的引擎是Catalina 在aa.xml文件中添加Context元素映射JavaWeb应用，代码如下： 11 &lt;Context docBase=&quot;F:\JavaWebDemoProject&quot; /&gt; 注意：在Context元素中并没有指明path属性来设置虚拟目录的名称，那么”F:\JavaWebDemoProject”映射的虚拟目录名称是神马呢，就是当前正在编辑的这个xml文件的名称aa。 使用这种方式映射虚拟目录的最大好处是修改了配置文件后不用重启Tomcat服务器，比如将aa.xml修改成bb.xml，Tomcat服务器会自动Undeploying context [/aa]，然后自动信息: Deploying configuration descriptor D:\apache-tomcat-7.0.53\conf\Catalina\localhost\bb.xml 三、Tomcat服务器配置虚似主机3.1、配置虚拟主机 配置虚似主机就是配置一个网站。 在Tomcat服务器配置一个虚拟主机(网站)，需要修改conf文件夹下的server.xml这个配置文件，使用Host元素进行配置，打开server.xml，可以看到Tomcat服务器自带的一个名称为localhost的虚拟主机(网站)，如下图所示： 平时我们将开发好的JavaWeb应用放到webapps文件夹下，然后就可以使用”http://localhost:端口号/JavaWebAppName“的方式去访问了，其实访问的就是name是”localhost”的那台虚拟主机(Host)，这台虚拟主机管理webapps文件夹下的所有web应用。 例如：http://localhost:8080/JavaWebDemoProject/1.jsp，这个URL地址访问的就是名称是localhost的那台虚拟主机下的JavaWebDemoProject这个应用里面的1.jsp这个web资源。 我们可以使用如下的方式配置一个虚拟主机，例如： 123&lt;Host name=&quot;www.gacl.cn&quot; appBase=&quot;F:\JavaWebApps&quot;&gt; &lt;/Host&gt; 这里我们新配置一个虚拟主机，虚拟主机的name是”www.gacl.cn”，虚拟主机”www.gacl.cn”现在管理着JavaWebApps文件夹下的所有web应用，平时我们在互联网上使用域名”www.baidu.com”访问百度的网站时，其实就是在访问一个名称是”www.baidu.com”的虚拟主机，所以当我们要访问name是”www.gacl.cn”的这个虚拟主机时，就可以使用”域名(www.gacl.cn)”去访问，注意一下appBase=”F:\JavaWebApps”，这里的JavaWebApps文件夹代表的不是一个项目的根目录，而是一个存放了一个或者多个JavaWeb应用的文件夹，如下图所示： 就好像是Tomcat服务器的webapps文件夹一样，里面存放了很多的JavaWeb应用 3.2、windows系统中注册域名 配置的主机(网站)要想通过域名被外部访问，必须在DNS服务器或windows系统中注册访问网站时使用的域名，找到”C:\Windows\System32\drivers\etc“目录下的hosts文件，如下图所示： 编辑这个文件，将新添加的网站的域名和IP地址绑定在一起，这样我们就可以在浏览器中使用www.gacl.cn这个域名去访问name是www.gacl.cn那个虚拟主机里面管理的那些web应用了 使用浏览器通过域名”www.gacl.cn”访问”www.gacl.cn”这个虚拟主机下的JavaWebDemo1这个web应用下的1.jsp这个web资源，”www.gacl.cn”这个虚拟主机开放了一个8080端口，用户只能通过这个8080端口去访问JavaWebDemo1这个web应用下的1.jsp这个web资源 四、浏览器与服务器交互的过程4.1、浏览器与服务器交互图 当我们打开浏览器，在浏览器的地址栏中输入URL地址”http://www.gacl.cn:8080/JavaWebDemo1/1.jsp&quot;去访问服务器上的1.jsp这个web资源的过程中，浏览器和服务器都做了神马操作呢，我们是怎么在浏览器里面看到1.jsp这个web资源里面的内容的呢？ 浏览器和服务器做了以下几个操作： 1、浏览器根据主机名”www.gacl.cn”去操作系统的Hosts文件中查找主机名对应的IP地址。 2、浏览器如果在操作系统的Hosts文件中没有找到对应的IP地址，就去互联网上的DNS服务器上查找”www.gacl.cn”这台主机对应的IP地址。 3、浏览器查找到”www.gacl.cn”这台主机对应的IP地址后，就使用IP地址连接到Web服务器。 4、浏览器连接到web服务器后，就使用http协议向服务器发送请求，发送请求的过程中，浏览器会向Web服务器以Stream(流)的形式传输数据，告诉Web服务器要访问服务器里面的哪个Web应用下的Web资源，如下图所示： 这就是浏览器向Web服务器发请求时向服务器传输的数据，解释一下”GET /JavaWebDemo1/1.jsp HTTP/1.1“这里面的内容， GET：告诉Web服务器，浏览器是以GET的方式向服务器发请求。 /JavaWebDemo1/1.jsp：告诉Web服务器，浏览器要访问JavaWebDemo1应用里面的1.jsp这个Web资源。 HTTP/1.1：告诉Web服务器，浏览器是以HTTP协议请求的，使用的是1.1的版本。 5、浏览器做完上面4步工作后，就开始等待，等待Web服务器把自己想要访问的1.jsp这个Web资源传输给它。 6、服务器接收到浏览器传输的数据后，开始解析接收到的数据，服务器解析”GET /JavaWebDemo1/1.jsp HTTP/1.1“里面的内容时知道客户端浏览器要访问的是JavaWebDemo1应用里面的1.jsp这个Web资源，然后服务器就去读取1.jsp这个Web资源里面的内容，将读到的内容再以Stream(流)的形式传输给浏览器，如下图所示： 这个就是Web服务器传输给浏览器的数据。 7、浏览器拿到服务器传输给它的数据之后，就可以把数据展现给用户看了，如下图所示： 看到的这个”JavaWebDemo1”就是浏览器解析服务器发送回来的数据后的效果 服务器发送回来的数据： ;) 123456789101112131415 HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Content-Type: text/html;charset=ISO-8859-1 Content-Length: 102 Date: Mon, 19 May 2014 14:25:14 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;JavaWebDemo1&lt;/title&gt; &lt;/head&gt; &lt;body&gt; JavaWebDemo1 &lt;/body&gt;&lt;/html&gt; ;) 这就是浏览器和服务器的交互过程。 五、JavaWeb应用的组成结构 开发JavaWeb应用时，不同类型的文件有严格的存放规则，否则不仅可能会使web应用无法访问，还会导致web服务器启动报错 WebRoot →Web应用所在目录，一般情况下虚拟目录要配置到此文件夹当中。 ┝WEB-INF：此文件夹必须位于**WebRoot文件夹里面，而且必须以这样的形式去命名，字母都要大写。** ┝web.xml：配置文件，有格式要求，此文件必须以这样的形式去命名，并且必须放置到**WEB-INF文件夹中。** web.xml的格式可以直接从Tomcat中参考得到：找到Tomcat目录下的webapps\ROOT\WEB-INF这个目录下的web.xml文件，把这个文件拷贝到我们新建的WEB-INF文件夹中，并修改这个web.xml文件，把里面的注释删除掉，只留下如下所示的代码即可： web.xml : 123456789101112 &lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt; &lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; version=&quot;2.5&quot;&gt; &lt;display-name&gt;Welcome to Tomcat&lt;/display-name&gt; &lt;description&gt; Welcome to Tomcat &lt;/description&gt;&lt;/web-app&gt; 这就是web.xml这个文件的格式]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(一)--JavaWeb开发入门]]></title>
    <url>%2F2017%2F06%2F27%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B8%80-JavaWeb%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 一.基本概念1.1、WEB开发相关知识WEB，在英语中web即表示网页的意思，它用于表示Internet主机上供外界访问的资源。 Internet上供外界访问的Web资源分为： 静态web资源（如html 页面）：指web页面中供人们浏览的数据始终是不变。 动态web资源：指web页面中供人们浏览的数据是由程序产生的，不同时间点访问web页面看到的内容各不相同。 静态web资源开发技术：Html 常用动态web资源开发技术：JSP/Servlet、ASP、PHP等 在Java中，动态web资源开发技术统称为Javaweb。 1.2、WEB应用程序 WEB应用程序指供浏览器访问的程序，通常也简称为web应用。例如有a.html 、b.html…..多个web资源，这多个web资源用于对外提供服务，此时应把这多个web资源放在一个目录中，以组成一个web应用（或web应用程序） 一个web应用由多个静态web资源和动态web资源组成，如:html、css、js文件，Jsp文件、java程序、支持jar包、配置文件等等。 Web应用开发好后，若想供外界访问，需要把web应用所在目录交给web服务器管理，这个过程称之为虚似目录的映射 1.3、WEB发展史 WEB发展的两个阶段：静态、动态 1.4、静态WEB htm、html，这些是网页的后缀，如果现在在一个服务器上直接读取这些内容，那么意味着是把这些网页的内容通过网络服务器展现给用户。整个静态WEB操作的过程图如下： 在静态WEB程序中，客户端使用WEB浏览器（IE、FireFox等）经过网络(Network)连接到服务器上，使用HTTP协议发起一个请求（Request），告诉服务器我现在需要得到哪个页面，所有的请求交给WEB服务器，之后WEB服务器根据用户的需要，从文件系统（存放了所有静态页面的磁盘）取出内容。之后通过WEB服务器返回给客户端，客户端接收到内容之后经过浏览器渲染解析，得到显示的效果。 静态WEB中存在以下几个缺点： 1、Web页面中的内容无法动态更新，所有的用户每时每刻看见的内容和最终效果都是一样的。 为了可以让静态的WEB的显示更加好看，可以加入了JavaScript以完成一些页面上的显示特效，但是这些特效都是在客户端上借助于浏览器展现给用户的，所以在服务器上本身并没有任何的变化。 实现静态WEB客户端动态效果的手段： JavaScript VBScript 在实际的开发中JavaScript使用得最多。 2、静态WEB无法连接数据库，无法实现和用户的交互。 使用数据库保存数据是现在大多数系统的选择，因为数据库中可以方便地管理数据，增删改查操作可以使用标准的SQL语句完成。 1.5、动态WEB 所谓的动态不是指页面会动，主要的特性的是：“WEB的页面展示效果因时因人而变”，而且动态WEB具有交互性，WEB的页面的内容可以动态更新。整个动态WEB操作的过程图如下： 动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器（IE、FireFox等），通过网络(Network)连接到服务器上，使用HTTP协议发起请求（Request），现在的所有请求都先经过一个WEB Server Plugin（服务器插件）来处理，此插件用于区分是请求的是静态资源(.htm或者是.htm)还是动态资源。 如果WEB Server Plugin发现客户端请求的是静态资源(.htm或者是.htm)，则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。 如果WEB Server Plugin发现客户端请求的是动态资源（.jsp、.asp/.aspx、.php），则先将请求转交给WEB Container(WEB容器)，在WEB Container中连接数据库，从数据库中取出数据等一系列操作后动态拼凑页面的展示内容，拼凑页面的展示内容后，把所有的展示内容交给WEB服务器，之后通过WEB服务器将内容发送回客户端浏览器进行解析执行。 1.6、动态WEB应用的实现手段 动态WEB现在的实现手段非常多，较为常见的有以下几种： Microsoft ASP、ASP.NET PHP JAVA Servlet/JSP 1、Microsoft ASP、ASP.NET 微软公司动态WEB开发是比较早的，而且最早在国内最流行的是ASP。ASP就是在HTML语言之中增加了VB脚本，但是标准的开发应用应该是使用ASP+COM，但是实际情况来看，在开发ASP的时候基本上都在一个页面中写上成百上千的代码，页面代码极其混乱。 ASP本身有开发平台的限制：Windows+IIS+SQL Server/Access，ASP只能运行在Windows操作系统上，ASP现在基本上已经淘汰，现在基本上都是使用ASP.NET进行开发，ASP.NET在性能有了很大的改善，而且开发迅速，但是依然受限于平台。ASP.NET中主要是使用C#语言。 2.PHP PHP开发速度很快，功能强大，跨平台(平台指的就是运行的操作系统)，而且代码也简单。 3.Servlet/JSP 这是SUN公司(SUN现在已经被Oracle公司收购)主推的B/S架构的实现语言，是基于JAVA语言发展起来的，因为JAVA语言足够简单，而且很干净。 Servlet/JSP技术的性能也是非常高的，不受平台的限制，各个平台基本上都可以使用。而且在运行中是使用多线程的处理方式，所以性能非常高。 SUN公司最早推出的WEB技术推出的是Servlet程序，Servlet程序本身使用的时候有一些问题，所有的程序是采用JAVA代码+HTML的方式编写的，即，要使用JAVA输出语句，一行一行地输出所有的HTML代码，之后，SUN公司受到了ASP的启发，发展出了JSP(Java Server Page)，JSP某些代码的编写效果与ASP是非常相似的。这样可以很方便地使一些ASP程序员转向JSP的学习，加大市场的竞争力度。 二、WEB服务器2.1、WEB服务器简介 1、Web服务器是指驻留于因特网上某种类型计算机的程序，是可以向发出请求的浏览器提供文档的程序。当Web浏览器（客户端）连到服务器上并请求文件时，服务器将处理该请求并将文件反馈到该浏览器上，附带的信息会告诉浏览器如何查看该文件（即文件类型）。 2、服务器是一种被动程序：只有当Internet上运行在其他计算机中的浏览器发出请求时，服务器才会响应。 2.2、常见的Web服务器介绍 1、WebLogic WebLogic是美国bea公司出品的一个application server。BEA WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。是目前应用最广泛的Web服务器，支持J2EE规范，而且不断的完善以适应新的开发要求，启动界面如图 2、WebSphere WebSphere Application Server 是一种功能完善、开放的Web应用程序服务器，是IBM公司电子商务计划的核心部分，它是基于 Java 的应用环境，用于建立、部署和管理 Internet 和 Intranet Web 应用程序。这一整套产品进行了扩展，以适应 Web应用程序服务器的需要，范围从简单到高级直到企业级。启动界面如图： 3、Tomcat TomcatTomcat是一个实现了JAVA EE标准的最小的WEB服务器，是Apache 软件基金会的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。因为Tomcat 技术先进、性能稳定，而且开源免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。学习JavaWeb开发一般都使用Tomcat服务器，该服务器支持全部JSP以及Servlet规范，启动界面如图： 4、IIS Microsoft的Web服务器产品为Internet Information Services （IIS），IIS 是允许在公共Intranet或Internet上发布信息的Web服务器。ⅡS是目前最流行的Web服务器产品之一，很多著名的网站都是建立在ⅡS的平 台上。IIS提供了一个图形界面的管理工具，称为Internet信息服务管理器，可用于监视配置和控制Internet服务。 IIS是一种Web服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供ISAPI(Intranet Server API）作为扩展Web服务器功能的编程接口；同时，它还提供一个Internet数据库连接器，可以实现对数据库的查询和更新。 学习web开发，需要先安装一台web服务器，然后再在web服务器中开发相应的web资源，供用户使用浏览器访问。 三、搭建JavaWeb应用开发环境——Tomcat服务器3.1、疑问：学习web开发，为什么必须要先装一个WEB服务器？ 在本地计算机上随便创建一个web页面，用户是无法访问到的，但是如果启动tomcat服务器，把web页面放在tomcat服务器中，用户就可以访问了。这说明什么问题？ 1、不管什么web资源，想被远程计算机访问，都必须有一个与之对应的网络通信程序，当用户来访问时，这个网络通信程序读取web资源数据，并把数据发送给来访者。 2、WEB服务器就是这样一个程序，它用于完成底层网络通迅。使用这些服务器，We应用的开发者只需要关注web资源怎么编写，而不需要关心资源如何发送到客户端手中，从而极大的减轻了开发者的开发工作量。 3.2、下载和安装Tomcat服务器 Tomcat官方站点：http://jakarta.apache.org 下载Tomcat安装程序包：http://tomcat.apache.org/ 点击【Download】跳转到如下图所示的下载页面 tar.gz文件是Linux操作系统下的安装版本 exe文件是Windows系统下的安装版本 zip文件是Windows系统下的压缩版本 下载完成后，得到的是一个压缩包，将压缩包解压就可以完成Tomcat服务器的安装 将压缩包解压后，得到的就是如下图所示的文件夹，这样就完成了Tomcat服务器的安装。 3.3、启动和测试Tomcat服务器 启动Tomcat服务器 双击 bin 目录下的 startup.bat 文件启动Tomcat服务器 测试Tomcat服务器 打开浏览器，输入http://localhost:8080/，能显示如下界面代表安装成功。 3.4、Tomcat启动常见问题 导致Tomcat服务器无法正常启动的原因一般来说就是如下的两个： 1、JAVA_HOME环境变量设置问题 要想双击bin目录下的startup.bat文件启动Tomcat服务器，首先要做的就是在windows中设置JAVA_HOME环境变量，因为Tomcat服务器的启动需要用到这个JAVA_HOME环境变量，如果windows中不存在JAVA_HOME环境变量，则Tomcat服务器是无法启动的。 在Window中配置JAVA_HOME变量 操作步骤(win7系统)：计算机→右键“属性”→高级系统设置→高级→环境变量，如下图所示： 点击系统变量下面的“【新建】”，弹出一个新建系统变量对话框，首先在变量名写上JAVA_HOME，顾名思义，JAVA_HOME的含义就是JDK的安装路径，，然后在变量值写JDK的安装路径，如这里设置的变量值是”D:\Program Files (x86)\Java\jdk1.7.0“，设置好变量值之后，点击【确定】按钮，JAVA_HOME环境变量就设置完成，如下图所示：系统变量中多了一个”JAVA_HOME”变量。 正常来说，学习Java开发的第一步就是配置Path环境变量，比较好的配置方式是先配置JAVA_HOME环境变量，然后在Path变量中使用”%JAVA_HOME%“引用JAVA_HOME变量的值。 所以这个JAVA_HOME环境变量在Window中一般都是已经配置好了的，如果忘记配置JAVA_HOME环境变量，那么可以使用上述的方式配置 2、端口占用问题 因为Tomcat服务器启动时是需要默认是使用8080端口的，如果这个8080端口被别的应用程序占用了，那么Tomcat服务器就无法正常启动，看到的现象就是”Tomcat服务器启动界面会打印出异常错误信息，然后就自动关闭了”，如下图所示： 由于这个窗口从启动到关闭的时间非常短，我们很难通过这个窗口看到Tomcat启动时的报错异常信息，因此我们一般只能通过Tomcat服务器的记录的log(日志)信息去查看Tomcat服务器的运行情况。 在Tomcat服务器的根目录下有一个logs文件夹， logs文件夹存放Tomcat 的日志文件，打开logs文件夹，可以看到里面的log文件，其中有一个以”catalina.yyyy-MM-dd.log“形式命名的log文件，例如”catalina.2014-05-17.log”日志文件就是记录Tomcat服务器2014-05-17这一天的运行情况。 打开catalina.2014-05-17.log文件，看看里面的日志记录信息， 日志信息里面清楚的记录了Tomcat服务器的运行情况，如果因为8080端口被占用而无法正常启动，就会记录如上图所示的异常信息，通过查看异常信息，我们就可知道Tomcat服务器为什么不能够正常启动了！ 总结：当Tomcat服务器无法正常启动时，首先检查是否配置了JAVA_HOME环境变量，然后再检查Tomcat服务器启动时的端口是否被别的应用程序占用了。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP获取绝对路径]]></title>
    <url>%2F2017%2F06%2F27%2FJSP%E8%8E%B7%E5%8F%96%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[在JavaWeb开发中，常使用绝对路径的方式来引入JavaScript和CSS文件，这样可以避免因为目录变动导致引入文件找不到的情况，常用的做法如下： 一、使用${pageContext.request.contextPath} 代码” ${pageContext.request.contextPath}”的作用是取出部署的应用程序名，这样不管如何部署，所用路径都是正确的。 例如： 123456&lt;!--使用绝对路径的方式引入CSS文件--&gt;&lt;link rel="stylesheet" href="$&#123;pageContext.request.contextPath&#125;/themes/default/css/ueditor.css" type="text/css"/&gt;&lt;!--使用绝对路径的方式引入JavaScript脚本--&gt;&lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath&#125;/ueditor1_3_6-gbk-jsp/ueditor.config.js"&gt;&lt;/script&gt; 使用&lt;%=request.getContextPath()%&gt;和使用${pageContext.request.contextPath}达到同样的效果 12&lt;script type="text/javascript" src="&lt;%=request.getContextPath()%&gt;/ueditor1_3_6-gbk-jsp/ueditor.all.js"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC将根目录文件夹的权限赋给用户]]></title>
    <url>%2F2017%2F06%2F26%2FMAC%E5%B0%86%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%9D%83%E9%99%90%E8%B5%8B%E7%BB%99%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[[TOC] 1、sudu -i进入root模式（需输入密码）2、chown -R 用户名 /文件夹名1234sudo -iPassword:shuaigedeMacBook-Pro:~ root# mkdir /interestingchown -R shuaige /interesting 用PHP写socket通讯时需要用到端口，有的时候关闭了服务器，但是端口还是占用，解决的方法是kill掉占用该端口的进程 命令行 lsof -i:9000 这里9000是我要释放的端口号 可以看到，该端口被id围11475的进程所占用，这个时候直接在命令行输入 kill 11475 该进程就中止了，端口成功过释放出来]]></content>
      <categories>
        <category>Util</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http常见的请求头和响应头]]></title>
    <url>%2F2017%2F06%2F26%2Fhttp%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[[TOC] 1.常见的HTTP请求头部 请求头部 说明 Accept-Charset 用于指定客户端接受的字符集 Accept-Encoding 用于指定可接受的内容编码，如Accept-Encoding:gzip,deflate Accept-Language 用于指定一种自然语言，如Accept-Language:zh-cn User-Agent 客户端将它的操作系统、浏览器和其他属性告诉服务器 Host 用于指定被请求资源的Internet主机和端口号,如Host:www.taobao.com Connection 当前连接是否保持，如Connection:Keep-Alive 2.常见的HTTP响应头 响应头部 说明 Server 使用的服务器名称，如Server:Apache/1.3.6(Unix) Content-Type 用来指明发送给接收者的实体正文的媒体类型，如Content-Type:text/html;charset=GBK Content-Encoding 与请求报头Accept-Encoding对应，告诉浏览器服务端采用什么压缩编码 Content-Langeage 描述资源所使用的自然语言 Content-Length 指明实体正文的长度，用以字节方式存储的十进制数字表示 Keep-Alive 保持连接的时间，如Keep-Alive:timeout=5,max=120 3.常见的HTTP状态码 状态码 说明 200 客户端请求成功 302 临时跳转，跳转地址使用Location指定 400 客户端请求有语法错误，不能被服务器识别 403 服务器接受到请求，但是拒绝提供服务 404 请求资源不存在 500 服务器发生不可预期的错误]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dbUnit使用]]></title>
    <url>%2F2017%2F06%2F08%2FdbUnit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[TOC] ​ DbUnit(http://dbunit.sourceforge.net/ )是专门针对数据库测试框架Junit的一个扩展。本文介绍了使用DbUnit工具让我们在使用Junit测试的时候，不会对数据库造成破坏。本文将会简单的介绍使用dbUnit进行备份和恢复数据操作。 使用DbUnit的步骤:(Maven方式) 1.添加maven依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;org.dbunit&lt;/groupId&gt; &lt;artifactId&gt;dbunit&lt;/artifactId&gt; &lt;version&gt;2.4.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt; 2.使用DbUnit进行插入测试数据a.创建测试数据(提供数据配置文件dataset.xml,其中t_user为表名，属性为列名)123&lt;dataset&gt; &lt;t_user id="1" username="admin" password="123" nickname="admin_123"/&gt;&lt;/dataset&gt; b.创建DbUnit的连接信息(这个连接获取需要依赖项目的连接)1234567891011121314151617181920212223242526272829303132333435363738394041public class DbUtil &#123; private static final String url = "jdbc:mysql://127.0.0.1:3306/db_junit?useUnicode=true" + "&amp;characterEncoding=UTF-8"; private static final String username = "root"; private static final String password = "root"; public static Connection getConnection() throws SQLException &#123; Connection conn = DriverManager.getConnection(url, username, password); return conn; &#125; public static void close(Connection conn) &#123; try &#123; if (conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static void close(PreparedStatement ps) &#123; try &#123; if (ps != null) ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static void close(ResultSet rs) &#123; try &#123; if (rs != null) rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class TestDbUnit &#123; @Test public void testDbUnit() throws SQLException, DatabaseUnitException &#123; //1.创建dbunit的connection IDatabaseConnection conn = new DatabaseConnection(DbUtil.getConnection()); //2.获取配置的数据 IDataSet ds = new FlatXmlDataSet(new FlatXmlProducer(new InputSource(TestDbUnit.class .getResourceAsStream("/dataset.xml")))); //3.清空数据库,将测试数据添加进去 DatabaseOperation.CLEAN_INSERT.execute(conn,ds); &#125; //备份所有的数据 @Test public void testBackUpAllData() throws SQLException, DatabaseUnitException, IOException &#123; //1.获取dbunit的连接 IDatabaseConnection conn = new DatabaseConnection(DbUtil.getConnection()); //2.获取数据库中的所有的数据 IDataSet ds = conn.createDataSet(); //3.将dataset数据写入到一个文件中 FlatXmlDataSet.write(ds,new FileWriter("backUp.xml")); &#125; //备份部分表 @Test public void testBackUpSomeTable() throws SQLException, DatabaseUnitException, IOException &#123; IDatabaseConnection conn = new DatabaseConnection(DbUtil.getConnection()); //创建查询的dataset QueryDataSet queryDataSet = new QueryDataSet(conn); queryDataSet.addTable("t_user"); FlatXmlDataSet.write(queryDataSet,new FileWriter("backUp.xml")); &#125; //测试恢复 @Test public void testResume() throws SQLException, DatabaseUnitException &#123; IDatabaseConnection conn = new DatabaseConnection(DbUtil.getConnection()); IDataSet ds = new FlatXmlDataSet(new FlatXmlProducer(new InputSource("backUp.xml"))); DatabaseOperation.CLEAN_INSERT.execute(conn,ds); &#125;&#125; ​]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>dbUnit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown简介]]></title>
    <url>%2F2017%2F01%2F17%2FMarkdown%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[[TOC] Markdown简介 Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成各式丰富的HTML页面。–维基百科 图片1![描述](example.jpg) 笔记本1@(笔记本)［标签1，标签2，标签3］ 标题123标题一 标题二======= ----------## 标题二 ###### 标题六 列表121.有序列表 -无序列表 -[] 复选框2.有序列表 -无序列表 -[x] 复选框 引用12&gt; 这是引用的文字&gt; 引用内可以嵌套标题、列表等 代码1234这是一句行内代码｀var a = 1｀,以下是代码区块：&apos;&apos;&apos;rubyprint &apos;Hello world&apos;&apos;&apos;&apos; laTex公式12这是一句行内公式 $ y = x + 1 $,以下为整行公式：$$ a^2 + b^2 = c^2 $$ 表格123|Item | Value| Qty||:-------|--------:|:---:||Computer|1600 USD| 5|]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>