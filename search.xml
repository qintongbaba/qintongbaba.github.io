<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JAVA之IO--字符流(四)]]></title>
    <url>%2F2017%2F08%2F23%2FJAVA%E4%B9%8BIO-%E5%AD%97%E7%AC%A6%E6%B5%81-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[字符流处理文件字符流只能处理纯文本，全部为可见字符.步骤和使用字节流一致。(使用流Reader和Writer) 1.文件（纯文本）读取 123456789101112131415161718@Test public void readTest() throws IOException &#123; //1.创建文件关联 File src = new File("pom.xml"); //2.选择流 Reader reader = new FileReader(src); //3.操作 char[] chars = new char[1024]; @SuppressWarnings("unused") int len = 0; while((len=reader.read(chars, 0, 1024))!=-1) &#123; System.out.println(new String(chars)); &#125; //4.关闭流 reader.close(); &#125; 2.文件的写入 1234567891011121314151617181920212223@Test public void writerTest() throws IOException &#123; //1.写出的文件 File dest = new File("pom.txt"); //2.选择流 Writer writer = new FileWriter(dest); //3.操作 String mes="锄禾日当午\r\n汗滴禾下土\r\n谁知盘中餐\r\n粒粒皆辛苦"; char[] cbuf = mes.toCharArray(); writer.write(cbuf, 0, cbuf.length); //写入还可以使用一下两种方式 //writer.writer(mes); //writer.append(mes); writer.flush(); //4.关闭 writer.close(); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA之IO--字节流(三)]]></title>
    <url>%2F2017%2F08%2F21%2FJAVA%E4%B9%8BIO-%E5%AD%97%E8%8A%82%E6%B5%81-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[使用字节流进行文件操作1、读取文件 一般步骤：1）建立连接 File—&gt;2）选择流 InputStream —&gt;3)操作 byte[]+read—&gt;4)关闭 12345678910111213141516171819202122232425262728293031@Test public void readFile() &#123; // 1.建立连接 File File pom = new File("pom.xml"); // 2.选择流 InputStream in = null; try &#123; in = new FileInputStream(pom); // 3.操作 byte[] bytes = new byte[1024]; // 每次读取1024个字节 int len = 0;// 接收读取的大小 while ((len = in.read(bytes, 0, 1024)) != -1) &#123; System.out.println(new String(bytes, 0, len)); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); System.out.println("文件不存在！"); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println("读取文件失败!"); &#125; finally &#123; //4.释放资源 try &#123; if (null != in) &#123; in.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 2、写出文件一般步骤：1）建立连接 File—&gt;2）选择流 OutputStream —&gt;3)write+flush—&gt;4)关闭 12345678910111213141516171819202122232425262728293031@Test public void writeFile() &#123; // 1.建立联系 File File file = new File("test.txt"); // 2.选择流 OutputStream out = null; try &#123; out = new FileOutputStream(file, true);// 表示写文件是追加还是覆盖 // 3.操作 String msg = "hello world!\n"; byte[] data = msg.getBytes(); out.write(data, 0, data.length); out.flush();// 强制刷新出去 &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); System.out.println("文件找不到!"); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println("文件写出失败！"); &#125;finally &#123; try &#123; if (out != null) &#123; out.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println("关闭失败!"); &#125; &#125; &#125; 3、文件的拷贝就是将文件的读取和文件的写出就是文件的拷贝。 12345678910111213141516171819202122232425262728293031323334353637383940414243@Test public void copyFile() &#123; // 1.建立联系 File inFile = new File("pom.xml"); File outFile = new File("test.txt"); //只能拷贝文件 if(inFile.isFile)&#123; return; &#125; // 2.选择流 InputStream in = null; OutputStream out = null; try &#123; in = new FileInputStream(inFile); out = new FileOutputStream(outFile); // 3.操作 byte[] bytes = new byte[1024]; int len = 0; while ((len = in.read(bytes, 0, 1024)) != -1) &#123; out.write(bytes, 0, len); &#125; out.flush();// 强制刷新 &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (out != null) &#123; out.close(); &#125; if (in != null) &#123; in.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 4、文件夹的拷贝1234567891011121314151617181920212223242526272829303132@Test public void copyFile2() &#123; File inFile = new File("src"); File outFile= new File("outSrc"); try &#123; copy(inFile,outFile); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private void copy(File inFile, File outFile) throws IOException &#123; File nowOut = new File(outFile,inFile.getName()); //需要拷贝的文件名称 if(inFile.isDirectory()) &#123; nowOut.mkdirs(); //如果是目录就创建目录 for (File subFile : inFile.listFiles()) &#123; copy(subFile,nowOut); //递归调用 &#125; &#125;else &#123; //如果是文件就进行拷贝 InputStream in = new FileInputStream(inFile); OutputStream out = new FileOutputStream(nowOut); byte[] bytes = new byte[1024]; int len = 0; while((len=in.read(bytes, 0, 1024))!=-1) &#123; out.write(bytes, 0, len); &#125; out.flush(); out.close(); in.close(); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA之IO--流的原理(二)]]></title>
    <url>%2F2017%2F08%2F21%2FJAVA%E4%B9%8BIO-%E6%B5%81%E7%9A%84%E5%8E%9F%E7%90%86-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[一、概念​ 流：流动、流向（比如车流。。）从一端移动到另一段，那么就会出现源头和目的地，那么在代码中就是文件移动到代码获取网络上到程序等 。需要注意以程序为中心。 二、IO流的分类​ 1.流向:以程序为中心，输入流和输出流​ 2.数据：字节流：二进制，可以处理一切数据，比如文本、视频、音频等​ 字符流：文本文件，只能处理纯文本​ 3.功能：节点流：离源头比较近的，包裹源头​ 处理流：增强功能，提高效率 三、常用的一些流 ​ 1.字节流：​ 输入流：InputStream​ 输出流：OutputSteacm​ 2.字符流​ 输入流：Reader​ 输出流：Writer 操作流的一般步骤：(一般家为例)​ 1.选择需要搬家的的房子（关联房子） ——&gt;建立和文件的联系 2.选择搬家公司 ——&gt;选择对应的流​ 3.进行搬家 ——&gt;文件的读取｜写入​ 选择卡车 ——&gt;数组大小​ 运输​ 4.结束搬家 ——&gt;释放资源 过程为：​ 1)建立连接－－》2）选择合适的流－－》3）操作，选择数组的大小进行读取－－－》4）关闭流]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA之IO--FILE(一)]]></title>
    <url>%2F2017%2F08%2F21%2FJAVA%E4%B9%8BIO-FILE-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[File类​ 表示为文件和路径名的抽象表示，也就是系统中文件或文件夹在Java中表示形式，File不能直接操作文件，只能表示文件，如果需要操作文件，后面会使用到流。 1.File中的常量 pathSeparator:与系统有关的的路径分隔符 separator:与系统有关的名称分隔符12345@Test public void fileConstant() &#123; System.out.println(File.pathSeparator); //windows --&gt; ; linux --&gt; : System.out.println(File.separator); //windows \ linux / &#125; 2.绝对路径和相对路径​ 表示一个文件的位置信息，绝对路径表示从盘符开始表示其位置。绝对路径表示相对于一个位置，其位置的信息。 123456789101112/*** 比如在你的电脑上存在 d:/file/parent/test/test.txt**/@Test public void filePath() &#123; /**绝度路径**/ File file1 = new File("d:/file/parent/test"); /**相对路径**/ File file2 = new File(new File("d:/file/parent/test"),"text.txt"); File file3 = new File("abc.txt");//表示当前工程 &#125; 3.File的简单使用(常用的方法)1.文件名相关的操作getName():文件名称getPath():路径名，如果采用绝对路径那么返回的就是绝对路径，如果采用相对路径构建的File那么就是相对路径getAbsoluteFile():绝对路径对应的文件getAbsolutePath:绝对路径getParent():父目录,相对路径的父目录，可能为nullrenameTo(File newName);重命名 1234567891011@Test public void fileTest() &#123; //表示工程目录下的pom.xml File file = new File("pom.xml"); System.out.println("文件名称:"+file.getName()); System.out.println("绝对路径:"+file.getAbsolutePath()); System.out.println("路径:"+file.getPath()); //如果为绝度路径，返回绝对路径，否则相对路径 System.out.println("上级目录:"+file.getParent()); //相对路径返回null System.out.println("绝对文件:"+file.getAbsoluteFile()); System.out.println("绝对文件的上级目录:"+file.getAbsoluteFile().getParent()); //可以返回为上级目录 &#125; #####2.判断信息操作exists():是否存在canWrite():能否写入canRead()：能否进行读取isFile():判断是否为文件isDirectory():判断是否为文件夹isAbsolute():消除平台差异，windows是以盘符开头,其它以/ 12345678910@Test public void fileTest02() &#123; File file = new File("pom.xml"); System.out.println("文件是否存在:"+file.exists()); System.out.println("文件是否可读："+file.canRead()); System.out.println("文件是否可写："+file.canWrite()); System.out.println("是否为文件:"+file.isFile()); System.out.println("是否为文件夹:"+file.isDirectory()); System.out.println("是否为绝对路径构建："+file.isAbsolute()); &#125; #####3.长度length():文件的大小 #####4.创建和删除createNewFile():不存在创建新文件delete():删除文件static createTempFile(前缀3个字节，后缀默认.temp) 在默认的临时空间中创建临时文件static createTempFile(前缀3个字节，后缀默认.temp,目录) 在目录中创建临时文件deleteOnExit() 退出虚拟机删除，常用语删除临时文件 12345678910111213@Testpublic void fileTest03() throws IOException &#123; File file = new File("test.txt"); if(!file.exists()) &#123; file.createNewFile(); //文件不存在创建文件 &#125; file.delete();//删除文件 File fileTemp1 = File.createTempFile("abc", ".temp");//创建临时文件 File fileTemp2 = File.createTempFile("abc", ".temp", new File(".")); fileTemp1.deleteOnExit(); //退出时删除 fileTemp2.deleteOnExit();&#125; #####5.操作目录mkdir() 创建目录，但是父目录不存在不能创建mkdirs() 创建目录，父目录不存在也同时创建list() : 返回的为字符串数组，表示文件的字符串表示listFiles() :返回目录下的所有的字符串listFiles(FileFilter):进行过滤器过滤static listRoots(): 根目录1234567891011121314151617181920212223242526272829303132@Test public void fileTest04() throws IOException &#123; File file1 = new File("abc/ccc"); file1.mkdir();//创建目录，必须保证父路径存在 file1.mkdirs();//创建目录，父目录不存在，同时创建 //创建文件 for(int i = 0;i&lt;5;i++) &#123; File file = new File(file1,i+".txt"); if(!file.exists()) &#123; file.createNewFile(); &#125; &#125; String[] fileNames = file1.list();//返回目录中的文件字符串表示 System.out.println(Arrays.toString(fileNames)); File[] listFiles = file1.listFiles(); System.out.println(Arrays.toString(listFiles)); /**进行过滤器**/ File[] listFiles2 = file1.listFiles(new FileFilter() &#123; @Override public boolean accept(File pathname) &#123; return pathname.getName().endsWith("4.txt"); &#125; &#125;); System.out.println(Arrays.toString(listFiles2)); File[] listRoots = File.listRoots(); //获取跟目录 System.out.println(Arrays.toString(listRoots)); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM之运行时数据区-Runtime-Data-Area]]></title>
    <url>%2F2017%2F08%2F03%2FJVM%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-Runtime-Data-Area%2F</url>
    <content type="text"><![CDATA[Java虚拟机的自动内存管理机制1、Java内存区域与内存溢出异常​ Java虚拟机在执行Java程序的过程中会将其管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间，有的区域随着虚拟机进程启动而存在，有些区域依据用户线程启动和结束而建立和销毁。根据《Java虚拟机规范（第二版）》的规定，Java虚拟机所管理的内存包括以下几个运行时数据区域。 1、程序计数器​ 程序计数器(Program Counter Register)是一块较小的内存空间，它的作用可以看做为当前线程所执行字节码的行号指示器。在虚拟机的概念模型中（仅是概念模型，各种虚拟机可能会根据一些高效的方式实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。 ​ 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说为一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 ​ 如果线程正在执行的为一个Java方法，这个计数器纪录的是正在执行的虚拟机字节码指令地址；如果正在执行的是Native方法，这个计数器则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 2、Java虚拟机栈​ 与程序计数器一样，Java虚拟机栈（Java Virtual Machie Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 ​ 经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。其中所讲的“堆”在后面会专门的讲述，而所指的“栈”就是现在讲的虚拟机栈，或者虚拟机栈中的局部变量表部分。 ​ 局部变量表存放了编译期可知的各种基本数据类型（byte、short、int、long、double、float、char、boolean）、对象引用（reference类型，它不等同与对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的指针，也可能表示指向一个对象的句柄或者其它与此对象相关的位置）和returnAddress类型（指向一条字节码指令地址）。 ​ 其中64位长度的long和double类型的数据会占用两个局部变量的空间（slot），其余的数据类型只占用一个。局部表所需的内存在编译期间完成分配，当进入一个方法的时候，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 ​ 在Java虚拟机规范中，对这个区域规定了两种异常情况；如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分Java虚拟机都可以动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。 3、本地方法栈​ 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的， 其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到Native方法服务。虚拟机规范中本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由的实现它。甚至有些虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 4、Java堆​ 对于大多数引用来讲，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有的线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这点在Java虚拟机中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上渐渐变得不是那么“绝对”了。 ​ Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”（Garbage Collected Heap）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间，From Survivor空间、To Survivor空间等。如果从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过，无论如何划分，都与存放的内容无关，无论哪个区域，存放的都仍然是对象的实例，进一步的划分的目的是为了更好的回收内存，或者更快地分配内存。 ​ 根据Java虚拟机规范规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 5、方法区​ 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被Java虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范将方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做NonHeap（非堆），目的是与Java堆分开。 ​ 对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意将方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其它虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。即时是HotSpot虚拟机本身，根据官方路线图信息，现在也有放弃永久代并“搬家”至Native Memory来实现方法区的规划了。 ​ Java虚拟机规范对这个区域的限制非常的宽松，除了和Java堆一样不需要连续的内存和可以固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当的苛刻，但是这区域的回收确实比较有必要的。在Sun公司的BUG列表中，曾出现过若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收导致内存泄漏。 ​ 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 6、运行时常量池​ 运行时常量池（Runtime Constant Pool）是方法的一部分。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 ​ Java虚拟机对Class文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储那种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。 ​ 运行时常量池相对Class文件常量池的另一个重要的特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特征被开发人员利用得比较多的便是String类的intern（）方法。 ​ 既然运行时常量池是方法区的一部分，自然会受到方法区的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 7、直接内存​ 直接内存（Direct Memory）并不是虚拟机运行时数据区一部分，也不是Java虚拟机规范中定义的内存区域，但是这个内存也被频繁使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。 ​ 在JDK1.4中新加入NIO（New Input／Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I／O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 ​ 显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM及SWAP区或者分页文件）的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。 2、对象访问​ 介绍完Java虚拟机的运行时运行时数据区之后，我们就可以来探讨一个问题：在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码： 1Object obj = new Object(); ​ 假如这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java栈的本地变量表中，作为reference类型数据出现。而“new Object()”这部分语义会反应到Java堆中，形成一块存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。 ​ 由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。 如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄包含了对象实例数据和类型数据各自的具体地址信息。如下图所示 如果使用直接指针访问方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如下图所示 ​ 这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。 ​ 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就Sun HotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。]]></content>
      <categories>
        <category>JavaJVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言学习(四)--顺序编程(二)]]></title>
    <url>%2F2017%2F07%2F11%2Fgo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E5%9B%9B-%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 流程控制​ 程序设计语言的流程控制语句,用于设定计算执行的次序,建立程序的逻辑结构。可以说,流程控制语句是整个程序的骨架。 ​ 从根本上讲,流程控制只是为了控制程序语句的执行顺序,一般需要与各种条件配合,因此,在各种流程中,会加入条件判断语句。流程控制语句一般起以下3个作用:  选择,即根据条件跳转到不同的执行序列;  循环,即根据条件反复执行某个序列,当然每一次循环执行的输入输出可能会发生变化;  跳转,即根据条件返回到某执行序列。 Go语言支持如下的几种流程控制语句:  条件语句,对应的关键字为if、else和else if;  选择语句,对应的关键字为switch、case和select(将在介绍channel的时候细说);  循环语句,对应的关键字为for和range;  跳转语句,对应的关键字为goto。 在具体的应用场景中,为了满足更丰富的控制需求,Go语言还添加了如下关键字:break、continue和fallthrough。在实际的使用中,需要根据具体的逻辑目标、程序执行的时间和空间限制、代码的可读性、编译器的代码优化设定等多种因素,灵活组合。 接下来简要介绍一下各种流程控制功能的用法以及需要注意的要点。 1.条件语句​ 关于条件语句的示例代码: 12345if a &lt; 5 &#123; return 0&#125;else&#123; return 1&#125; ​ 关于条件语句,需要注意以下几点:  条件语句不需要使用括号将条件包含起来();  无论语句体内有几条语句,花括号{}都是必须存在的;  左花括号{必须与if或者else处于同一行;  在if之后,条件语句之前,可以添加变量初始化语句,使用;间隔; ​ 2.选择语句根据传入的条件不同，选择语句会执行不同的语句。下面的例子根据传入的整形变量i不同而打印不同的的内容。 123456789101112switch i &#123; case 0: fmt.Println(0) case 1: fmt.Println(1) case 2: fallthrough case 4, 5, 6: fmt.Println("4,5,6") default: fmt.Println("Default") &#125; 比较有意思的为，switch后面的表达式甚至不是必须的，比如 123456789Num := 3switch &#123;case 0 &lt;= Num &amp;&amp; Num &lt;= 3: fmt.Println("0-3")case 4 &lt;= Num &amp;&amp; Num &lt;= 6: fmt.Println("4-6")case 7 &lt;= Num &amp;&amp; Num &lt;= 9: fmt.Println("7-9")&#125; 在使用switch结构时,我们需要注意以下几点:  左花括号{必须与switch处于同一行;  条件表达式不限制为常量或者整数;  单个case中,可以出现多个结果选项;  与C语言等规则相反,Go语言不需要用break来明确退出一个case;  只有在case中明确添加fallthrough关键字,才会继续执行紧跟的下一个case; 可以不设定switch之后的条件表达式,在此种情况下,整个switch结构与多个if…else…的逻辑作用等同。 3.循环语句 与多数语言不同，Go语言只支持for关键字，不支持while和do while结构。 1234sum := 0for i := 0; i &lt; 10 ; i++&#123; sum+=i&#125; 可以看到比较大的一个不同在于for后面的条件表达式不需要用圆括号()包含起来。Go语言 还进一步考虑到无限循环的场景,让开发者不用写无聊的for (;;) {} 和 do {} while(1);, 而直接简化为如下的写法: 1234567sum := 0for &#123; sum++ if sum &gt; 100&#123; break &#125;&#125; 在条件表达式中也支持多重赋值,如下所示: 1234a := []int&#123;1, 2, 3, 4, 5, 6&#125;for i, j := 0, len(a) – 1; i &lt; j; i, j = i + 1, j – 1 &#123; a[i], a[j] = a[j], a[i]&#125; 使用循环语句时,需要注意的有以下几点。  左花括号{必须与for处于同一行。  Go语言中的for循环与C语言一样,都允许在循环条件中定义和初始化变量,唯一的区别是,Go语言不支持以逗号为间隔的多个赋值语句,必须使用平行赋值的方式来初始化多个变量。 Go语言的for循环同样支持continue和break来控制循环,但是它提供了一个更高级的 break,可以选择中断哪一个循环,如下例: 12345678for j := 0; j &lt; 5; j++ &#123; for i := 0; i &lt; 10; i++ &#123; if i &gt; 5 &#123; break JLoop &#125; fmt.Println(i) &#125;&#125; JLoop:// ... 本例中,break语句终止的是JLoop标签处的外层循环。 4.跳转语句goto语句被多数语言学者所反对,谆谆告诫不要使用。但对于Go语言这样一个惜关键字如 6金的语言来说,居然仍然支持goto关键字,无疑让某些人跌破眼镜。但就个人一年多来的Go语言编程经验来说,goto还是会在一些场合下被证明是最合适的。 goto语句的语义非常简单,就是跳转到本函数内的某个标签,如: 123456789func myfunc()&#123; i:=0 HERE: fmt.Println(i) i++ if(i&lt;10)&#123; goto HERE &#125;&#125; 函数​ 函数构件了代码执行的逻辑结构。在Go语言中，函数的基本组成为：func关键字、函数名、参数列表、返回值、函数体和返回语句。 1.函数定义前面已经大概的介绍过函数,这里我们使用一个简单的加法函数： 1234567891011121314package mymathimport ( "errors")func Add(a, b int) (ret int, err errors) &#123; if a &lt; 0 || b &lt; 0 &#123; //假设这函数只支持两个非负数的加法 err = errors.New("Should be non-negative numbers!") return &#125; return a + b, nil //支持重返回&#125; 2.不定参数]]></content>
      <categories>
        <category>GoLang</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言学习(三)--顺序编程]]></title>
    <url>%2F2017%2F07%2F09%2Fgo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E4%B8%89-%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[[TOC] 1.变量​ 变量几乎是所有编程语言中最基本的的组成元素。从根本上讲，变量相当于是对一块数据存储空间的命名，程序可以通过定义一个变量来申请一块数据存储空间，之后通过引用变量名来使用这块存储空间。 1.1变量的声明Go语言中的变量定义和其它的编程语言有很大的不同，Go中使用var关键子，而且类型信息放在变量名之后,如下: 12345678910var v1 intvar v2 stringvar v3 [10]int //数组var v4 []int //数组切片var v5 struct &#123; //结构 f int&#125;var v6 *int //指针var v7 map[string]int //map,key为string类型，value为int类型var v8 func(a int) int //函数 每一行结束都不需要使用分号，也就是说Go不是用分号作为语句的结束标记的习惯。 var还有另一种的使用方式－－可以将若干个声明的变量放置在一起，免的程序员需要重复写var关键字，如下: 1234var ( v9 int v10 string) 1.2变量的初始化对于声明变量时需要进行初始化的场景，var关键字可以保留，但是不再是必要元素，如下： 123var v11 int = 10 //正确使用方式一var v12 = 10 //正确使用方式二，编译器可以推导出v12的类型v13 := 10 //正确使用方式三，编译器可以推导出v13的类型 ​ 以上三种用法的效果是完全一致。与第一种用法比较，第三种用法需要输入的字符大大减少，是懒程序员和聪明的程序员的最佳选择。第三种方式是Go语言中引用（冒号和等号的组合:=）,用于明确表达同时变量申明和初始化的工作。 ​ ⚠️ 申明在:=左侧的变量不应该是已经被声明过的，否则会导致编译错误，比如： 12var i inti := 2 ​ 会出现no new variables on left side of := 1.3变量赋值在Go语言中，变量初始化和变量赋值是两个不同的概念。下面为声明一个变量之后的赋值过程： 12var i inti = 123 Go语言的变量赋值与多数语言一致，但Go还提供了一种多重赋值功能，比如下面这个交换i和j变量的语句： 1i,j = j,i 而在不支持多重赋值的语言中，交换两个变量的内容需要引入一个中间变量： 1t = i;i = j;j = t; 1.4匿名变量​ 我们在使用一些传统的强类型编程语言，经常会出现如下情况，即在调用函数时为了获取一个值，却因为该函数返回多个值而不得不定义一堆没有意义的变量。在Go语言中和结合多重返回和匿名变量来避免这种丑陋的写法，让代码看起来更加的优雅。 ​ 假设GetName()函数定义如下，它返回3个值，分别为firstName，lastName和nickName： 123func GetName()(firstName,lastName,nickName string)&#123; return "Mary","Chan","Chibi Maruko"&#125; ​ 若只想获取nickName，则函数的语句可以使用如下方式: 1_,_,nikeName := GetName() ​ 这种用法可以让代码非常清晰,基本上屏蔽掉了可能混淆代码阅读者视线的内容,从而大幅降低沟通的复杂度和代码维护的难度。 2.常量​ 在Go语言中常量表示在编译期间就已知且不可改变的值。常量的类型可以为数值类型（包括整型、浮点型和复数类型）、布尔类型和字符串类型等。 2.1字面常量​ 所谓字面常量（literal），是指程序中硬编码的常量，如: 12345－123.14159265358979323846 //浮点类型的常量3.2 + 12i //复数类型的常量true //布尔类型的常量"foo" //字符串类型的常量 2.2常量的定义​ 通过const关键字，你可以给字面量定义一个友好的名字： 12345678const PI = 3.14159265358979323846 const zero = 0.0const &#123; size int64 = 1024 eof = -1&#125;const u,v float32 = 0, 3const a,b,c = 3,4,"foo" ​ Go中的常量可以限定类型，但不是必须的。 ​ 常量定义的右值也可以是一个在编译期间运算的表达式，比如 1const mask = 1&lt;&lt;3 ​ 由于常量的赋值是一个在编译期间的行为，所有右值不能出现任何需要在运行期才能得出结果的表达式，比如试图以如下方式定义常量就会出现编译错误。 1const Home = os.GetEnv("HOME") ​ 因为os.GetEnv()只有在运行期才知道返回结果，在编译期间并不能确定，所有无法作为常量定义的右值。 2.3 预定义常量​ Go语言中预定义了这些常量：true、false和iota。 ​ iota比较特殊，可以认为是一个可被编译器修改的常量，在每一个const出现时被重置为0，然后在下一个const出现之前，每出现一次iota，其所代表的数值会自动增1. ​ 比如; 1234567891011121314151617181920const ( //iota被重置 c0 = iota //c0 == 0 c1 = iota //c1 == 1 c2 = iota //c2 == 2)const( a = 1 &lt;&lt; iota //a == 1 (iota在每个const开始被重设为0) b = 1 &lt;&lt; iota //b == 2 c = 1 &lt;&lt; iota //c == 4)const( u = iota * 42 // u == 0 v float64= iota * 42 // v == 42.0 w = iota * 42 // w == 84)const x = iota // x == 0 (因为iota又被重置)const y = iota // y == 0 ​ 如果两个const表达式的赋值语句一致，那么可以省略后一个赋值表达式。因此上面的前两个const语句可以简写为： 1234567891011const( c0 = iota c1 c2 )const( a = 1 &lt;&lt; iota b c) 2.4 枚举​ 枚举指一系列相关的常量，比如下面关于一个星期中的每天的定义。 12345678910const( Sunday = iota Monday Tuesday Wednesday Thursday Friday Saturday numberOfDays //这个常量没有导出 ) ​ 同Go语言的其他符号(symbol)一样,以大写字母开头的常量在包外可见。以上例子中numberOfDays为包内私有,其他符号则可被其他包访问。 3.类型​ Go语言内置一下基础类型： 布尔类型:bool 整型:int8、uint8(byte)、int16、int、uint、intptr等 浮点类型:float32、float64 复数类型:complex64、complex128 字符串:string 字符类型:rune 错误类型:error 此外Go语言还支持一下这些符合类型: 指针(pointer) 数组(array) 切片(slice) 字典(map) 通道(chan) 结构体(struct) 接口(interface) 3.1布尔类型​ Go语言中的布尔类型与其他语言基本一致,关键字也为bool,可赋值为预定义的true和 false示例代码如下: 123var v1 boolv1 = truev2 := (1 == 2) // v2也会被推导为bool类型 布尔类型不能接受其他类型的赋值,不支持自动或强制的类型转换。以下的示例是一些错误的用法,会导致编译错误: 123var b boolb=1// 编译错误b = bool(1) // 编译错误 以下的用法才是正确的: 123var b boolb = (1!=0) // 编译正确fmt.Println("Result:", b) // 打印结果为Result: true 3.2整型整型是所有编程语言里最基础的数据类型。Go语言支持如下整型类型。 类型 长度（字节） 范围值 int8 1 -128~127 uint8(byte) 1 0~255 int16 2 -32768~32768 uint16 2 0~65535 int32 4 -2147483648~2147483647 uint32 4 0~4294967295 int64 8 -9223372036854775808~9223372036854775807 uint64 8 0~18446744073709551615 int 平台相关 平台相关 uint 平台相关 平台相关 uintptr 同指针 32位平台下为4字节,64位平台下为8字节 3.2.1整型表示需要注意的是，int和int32在Go语言中被认为是两种不同的类型，编译器也不会帮你自动的转换，比如以下的例子会有编译错误: 123var v1 int32v2 := 32 //v2会被自动推导为int类型v1 = v2 //编译错误 编译错误类似于: cannot use value1 (type int) as type int32 in assignment。 可以使用强制类型转换可以解决： 1v1 = int32(v2) 当然,开发者在做强制类型转换时,需要注意数据长度被截短而发生的数据精度损失(比如浮点数强制转为整数)和值溢出(值超过转换的目标类型的值范围时)问题。 3.2.2数值运算Go语言支持如下常规运算符:+、－、＊、／、％ 分别就为加、减、乘、除、取余。 3.2.3比较运算Go语言支持的比较运算符有:&gt;、&lt; 、== 、&gt;= 、&lt;= 和 !=。这一点与大多数其它语言相同，与c语言完全一致。 1234i,j := 1 ,2if i==j &#123; fmt.Println("i and j are equal.")&#125; 两个不同的类型的整型数不能直接比较，比如int8类型的数和int类型的数不能直接比较，但是各种类型的整形变量与字面量直接比较，比如: 123456789101112var i int32var j int64i,j = 1,2if i==j &#123; //编译错误 fmt.Println("i and j are equal.")&#125;if i==1 || j==2 &#123;//编译通过 fmt.Println("i and j are equal.")&#125; 3.2.4 位运算Go语言支持的位运算符。 运算 含义 样例 x &lt;&lt; y 左移 124 &lt;&lt; 2 //结果为496 x &gt;&gt; y 右移 124 &gt;&gt; 2//结果为31 x ^ y 异或 124 ^ 2//结果为126 x &amp; y 与 124 &amp; 2//结果为0 x \ y 或 124 \ 2//结果为126 ^x 取反 ^2//结果为-3 3.3浮点型​ 浮点型用于表示包含小数点的数据,比如1.234就是一个浮点型数据。Go语言中的浮点类型采用IEEE-754标准的表达方式。 ​ 在Go语言中，定义一个浮点型变量的代码如下. 123var f1 float32f1 = 12f2 := 12.0 //如果不添加小数点，f2会被推导为整型而不是浮点型 ​ 对于以上的例子中f2会被推导为float64，因此对于以上的例子，下面的赋值回导致编译错误 1f1 = f2 ​ 而必须使用强制类型转换: 1f1 = float32(f2) ​ 浮点型的比较－－因为浮点型不是一种精确的表示方式，所以像整型那样直接使用＝＝来判断两个浮点型是否相同是不可行的，这样会导致不稳定的结果。 ​ 下面是一种推荐的方式： 123456import "math"//p为用户自定义的精度，比如0.00000001func IsEqual(f1,f2,p float64)&#123; return math.Fdim(f1,f2)&lt;p&#125; 3.4 复数类型复数实际上由两个实数(在计算机中用浮点数表示)构成,一个表示实部(real),一个表示虚部(imag)。如果了解了数学上的复数是怎么回事,那么Go语言的复数就非常容易理解了。 复数表示复数表示的示例如下: var value1 complex64 123value1 = 3.2 + 12ivalue2 := 3.2 + 12ivalue3 := complex(3.2, 12) 实部与虚部 // 由2个float32构成的复数类型// value2是complex128类型 // value3结果同 value2 对于一个复数z = complex(x, y),就可以通过Go语言内置函数real(z)获得该复数的实部,也就是x,通过imag(z)获得该复数的虚部,也就是y。 更多关于复数的函数,请查阅math/cmplx标准库的文档。 3.5字符串​ 在Go语言中字符串也是基本类型。Go语言中对字符串的声明和初始化非常简单，如下: 12345var str stringstr = "Hello world"ch := str[0]fmt.Printf("The length of \"%s\" is %d \n", str, len(str)) fmt.Printf("The first character of \"%s\" is %c.\n", str, ch) ​ 输出结果为: The length of “Hello world” is 11The first character of “Hello world” is H. ​ 字符串的内容可以通过类似数组下标的方式获取，但是与数组不同的是，字符串的内容不能在初始化后修改，比如以下的例子： 12str := "Hello world!"str[0] = 'x' //编译错误 3.5.1字符串操作平常的字符串操作如下所示: 运算 含义 样例 x + y 字符串链接 “hello”+”123” //结果为hello123 len(s) 字符串的长度 len(“hello”) //结果为5 s[i] 取字符 “Hello”[1] //结果为e ​ 更多的字符串操作请参考标准包strings 3.5.2字符串的遍历​ Go语言支持两种方式的遍历字符串。一种以字节数组的方式遍历： 123456789101112package mainimport "fmt"func main() &#123; str := "Hello,世界" n := len(str) for i := 0; i &lt; n; i++ &#123; ch := str[i] fmt.Println(i, ch) &#125;&#125; 执行结果如下: 0 721 1012 1083 1084 1115 446 2287 1848 1509 23110 14911 140 可以看出这个字符串长度为12。尽管直观上这个字符串只有8个字符,那是每个中文字符在UTF－8中占3个字节，而不是一个字节。 另一种采用Unicode字符遍历： 1234str := "Hello,世界" for i, c := range str &#123; fmt.Println(i, c) &#125; 执行结果: 0 721 1012 1083 1084 1115 446 199909 30028 因为在Unicode字符方式遍历时，每个字符的类型都为rune，而不是byte。 3.6字符类型​ 在Go语言中支持两种类型的字符类型，一个是byte(实际为uint8的别名),代表UTF－8字符串的单个字节的值；另一个是rune，代表单个Unicode字符。 ​ 关于rune的操作可以参考标准库中的unicode包。同时在unicode/utf-8包也提供了UTF－8和Unicode之间的转换。 ​ Go语言中多数的API都假设字符串为UTF－8编码。虽然Unicode在标准库中有支持，但是实际上较少使用。 3.7数组​ 数组是Go语言编程中最常用的数据结构之一。数组为一系列的同一类型数据的集合。数组中包含的每个数据被称为数组的元素（element），一个数组包含的元素个数被称为数组的长度。 ​ 以下为一些常规的数组声明方法： 1234567[32]byte //长度为32的数组，每个元素为一个字节[2*N] struct&#123; //结构类型数组 x,y int32&#125;[1000]*float64 //指针数组[3][5]int //二维数组[2][2][2]float64 //三维数组 ​ 数组的长度在定义后就不能修改了，声明的常量可以为一个常量或一个常量表达式。数组的长度是该数组中的一个内置常量，可以通过len()函数获取。长度不同的数组类型也是不同的比如： 123var a [32]intvar b [12]inta==b //编译错误 mismatched types [32]int and [12]int 3.7.1数组的访问​ 可以使用数组下标访问数组中元素，数组下标从0开始，len(array)-1表示最后一个元素的下标。如： 1234arr := [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;for i := 0; i &lt; len(arr); i++ &#123; fmt.Println(arr[i])&#125; ​ Go语言中还提供了一个range关键字，用于便捷地遍历容器中的元素。当然数组也是range的支持范围。上边的遍历可以简化为 1234arr := [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;for i, e := range arr &#123; fmt.Println("Element:", e, " Index:", i)&#125; ​ 在上面的例子中可以看出range含有两个返回值，第一个返回值表示数组的下标，第二个表示为元素值。 3.7.2值类型​ 需要注意的是，在Go语言中数组为一个值类型（value type）。所有的值类型变量在赋值和参数传递的时候都将产生一次复制动作。如果将数组作为函数的参数，则函数调用的时候将参数进行复制。因此，在函数中对数组进行修改，不会对原始的数组造成影响。 ​ 下面通过一个例子来看看这个特点： 1234567891011121314package mainimport "fmt"func modify(arr [5]int) &#123; arr[0] = 10 //尝试修改第一个元素 fmt.Println("In modify(),arr values:", arr)&#125;func main() &#123; arr := [5]int&#123;1, 2, 3, 4, 5&#125; modify(arr) fmt.Println("In main(),arr values:", arr)&#125; ​ 运行结果: In modify(),arr values: [10 2 3 4 5]In main(),arr values: [1 2 3 4 5] 3.8数组切片​ 前面我们看到数组的特点：数组的长度在定义后无法再次修改；数组是值类型，每次传递都将会产生一个副本。显然这种数据结构无法满足开发者真正的需求。 ​ 那么Go语言提供了切片（slice）这个非常酷的功能来满足数组的不足。 ​ 初看起来，数组就像一个指向数组的指针，实际上它拥有自己的数据结构，而不仅仅是指针。数组切片的数据结构可以抽象为3个变量： 一个指向原生数组的指针 数组切片中的元素的个数 数组切片已分配的存储空间 3.8.1创建数组切片创建数组切片的方法主要有两种－－基于数组和直接创建。 1.基于数组创建​ 数组切片的创建可以基于一个已存在的数组。数组切片可以使用数组的一部分或整个数组来创建，甚至可以创建一个比所基于的数组还要大的数组切片。 下面是一个数组创建切片的实例：slice.go 1234567891011121314151617181920212223package mainimport "fmt"func main() &#123; //先定义一个数组 var myArr [10]int = [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; //基于数组创建一个切片 var mySlice = myArr[:5] fmt.Println("Element of myArray: ") for _, v := range myArr &#123; fmt.Print(v, " ") &#125; fmt.Println("\nElement of mySlice:") for _, v := range mySlice &#123; fmt.Print(v, " ") &#125; fmt.Println()&#125; 运行结果为： Element of myArray:1 2 3 4 5 6 7 8 9 10Element of mySlice:1 2 3 4 5 ​ Go语言中支持myArray[first:last]这样的方式来基于数组生成一个数组切片（左闭右开），而且这个用法还很灵活，比如下面的几种方式都是合法的。 12345678//基于myArray所有元素创建mySlice := myArray[:]//基于myArray的前5个元素创建mySlice := myArray[:5]//基于从第5个元素开始的所有元素创建mySlice := myArray[5:] 2.直接创建​ 切片还可以通过直接创建的方式进行创建，Go语言提供了内置make()函数可以灵活的创建数组切片。下面显示直接创建数组的几种正确的方法。 12345678//创建一个初始元素为5个的切片，元素的初始值为0mySlice := make([]int,5)//创建一个初始元素为5的切片，元素初始值为0，并且预留10个元素的空间mySlice := make([]int,5,10)//直接创建并初始化包含5个元素的数组切片mySlice := []int&#123;1,2,3,4,5&#125; 3.8.2元素遍历​ 操作数组的所有的方法都可以使用在切片上，比如数组切片也可以使用下标读写元素，使用len()获取元素的个数，并可以使用range关键字遍历所有的元素。 123456789//传统的遍历方式如下for i:=0 ; i&lt;len(mySlice) ; i++ &#123; fmt.Println("mySlice[",i,"]=",mySlice[i])&#125;//使用range关键字遍历for i , v := range mySlice &#123; fmt.Println("mySlice[",i,"]=",v)&#125; 3.8.3动态增减元素​ 可动态的增减元素是数组切片比数组更为强大的功能。与数组相比，数组切片多了一个存储能力（capacity）的概念，即元素个数和分配的空间可以是两个不同的概念。合理的分配存储的空间，可以大幅度的降低数组切片内部重新分配内存和搬送内存块的频率，从而大大提高程序的性能。 ​ 数组切片支持Go语言内置的cap()和len()函数，cap()返回为数组切片分配的空间的大小,len()为数组切片中元素的个数。 123456789101112package mainimport ( "fmt")func main() &#123; mySlice := make([]int, 5, 10) fmt.Println("len(mySlice):", len(mySlice)) fmt.Println("cap(mySlice):", cap(mySlice))&#125; 运行结果为: len(mySlice): 5cap(mySlice): 10 ​ 如果需要往上面的mySlice已包含5个元素后面继续添加元素可以使用append()函数。下面的代码可以从尾端给mySlice加上3个元素，从而生成一个新的数组切片 1mySlice = append(mySlice,1,2,3) append()函数的第二个参数为一个不定参数，我们可以按照自己需求添加若干的参数，甚至可以将一个数组切片添加到另一个数组切片中。 12mySlice2 = []int&#123;7,8,9&#125;mySlice = append(mySlice,mySlice2...)//== mySlice = append(mySlice,mySlice2...) 需要注意的是上面的方法中第二个参数后面添加的…不能省略，因为需要将mySlice2打散后在传入。 3.8.4基于数组切片创建数组切片​ 类似数组切片可基于数组创建，数组切片也可以基于另一个数组切片创建。 12oldSlice := []int&#123;1,2,3,4,5&#125;newSlice := oldSlice[:3] //基于oldSlice的前3个元素 ​ 有意思的是，选择的oldSlice元素范围甚至可以超过所包含的元素个数，比如newSlice前6个元素创建，只要这个值不要超过oldSlice的cap值就可以了。 3.8.5内容复制​ 数组切片支持Go语言的另一个内置函数copy(),用于将内容从一个数组切片复制到另一个数组切片。如果加入的两个数组切片大小不一致，就会按照较小那个数组切片的元素个数进行复制。 12345slice1 := []int&#123;1, 2, 3, 4, 5&#125;slice2 := []int&#123;5, 4, 3&#125;copy(slice2, slice1)copy(slice1, slice2) 3.9 map​ 在Go语言中map未排序的健值对的组合。比如以身份证号为唯一主键来识别一个人的信息。 123456789101112131415161718192021222324252627282930package mainimport ( "fmt")type PersonInfo struct &#123; ID string Name string Address string&#125;func main() &#123; //创建map var personDB map[string]PersonInfo personDB = make(map[string]PersonInfo) //给map添加一下数据 personDB["12345"] = PersonInfo&#123;"12345", "Tom", "Room 203,..."&#125; personDB["1"] = PersonInfo&#123;"1", "Jack", "Room 101,..."&#125; //查询key为12345的值 person, ok := personDB["12345"] if ok &#123; fmt.Println("Found person ", person.Name, " with ID 1234.") &#125; else &#123; fmt.Println("Did not find person with ID 1234.") &#125;&#125; ​ 上面这个简单的例子基本上已经覆盖了map的主要用法,下面对其中的关键点进行细述。 变量声明 map的声明基本上没有多余的元素,比如:var myMap map[string] PersonInfo 其中,myMap是声明的map变量名,string是键的类型,PersonInfo则是其中所存放的值类型。 创建 我们可以使用Go语言内置的函数make()来创建一个新map。下面的这个例子创建了一个键类型为string、值类型为PersonInfo的map: myMap = make(map[string] PersonInfo)也可以选择是否在创建时指定该map的初始存储能力,下面的例子创建了一个初始存储能力 为100的map:myMap = make(map[string] PersonInfo, 100) 元素赋值 赋值过程非常简单明了,就是将键和值用下面的方式对应起来即可: 1myMap[&quot;1234&quot;] = PersonInfo&#123;&quot;1&quot;, &quot;Jack&quot;, &quot;Room 101,...&quot;&#125; 4. 元素删除delete(myMap, “1234”)上面的代码将从myMap中删除键为“1234”的键值对。如果“1234”这个键不存在,那么这个 将什么都不发生,也不会有什么副作用。但是如果传入的map变量的值是nil,该调用将导致程序抛出异常(panic)。 5. 元素查找在Go语言中,map的查找功能设计得比较精巧。而在其他语言中,我们要判断能否获取到一个值不是件容易的事情。判断能否从map中获取一个值的常规做法是:(1) 声明并初始化一个变量为空;(2) 试图从map中获取相应键的值到该变量中;(3) 判断该变量是否依旧为空,如果为空则表示map中没有包含该变量。这种用法比较啰唆,而且判断变量是否为空这条语句并不能真正表意(是否成功取到对应的 值),从而影响代码的可读性和可维护性。有些库甚至会设计为因为一个键不存在而抛出异常,让开发者用起来胆战心惊,不得不一层层嵌套try-catch语句,这更是不人性化的设计。在Go语言中,要从map中查找一个特定的键,可以通过下面的代码来实现: value, ok := myMap[“1234”] ifok{// 找到了 // 处理找到的value} 判断是否成功找到特定的键,不需要检查取到的值是否为nil,只需查看第二个返回值ok,这让表意清晰很多。配合:=操作符,让你的代码没有多余成分,看起来非常清晰易懂。​​​​​​​​​​​​​​​ ​​​ ​​​​​​​​​ ​​​​​​]]></content>
      <categories>
        <category>GoLang</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言学习(二)--第一个GO程序]]></title>
    <url>%2F2017%2F07%2F09%2Fgo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%E7%AC%AC%E4%B8%80%E4%B8%AAGO%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[[TOC] 1.第一个Go程序​ 几乎所有的程序开始都是以Hello World小例子作为开始。我们也不面熟（或者说尊重传统），下面我们从一个简单Go语言版本的Hello World来初窥Go这门新语言的模样。 ​ hello.go 1234567package mainimport "fmt" //导入我们需要使用的包 ，我们需要使用里面的Println函数func main() &#123; fmt.Println("Hello, world. 你好， 世界！")&#125; 代码解读：​ 每个Go源码文件的开头都是以一个package开头，表示该Go代码所属的包。包是Go中最基本的分发单位,也会工程管理中依赖关系的体现。要生成可执行文件，必须建立一个名字为main的包，并且在该包中包含一个叫main()的函数（该函数为Go可执行程序的起点，也只能含有一个）。 ​ main()函数定义为不能带参数、返回值。命令行的参数保存在os包中的os.Args中，命令行的参数解析可以通过flag包解析，在后面章节中我们回看到如何使用flag包。 ​ 在包的声明后会含有一系列的import语句，用于导入该程序所依赖的包。（有一点需要注意：⚠️ 在源码文件中不能包含没有使用的包，否则会编译错误） ​ 所有的Go函数都是以func关键字开头一个常规的函数包涵一下格式。 1234567func 函数名(参数列表)(返回值列表)&#123; &#125;//比如func Compute(arg1 int,arg2 float64)(retVal float64,err error)&#123; &#125; ​ 在Go的函数中支持多个函数返回值，比如上面的例子中返回了retVal和error。但是并不是所有的返回值都需要赋值，如果函数返回值没有被明确的赋值都会被设置为对应的类型的零值，比如retVal被设置为0.0，err被设置为nil。 Go中的注释Go的注释和C++保持一致，同时支持一下两种方式： 12345/* 快注释*/// 行注释 ​ ⚠️ 在Go源码文件中不能包含没有使用的包，否则会编译错误。 在Go源码文件中不能使用分号。 同时在含有括号的语句中，左括号({)不能另起一行。syntax error: unexpected semicolon or newline before { 代码的编译与执行12$ go run hello.go #直接执行Hello, world. 你好,世界! 使用如上命令，会将编译、链接和运行3个步骤合并为一步。运行完成后在当前目录下也看不到中间文件和最终的可执行文件。如果需要生成编译结果，不需要自动执行，可以使用build命令： 123$ go build hello.go #编译$ ./helloHello, world. 你好,世界! 工程管理​ 在实际的开发工作中,直接调用编译器进行编译和链接的场景是少而又少,因为在工程中不会简单到只有一个源代码文件,且源文件之间会有相互的依赖关系。如果这样一个文件一个文件逐步编译,那不亚于一场灾难。Go语言的设计者作为行业老将,自然不会忽略这一点。早期Go语言使用makefile作为临时方案,到了Go 1发布时引入了强大无比的Go命令行工具。 ​ Go命令行工具的革命性之处在于彻底消除了工程文件的概念,完全用目录结构和包名来推导工程结构和构建顺序。针对只有一个源文件的情况讨论工程管理看起来会比较多余,因为这可以直接用go run和go build搞定。下面我们将用一个更接近现实的虚拟项目来展示Go语言的基本工程管理方法。 假设有这样一个场景:我们需要开发一个基于命令行的计算器程序。下面为此程序的基本用法: 1234567891011$ cal helpUsage: calc cmmand [args]...The cmmand are:sqrt Square root of non-negative value.add Add of two value$ cal sqrt 4 # 开根号2$ cal add 1 2 # 加法3 我们假设这个工程被分割为两个部分: 可执行程序,名为calc,内部只包含一个calc.go文件; 算法库,名为simplemath,每个command对应于一个同名的go文件,比如add.go。 1则一个正常的工程目录组织应该如下所示: 在上面的结构里,带尖括号的名字表示其为目录。xxx_test.go表示的是一个对于xxx.go的单元测试,这也是Go工程里的命名规则。 为了让读者能够动手实践,这里我们会列出所有的源代码并以注释的方式解释关键内容,需要注意的是,本示例主要用于示范工程管理,并不保证代码达到产品级质量。 cal.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//calc.gopackage mainimport ( "fmt" "gostudy/ch02/calc/simplemath" "os" //用于获取命令行参数os.Args "strconv")func main() &#123; args := os.Args //获取控制台参数 argsLen := len(args) if args == nil || argsLen &lt; 3 &#123; Usage() return &#125; switch args[1] &#123; case "add": if argsLen &lt; 4 &#123; fmt.Println("Usage: calc add &lt;integer1&gt;&lt;integer2&gt;") return &#125; v1, err1 := strconv.Atoi(args[2]) v2, err2 := strconv.Atoi(args[3]) if err1 != nil || err2 != nil &#123; fmt.Println("Usage: calc add &lt;integer1&gt;&lt;integer2&gt;") return &#125; result := simplemath.Add(v1, v2) fmt.Println("Result:", result) case "sqrt": v, err := strconv.Atoi(args[2]) if err != nil &#123; fmt.Println("Usage: calc sqrt &lt;integer&gt;") return &#125; result := simplemath.Sqrt(v) fmt.Println("Result:", result) default: Usage() &#125;&#125;func Usage() &#123; fmt.Println("Usage: calc command [args]...") fmt.Println("The command are:") fmt.Println("sqrt Square root of non-negative value.") fmt.Println("add Add of two value")&#125; add.go 123456//add.gopackage simplemathfunc Add(a int, b int) int &#123; return a + b&#125; add_test.go 123456789101112package simplemathimport ( "testing")func TestAdd1(t *testing.T) &#123; r := Add(1, 2) if r != 3 &#123; t.Errorf("Add(1,2) failed.Got %d,expected 3.", r) &#125;&#125; sqrt.go 12345678910package simplemathimport ( "math")func Sqrt(a int) int &#123; v := math.Sqrt(float64(a)) return int(v)&#125; sort_test.go 123456789101112package simplemathimport ( "testing")func TestSqrt1(t *testing.T) &#123; v := Sqrt(16) if v != 4 &#123; t.Errorf("Sqrt(16) failed. Got %v, expected 4.", v) &#125;&#125; 为了能够构建这个工程,需要先把这个工程的根目录加入到环境变量GOPATH中。 执行测试go test simplemath 生成可执行文件go install calc.go 进入bin ./calc add 1 2 ​​​]]></content>
      <categories>
        <category>GoLang</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言学习(一)--GO语言的环境搭建]]></title>
    <url>%2F2017%2F07%2F08%2Fgo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E4%B8%80-GO%E8%AF%AD%E8%A8%80%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[1.安装git ​ 因为golang是通过git来管理远程包的，所以我们首先要安装git，下载地址：http://www.git-scm.com/download/。本教程主要针对golang环境搭建，git安装请自行baidu。 2.安装Golang ​ 1) 首先到https://golang.org/dl/选择适合你系统的安装包，（墙内：http://golangtc.com/download）。 ​ 2）我这里选择的是：go1.4.2.windows-amd64.msi，下载完成安装到指定目录即可。我这里是(E:\Go)。 ​ 3）安装完成后环境变量已经自动设置好了，可以呼出cmd命令行输入命令查看 1&gt; go env 可以看到，已经出现 go命令 了。如果你的不能出现，那可能是环境变量设置的问题。 ​ 进入我的电脑-&gt;高级设置-&gt;环境变量查看下，GOROOT变量是否存在，以及Path变量中是否也设置了GOROOT。没有的话，新增一个GOROOT变量，路径则输入你刚刚安装完成后Go的根目录，如我的是：E:\Go\。然后编辑Path变量，在最后面新增”;%GOROOT%bin“。 ​ 4）go命令依赖一个环境变量：GOPATH，这不是Go的安装目录，而是你的工作（工程）目录（你的代码都会在该目录下）。GOPATH可以有多个，windows以分号(;)进行区分，Linux系统是冒号(:)，当有多个GOPATH时，默认会将go get的内容放在第一个目录下。这里我们新建一个GOPATH变量，以我的为例：F:\mygo。 3.安装Sublime Text3 ​ 首先也是下载：http://www.sublimetext.com/3，安装也很傻瓜，直接下一步即可。 ​ 注意：sublime是收费软件，不注册也可以正常使用,只是保存次数达到一定的数量的时候会提示购买;忽略后可以正常使用。 ​ 这里需要安装一个sublime的pakcage control功能，用于接下来安装sublime插件。 ​ 1）在打开软件后，按下快捷键 Ctrl+`，（`这个符号为英文半角模式下，按下 Tab 键上方、数字键1左边的那个按键），此时会打开一个命令窗口，复制并输入以下内容，最后回车： 1import urllib.request,os,hashlib; h = &apos;eb2297e1a458f27d836c04bb0cbaf282&apos; + &apos;d0e7a3098092775ccb37ca9d6b2e4b7d&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 如果遇到报错则参考这里安装：https://packagecontrol.io/installation#st3。 2）重启sublime之后，你就可以发现在 Preferences 这个菜单下出现了菜单项 Package Control，如图： 4. 安装GoSublime插件 ​ 1）在sublime中，按住快捷键 shift + ctrl + p，在弹出框中输入install package，如图： ​ 2）回车，会出现如下图（可能需要稍微等待下，可以看sublime最下面的状态）： ​ 3）输入gosublime，回车（可能需要稍微等待下，可以看sublime最下面的状态），如图： ​ 4）gosublime安装完成后，Preferences -&gt; package settings -&gt; GoSublime -&gt; Settings - Uesrs需要配置下GOPATH，GOROOT，如图： ​ 5）在打开的窗口中输入以下内容，路径请自行替换，ctrl+s保存。 123456&#123; &quot;env&quot;: &#123; &quot;GOPATH&quot;: &quot;F:/mygo&quot;, &quot;GOROOT&quot;: &quot;E:/Go&quot; &#125;&#125; ​ 6）重启sublime，在GOPATH中的src新建一个hello.go文件，可以看到代码自动补全已经出来了，:) 至此，sublime text3 + golang 安装完成。 附上我的 sublime text3 的简单配置, Preferences -&gt; Settings User清空复制粘贴即可。 123456789101112131415&#123; &quot;font_size&quot;: 12, &quot;highlight_line&quot;: true, &quot;highlight_modified_tabs&quot;: true, &quot;ignored_packages&quot;: [ &quot;Vintage&quot; ], &quot;soda_classic_tabs&quot;: true, &quot;soda_folder_icons&quot;: true, &quot;tab_size&quot;: 4, &quot;translate_tabs_to_spaces&quot;: true, &quot;update_check&quot;: false, &quot;word_wrap&quot;: true&#125;]]></content>
      <categories>
        <category>GoLang</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java操作XML的五种方式]]></title>
    <url>%2F2017%2F07%2F05%2FJava%E6%93%8D%E4%BD%9CXML%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[[TOC] 1、了解XML​ XML，即可扩展标记语言（Extensible Markup Language），标准通用标记语言的子集，一种用于标记电子文件使其具有结构性的标记语言。它可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 它非常适合万维网传输，提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。它和JSON都是一种数据交换格式。 作用：解析XML文档，创建XML文档。 2、什么是可扩展标记语言？ · 可扩展标记语言是一种很像超文本标记语言的标记语言。 · 它的设计宗旨是传输数据，而不是显示数据。 · 它的标签没有被预定义。您需要自行定义标签。 · 它被设计为具有自我描述性。 · 它是W3C的推荐标准。 3、解析XML文档的五种方式： 五种方法解析XML文档：Dom、SAX、JDOM、dom4j 、degister准备xml文件123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;languages cat="it"&gt; &lt;lang id="1"&gt; &lt;name&gt;Java&lt;/name&gt; &lt;ide&gt;Eclipse&lt;/ide&gt; &lt;/lang&gt; &lt;lang id="2"&gt; &lt;name&gt;Swift&lt;/name&gt; &lt;ide&gt;Xcode&lt;/ide&gt; &lt;/lang&gt; &lt;lang id="3"&gt; &lt;name&gt;c#&lt;/name&gt; &lt;ide&gt;Visual Studio&lt;/ide&gt; &lt;/lang&gt;&lt;/languages&gt; 3.1、DOM第一种：DOM的全称是Document Object Model，也即文档对象模型。在应用程序中，基于DOM的XML分析器将一个XML文档转换成一个对象模型的集合（通常称DOM树），应用程序正是通过对这个对象模型的操作，来实现对XML文档数据的操作。通过DOM接口，应用程序可以在任何时候访问XML文档中的任何一部分数据，因此，这种利用DOM接口的机制也被称作随机访问机制。 3.1.1 dom读取xml文件​ 读取代码如下： 12345678910111213141516171819202122232425262728293031323334public void readXML() throws ParserConfigurationException, IOException, SAXException &#123; //1.获取DocumentBuilder工厂实例 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); //2.获取解析器 DocumentBuilder builder = dbf.newDocumentBuilder(); //3.解析文件 Document document = builder.parse(this.getClass().getClassLoader().getResourceAsStream("xml/languages.xml")); //获取根元素 Element root = document.getDocumentElement(); //获取属性 String cat = root.getAttribute("cat"); System.out.println("根元素为："+root.getNodeName()+" 属性cat:"+cat); //获取所有名字为lang的标签 NodeList langs = root.getElementsByTagName("lang"); int length = langs.getLength(); System.out.println("lang名称的节点长度为："+length); for (int i = 0; i &lt; length; i++) &#123; Node node = langs.item(i); //获取下面所有的子节点 NodeList childNodes = node.getChildNodes(); int len = childNodes.getLength(); System.out.println("第"+(i+1)+"个lang标签子节点长度:"+len);//长度为5（因为含有三个回车） for (int j = 0; j &lt; len; j++) &#123; Node item = childNodes.item(j); //只对节点类型为ELEMENT_NODE的操作 回车的类型为TEXT_NODE if(item.getNodeType()==Node.ELEMENT_NODE)&#123; System.out.println(item.getNodeName()+"="+item.getTextContent()); &#125; &#125; &#125; &#125; 3.1.2 dom方式创建xml创建xml代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public void createXml() throws ParserConfigurationException, TransformerException &#123; //1.获取DocumentBuilder工厂实例 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); //2.获取解析器 DocumentBuilder builder = dbf.newDocumentBuilder(); //3.获取Document Document document = builder.newDocument(); //创建节点 Element root = document.createElement("languages"); //创建属性 root.setAttribute("cat", "it"); //创建lang Element lang = document.createElement("lang"); lang.setAttribute("id", "1"); Element name = document.createElement("name"); name.setTextContent("java");//设置文本内容 Element ide = document.createElement("ide"); ide.setTextContent("Eclipse"); //添加节点 lang.appendChild(name); lang.appendChild(ide); root.appendChild(lang); document.appendChild(root); //输出 TransformerFactory factory = TransformerFactory.newInstance(); Transformer transformer = factory.newTransformer(); transformer.setOutputProperty("encoding", "UTF-8"); //写到字符串 StringWriter out = new StringWriter(); transformer.transform(new DOMSource(document),new StreamResult(out)); System.out.println(out.toString()); //写到文件 transformer.transform(new DOMSource(document), new StreamResult(new File("newxml.xml"))); &#125; 3.2 、SAX​ SAX介绍 SAX的全称是Simple APIs for XML，也即XML简单应用程序接口。 与DOM不同，SAX提供的访问模式是一种顺序模式，这是一种快速读写XML数据的方式。 当使用SAX分析器对XML文档进行分析时，会触发一系列事件，并激活相应的事件处理函数，应用程序通过这些事件处理函数实现对XML文档的访问，因而SAX接口也被称作事件驱动接口。 局限性： 1. SAX分析器在对XML文档进行分析时，触发了一系列的事件，由于事件触发本身是有时序性的，因此，SAX提供的是一种顺序访问机制，对于已经分析过的部分，不能再倒回去重新处理。 即，一旦经过了某个元素，我们没有办法返回去再去访问它。 2. SAX分析器只做了一些简单的工作，大部分工作还要由应用程序自己去做。 也就是说，SAX分析器在实现时，只是顺序地检查XML文档中的字节流，判断当前字节是XML语法中的哪一部分、是否符合XML语法，然后再触发相应的事件，而事件处理函数本身则要由应用程序自己来实现。 同DOM分析器相比，SAX分析器缺乏灵活性。 优势： 然而，由于SAX分析器实现简单，对内存要求比较低，（SAX不必将整个XML文档加载到内存当中，因此它占据内存要比DOM小）， 因此实现效率比较高。 对于大型的XML文档来说，通常会用SAX而不是DOM。 并且对于那些只需要访问XML文档中的数据而不对文档进行更改的应用程序来说，SAX分析器更为合适。 DefaultHandler类： 3.2.1 读取xml文件标签的枚举类如下 1234567891011121314151617181920212223242526272829303132package org.wuqinghua.java.xml.sax;/** * Created by wuqinghua on 17/7/5. */public enum TagName &#123; LANGUAGES("languages"),LANG("lang"), NAME("name"), IDE("ide"),NONE("none"); private String tagName; TagName(String tagName) &#123; this.tagName = tagName; &#125; public String getTagName() &#123; return tagName; &#125; public static TagName transformer(String tagName) &#123; switch (tagName) &#123; case "languages": return LANGUAGES; case "lang": return LANG; case "name": return NAME; case "ide": return IDE; default: return NONE; &#125; &#125;&#125; 将lang标签设计为一个对象 12345678910111213141516171819202122232425262728293031323334353637383940414243package org.wuqinghua.java.xml.sax;/** * Created by wuqinghua on 17/7/5. */public class Lang &#123; private String id; private String name; private String ide; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getIde() &#123; return ide; &#125; public void setIde(String ide) &#123; this.ide = ide; &#125; @Override public String toString() &#123; return "Lang&#123;" + "id='" + id + '\'' + ", name='" + name + '\'' + ", ide='" + ide + '\'' + '&#125;'; &#125;&#125; xml顺序执行的handler 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package org.wuqinghua.java.xml.sax;import org.xml.sax.Attributes;import org.xml.sax.SAXException;import org.xml.sax.helpers.DefaultHandler;import java.util.ArrayList;import java.util.List;/** * Created by wuqinghua on 17/7/5. */public class SaxHandler extends DefaultHandler &#123; private List&lt;Lang&gt; langs = null; private Lang lang = null; private boolean isName = false; private boolean isIde = false; //文档开始触发 @Override public void startDocument() throws SAXException &#123; super.startDocument(); &#125; //文档结束触发 @Override public void endDocument() throws SAXException &#123; super.endDocument(); &#125; //标签开始触发 @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; TagName tagName = TagName.transformer(qName); switch (tagName) &#123; case NONE: break; case LANGUAGES: if (langs == null) langs = new ArrayList&lt;&gt;(); break; case LANG: //解析lang标签 lang = new Lang(); String id = attributes.getValue("id"); lang.setId(id); break; case NAME: //解析name标签 isName = true; break; case IDE: //解析ide标签 isIde = true; break; &#125; &#125; //标签结束触发 @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; if (TagName.transformer(qName).equals(TagName.LANG)) &#123; langs.add(lang); &#125; &#125; //标签中数据触发 @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; if (isName) &#123; lang.setName(new String(ch, start, length)); isName = false; &#125; else if (isIde) &#123; lang.setIde(new String(ch, start, length)); isIde = false; &#125; &#125; public List&lt;Lang&gt; getLangs() &#123; return langs; &#125;&#125; 读取xml 12345678910111213public void readXML() throws ParserConfigurationException, SAXException, IOException &#123; //1.获取SAX解析器的工厂 SAXParserFactory factory = SAXParserFactory.newInstance(); //2.获取SAX解析器 SAXParser saxParser = factory.newSAXParser(); //3.创建顺序读取xml的处理器 SaxHandler handler = new SaxHandler(); //4.解析xml saxParser.parse(this.getClass().getClassLoader().getResourceAsStream("xml/languages" + ".xml"),handler); System.out.println(handler.getLangs());&#125; 3.2.1 创建xml文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public void createXML() throws TransformerConfigurationException, SAXException &#123; //1.获取SAXTransformerFactory实例 SAXTransformerFactory factory = (SAXTransformerFactory) SAXTransformerFactory.newInstance(); //2.创建TransformerHandler实例 TransformerHandler transformerHandler = factory.newTransformerHandler(); //3.创建Transformer对象 Transformer transformer = transformerHandler.getTransformer(); //4、设置输出的xml属性，encoding为编码，indent是确保输出的xml文件能够自动换行 transformer.setOutputProperty(OutputKeys.ENCODING,"UTF-8"); transformer.setOutputProperty(OutputKeys.INDENT,"yes"); //5、创建Result对象，将Result对象加载到TransHandler中 //注意：1、这一步必须在Transformer.setOutputProperty()之后，不然设置的xml属性将不生效 // 2、这一步也必须在TransformerHandler.startDocument()之前，不然会报错。 // 分析源码后发现，startDocument()会先判断result是否为空，为空则报错 Result result = new StreamResult("newxml.xml"); transformerHandler.setResult(result); //6、创建属性Attribute对象 AttributesImpl attr = new AttributesImpl(); //7.开始写文件 transformerHandler.startDocument(); //8.写入根节点 attr.clear(); //设置属性 attr.addAttribute("","","cat","","it"); transformerHandler.startElement("","",TagName.LANGUAGES.getTagName(),attr); //设置lang节点 attr.clear(); attr.addAttribute("","","id","","1"); transformerHandler.startElement("","",TagName.LANG.getTagName(),attr); //设置name节点 attr.clear();; transformerHandler.startElement("","",TagName.NAME.getTagName(),attr); transformerHandler.characters("java".toCharArray(),0,"java".toCharArray().length); transformerHandler.endElement("","",TagName.NAME.getTagName()); //设置ide attr.clear(); transformerHandler.startElement("","",TagName.IDE.getTagName(),attr); transformerHandler.characters("Eclipse".toCharArray(),0,"Eclipse".toCharArray().length); transformerHandler.endElement("","",TagName.IDE.getTagName()); transformerHandler.endElement("","",TagName.LANG.getTagName()); transformerHandler.endElement("","",TagName.LANGUAGES.getTagName()); //9.结束 transformerHandler.endDocument();&#125; 3.3 JDomJDOM是一个开源项目，它基于树型结构，利用Java的技术对XML文档实现解析、生成、序列化以及多种操作，用Java的数据类型来定义操作数据树的各个节点。 JDOM下载 jdom-2.0.4.jar下载： http://www.jdom.org/downloads/ 3.3.1 读取xml文件12345678910111213141516171819202122232425public void readXML() throws JDOMException, IOException &#123; //1.获取JDom的解析器 SAXBuilder saxBuilder = new SAXBuilder(); //2.加载xml Document document = saxBuilder.build(this.getClass().getClassLoader().getResourceAsStream("xml/languages" + ".xml")); //3.获取根元素 Element rootElement = document.getRootElement(); System.out.println("根元素名称:"+rootElement.getName()+" 属性cat:"+rootElement.getAttributeValue ("cat")); //4.获取根元素下的所有的子节点 List&lt;Element&gt; children = rootElement.getChildren(); for (int i = 0; i &lt;children.size() ; i++) &#123; Element element = children.get(i); System.out.println(element.getName()+" id:"+element.getAttribute("id").getValue()); List&lt;Element&gt; child = element.getChildren(); for (int j = 0; j &lt; child.size(); j++) &#123; System.out.println(child.get(j).getName()+"="+child.get(j).getText()); &#125; &#125;&#125; 3.3.2 创建xml文件123456789101112131415161718192021222324252627282930313233343536373839public void createXml() throws TransformerException, IOException &#123; //1.创建文档 Document document = new Document(); //2.添加跟节点 Element root = new Element("languages"); root.setAttribute("cat","it"); document.setRootElement(root); //3.添加子节点 Element lang = new Element("lang"); lang.setAttribute("id","1"); Element name = new Element("name"); name.setText("Java"); Element ide = new Element("ide"); ide.setText("Eclipse"); lang.addContent(name); lang.addContent(ide); root.addContent(lang); //输出// TransformerFactory factory = TransformerFactory.newInstance();// Transformer transformer = factory.newTransformer();// transformer.setOutputProperty(OutputKeys.ENCODING,"UTF-8");// transformer.setOutputProperty(OutputKeys.INDENT,"yes");// transformer.transform(new JDOMSource(document),new StreamResult(new FileWriter("newxml" +// ".xml"))); //输出 Format format = Format.getPrettyFormat(); format.setEncoding("UTF-8"); XMLOutputter out = new XMLOutputter(); out.setFormat(format); out.output(document,new FileWriter("newxml.xml")); &#125; 3.4 DOM4J​ dom4j的项目地址：http://sourceforge.net/projects/dom4j/?source=directory dom4j是一个简单的开源库，用于处理XML、 XPath和XSLT，它基于Java平台，使用Java的集合框架，全面集成了DOM，SAX和JAXP。 3.4.1 读取xml1234567891011121314151617181920212223242526public void readXml() throws DocumentException &#123; //1.说去SAXReader对象 SAXReader reader = new SAXReader(); //2.获取Document对象 Document document = reader.read(this.getClass().getClassLoader().getResourceAsStream("xml/languages.xml")); //3.获取根元素 Element rootElement = document.getRootElement(); System.out.println("根元素名称:"+rootElement.getName()); String cat = rootElement.attributeValue("cat"); System.out.println("属性为cat的值为:"+cat); System.out.println("-------------------------"); //4.获取其下的子元素 List&lt;Element&gt; elements = rootElement.elements(); for (int i = 0; i &lt; elements.size(); i++) &#123; Element element = elements.get(i); System.out.println("第"+i+"个元素的名称:"+element.getName()); System.out.println("属性id为:"+element.attributeValue("id")); List&lt;Element&gt; children = element.elements(); for (int j = 0; j &lt; children.size(); j++) &#123; Element ele = children.get(j); System.out.println(ele.getName()+"="+ele.getText()); &#125; System.out.println("-------------------------"); &#125;&#125; 3.4.2 创建xml12345678910111213141516171819202122232425262728293031public void createXml() throws IOException &#123; //1.获取文档 Document document = DocumentHelper.createDocument(); //2.创建跟节点 Element languages = DocumentHelper.createElement("languages"); languages.addAttribute("cat","it"); document.setRootElement(languages); //3.添加子节点 Element lang = languages.addElement("lang"); lang.addAttribute("id","1"); Element name = lang.addElement("name"); name.setText("Java"); Element ide = lang.addElement("ide"); ide.setText("Eclipse"); //输出 //输出到控制台 XMLWriter writer = new XMLWriter(); writer.write(document); //输出到文件 OutputFormat format = new OutputFormat(" ",true); XMLWriter out = new XMLWriter(new FileOutputStream("newxml.xml"),format); out.write(document);&#125; 3.5 digesterdigester原来为struts中解析xml的方式，由于其比较好，被apache单独拿出变为一个小型框架。 其使用的原理为sax。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十七)--JSP中的九个内置对象]]></title>
    <url>%2F2017%2F07%2F04%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81%E4%B8%83-JSP%E4%B8%AD%E7%9A%84%E4%B9%9D%E4%B8%AA%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[[TOC] 一、JSP运行原理 每个JSP 页面在第一次被访问时，WEB容器都会把请求交给JSP引擎（即一个Java程序）去处理。JSP引擎先将JSP翻译成一个_jspServlet(实质上也是一个servlet) ，然后按照servlet的调用方式进行调用。 由于JSP第一次访问时会翻译成servlet，所以第一次访问通常会比较慢，但第二次访问，JSP引擎如果发现JSP没有变化，就不再翻译，而是直接调用，所以程序的执行效率不会受到影响。 JSP引擎在调用JSP对应的_jspServlet时，会传递或创建9个与web开发相关的对象供_jspServlet使用。JSP技术的设计者为便于开发人员在编写JSP页面时获得这些web对象的引用，特意定义了9个相应的变量，开发人员在JSP页面中通过这些变量就可以快速获得这9大对象的引用。** 二、认识九个内置对象 NO. 内置对象 类型 1 pageContext javax.servlet.jsp.PageContext 2 request javax.servlet.http.HttpServletRequest 3 response javax.servlet.http.HttpServletResponse 4 session javax.servlet.http.HttpSession 5 application javax.servlet.ServletContext 6 config javax.servlet.ServletConfig 7 out javax.servlet.jsp.JspWriter 8 page java.lang.Object 9 exception java.lang.Throwable request，response，session，application，config这些对象在前面都已经作了详细的介绍，这里重点介绍一下剩下的pageContext对象，out对象，page对象。 三、内置对象使用说明3.1、page对象 page对象表示当前一个JSP页面，可以理解为一个对象本身，即：把一个JSP当作一个对象来看待。page对象在开发中几乎不用，了解一下即可 3.2、out对象 out对象用于向客户端发送文本数据。 out对象是通过调用pageContext对象的getOut方法返回的，其作用和用法与ServletResponse.getWriter方法返回的PrintWriter对象非常相似。 JSP页面中的out对象的类型为JspWriter，JspWriter相当于一种带缓存功能的PrintWriter，设置JSP页面的page指令的buffer属性可以调整它的缓存大小，甚至关闭它的缓存。 只有向out对象中写入了内容，且满足如下任何一个条件时，out对象才去调用ServletResponse.getWriter方法，并通过该方法返回的PrintWriter对象将out对象的缓冲区中的内容真正写入到Servlet引擎提供的缓冲区中： 设置page指令的buffer属性关闭了out对象的缓存功能 out对象的缓冲区已满 整个JSP页面结束 out对象的工作原理图 3.3、pageContext对象 pageContext对象是JSP技术中最重要的一个对象，它代表JSP页面的运行环境，这个对象不仅封装了对其它8大隐式对象的引用，它自身还是一个域对象(容器)，可以用来保存数据。并且，这个对象还封装了web开发中经常涉及到的一些常用操作，例如引入和跳转其它资源、检索其它域对象中的属性等。 3.4、通过pageContext获得其他对象 getException方法返回exception隐式对象 getPage方法返回page隐式对象 getRequest方法返回request隐式对象 getResponse方法返回response隐式对象 getServletConfig方法返回config隐式对象 getServletContext方法返回application隐式对象 getSession方法返回session隐式对象 getOut方法返回out隐式对象 3.5、pageContext封装其它8大内置对象的意义 如果在编程过程中，把pageContext对象传递给一个普通java对象，那么这个java对象将可以获取8大隐式对象，此时这个java对象就可以和浏览器交互了，此时这个java对象就成为了一个动态web资源了，这就是pageContext封装其它8大内置对象的意义，把pageContext传递给谁，谁就能成为一个动态web资源，那么什么情况下需要把pageContext传递给另外一个java类呢，什么情况下需要使用这种技术呢，在比较正规的开发中，jsp页面是不允许出现java代码的，如果jsp页面出现了java代码，那么就应该想办法把java代码移除掉，我们可以开发一个自定义标签来移除jsp页面上的java代码，首先围绕自定义标签写一个java类，jsp引擎在执行自定义标签的时候就会调用围绕自定义标签写的那个java类，在调用java类的时候就会把pageContext对象传递给这个java类，由于pageContext对象封装了对其它8大隐式对象的引用，因此在这个java类中就可以使用jsp页面中的8大隐式对象(request，response，config，application，exception，Session，page，out)了，pageContext对象在jsp自定义标签开发中特别重要。 3.6、pageContext作为域对象 pageContext对象可以作为容器来使用，因此可以将一些数据存储在pageContext对象中。 pageContext对象的常用方法 1234public void setAttribute(java.lang.String name,java.lang.Object value)public java.lang.Object getAttribute(java.lang.String name)public void removeAttribute(java.lang.String name)public java.lang.Object findAttribute(java.lang.String name) 重点介绍一下findAttribute方法，这个方法是用来查找各个域中的属性的，查看这个方法的API可以看到关于这个方法的描述： Searches for the named attribute in page, request, session (if valid), and application scope(s) in order and returns the value associated or null. 当要查找某个属性时，findAttribute方法按照查找顺序”page→request→session→application”在这四个对象中去查找，只要找到了就返回属性值，如果四个对象都没有找到要查找的属性，则返回一个null。 范例：使用pageContext的findAttribute方法查找属性值 12345678910111213141516171819202122232425262728293031323334 &lt;%@page contentType="text/html;charset=UTF-8"%&gt; &lt;%@page import="java.util.*"%&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;head&gt; &lt;title&gt;pageContext的findAttribute方法查找属性值&lt;/title&gt; &lt;/head&gt; &lt;% pageContext.setAttribute("name1", "孤傲苍狼"); request.setAttribute("name2", "白虎神皇"); session.setAttribute("name3", "玄天邪帝"); application.setAttribute("name4", "灭世魔尊");%&gt;&lt;% //使用pageContext的findAttribute方法查找属性，由于取得的值为Object类型，因此必须使用String强制向下转型，转换成String类型 //查找name1属性，按照顺序"page→request→session→application"在这四个对象中去查找 String refName1 = (String)pageContext.findAttribute("name1"); String refName2 = (String)pageContext.findAttribute("name2"); String refName3 = (String)pageContext.findAttribute("name3"); String refName4 = (String)pageContext.findAttribute("name4"); String refName5 = (String)pageContext.findAttribute("name5");//查找一个不存在的属性%&gt;&lt;h1&gt;pageContext.findAttribute方法查找到的属性值：&lt;/h1&gt;&lt;h3&gt;pageContext对象的name1属性：&lt;%=refName1%&gt;&lt;/h3&gt;&lt;h3&gt;request对象的name2属性：&lt;%=refName2%&gt;&lt;/h3&gt;&lt;h3&gt;session对象的name3属性：&lt;%=refName3%&gt;&lt;/h3&gt;&lt;h3&gt;application对象的name4属性：&lt;%=refName4%&gt;&lt;/h3&gt;&lt;h3&gt;查找不存在的name5属性：&lt;%=refName5%&gt;&lt;/h3&gt;&lt;hr/&gt;&lt;h1&gt;使用EL表达式进行输出：&lt;/h1&gt;&lt;h3&gt;pageContext对象的name1属性：$&#123;name1&#125;&lt;/h3&gt;&lt;h3&gt;request对象的name2属性：$&#123;name2&#125;&lt;/h3&gt;&lt;h3&gt;session对象的name3属性：$&#123;name3&#125;&lt;/h3&gt;&lt;h3&gt;application对象的name4属性：$&#123;name4&#125;&lt;/h3&gt;&lt;h3&gt;不存在的name5属性：$&#123;name5&#125;&lt;/h3&gt; 运行结果： EL表达式语句在执行时，会调用pageContext.findAttribute方法，用标识符为关键字，分别从page、request、 session、application四个域中查找相应的对象，找到则返回相应对象，找不到则返回”” （注意，不是null，而是空字符串）。 pageContext对象中封装了访问其它域的方法 123public java.lang.Object getAttribute(java.lang.String name,int scope)public void setAttribute(java.lang.String name, java.lang.Object value,int scope)public void removeAttribute(java.lang.String name,int scope) 代表各个域的常量 1234PageContext.APPLICATION_SCOPEPageContext.SESSION_SCOPEPageContext.REQUEST_SCOPEPageContext.PAGE_SCOPE 范例：pageContext访问其它域 123456789101112131415161718192021 &lt;%@page contentType="text/html;charset=UTF-8"%&gt; &lt;%@page import="java.util.*"%&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;head&gt; &lt;title&gt;pageContext访问其它域&lt;/title&gt; &lt;/head&gt; &lt;% //此时相当于往session对象中存放了一个name属性，等价于 session.setAttribute("name","孤傲苍狼"); pageContext.setAttribute("name","孤傲苍狼",PageContext.SESSION_SCOPE);%&gt;&lt;% //取得session对象的属性，使用pageContext对象获取 String refName1 = (String)pageContext.getAttribute("name",PageContext.SESSION_SCOPE); //由于取得的值为Object类型，因此必须使用String强制向下转型，转换成String类型 String refName2 = (String)session.getAttribute("name"); %&gt;&lt;h1&gt;取出存放在session对象中的属性值：&lt;/h1&gt;&lt;p&gt;第一种做法：使用pageContext.getAttribute("attributeName",PageContext.SESSION_SCOPE);去取出session对象中值&lt;/p&gt;&lt;h3&gt;姓名：&lt;%=refName1%&gt;&lt;/h3&gt;&lt;p&gt;第二种做法：使用session.getAttribute("attributeName");去取出session对象中值&lt;/p&gt;&lt;h3&gt;姓名：&lt;%=refName2%&gt;&lt;/h3&gt; 3.7、PageContext引入和跳转到其他资源 PageContext类中定义了一个forward方法(用来跳转页面)和两个include方法(用来引入页面)来分别简化和替代RequestDispatcher.forward方法和include方法。 方法接收的资源如果以“/”开头， “/”代表当前web应用。 范例：使用pageContext的forward方法跳转到其他页面 12345678910111213 &lt;%@page contentType="text/html;charset=UTF-8"%&gt; &lt;%@page import="java.util.*"%&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;head&gt; &lt;title&gt;使用pageContext的forward方法跳转页面&lt;/title&gt; &lt;/head&gt; &lt;% //使用pageContext的forward方法跳转到pageContextDemo05.jsp页面，/代表了当前的web应用 pageContext.forward("/pageContextDemo05.jsp"); //使用pageContext.forward(relativeUrlPath)替代RequestDispatcher.forward(relativeUrlPath) //使用RequestDispatcher的forward方法实现的跳转方式 //pageContext.getRequest().getRequestDispatcher("/pageContextDemo05.jsp").forward(request, response);%&gt; 运行结果如下： 11 pageContext.forward(&quot;/pageContextDemo05.jsp&quot;); 这种写法是用来简化和替代pageContext.getRequest().getRequestDispatcher(“/pageContextDemo05.jsp”).forward(request, response);这种写法的。在实际开发中，使用pageContext.forward(relativeUrlPath)方法跳转页面用得不多，主要是因为要在Jsp页面中嵌套java代码，所以这种做法简单了解一下即可，在开发中，要想从一个Jsp页面采用服务器端跳转的方式跳转到另一个Jsp页面，那么一般会使用标签，标签用于把请求转发给另外一个资源。 范例：使用pageContext的include方法引入资源 123456789101112131415161718 &lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;head&gt; &lt;title&gt;使用pageContext的include方法引入资源&lt;/title&gt; &lt;/head&gt; &lt;% pageContext.include("/jspfragments/head.jsp"); %&gt; 使用pageContext的include方法引入资源&lt;% pageContext.include("/jspfragments/foot.jsp");%&gt;&lt;hr/&gt;&lt;%--&lt;jsp:include page="/jspfragments/head.jsp"/&gt;使用jsp:include标签引入资源&lt;jsp:include page="/jspfragments/foot.jsp"/&gt;--%&gt; 运行结果： 在实际开发中，使用pageContext的include方法引入页面这种做法也很少用，一般都使用jsp:include标签引入资源，因此这种做法了解一下即可。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十五)--JSP基础语法]]></title>
    <url>%2F2017%2F07%2F04%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81%E4%BA%94-JSP%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[TOC] 任何语言都有自己的语法，JAVA中有，JSP虽然是在JAVA上的一种应用，但是依然有其自己扩充的语法，而且在JSP中，所有的JAVA语句都可以使用。 一、JSP模版元素 JSP页面中的HTML内容称之为JSP模版元素。 JSP模版元素定义了网页的基本骨架，即定义了页面的结构和外观。 二、JSP表达式 JSP脚本表达式（expression）用于将程序数据输出到客户端​ 语法：&lt;%= 变量或表达式 %&gt;​ 举例：输出当前系统时间: 1&lt;%= new java.util.Date() %&gt; JSP引擎在翻译脚本表达式时，会将程序数据转成字符串，然后在相应位置用out.print(…) 将数据输给客户端。 JSP脚本表达式中的变量或表达式后面不能有分号（;）。 三、JSP脚本片断 JSP脚本片断(scriptlet)用于在JSP页面中编写多行Java代码。语法： &lt;% 多行java代码 %&gt; 在&lt;% %&gt;中可以定义变量、编写语句，不能定义方法。 范例：在Scriptlet中定义变量、编写语句 123456789&lt;% int sum=0;//声明变量 /*编写语句*/ for (int i=1;i&lt;=100;i++)&#123; sum+=i; &#125; out.println("&lt;h1&gt;Sum="+sum+"&lt;/h1&gt;");%&gt; 注意事项： JSP脚本片断中只能出现java代码，不能出现其它模板元素， JSP引擎在翻译JSP页面中，会将JSP脚本片断中的Java代码将被原封不动地放到Servlet的_jspService方法中。 JSP脚本片断中的Java代码必须严格遵循Java语法，例如，每执行语句后面必须用分号（;）结束。 在一个JSP页面中可以有多个脚本片断，在两个或多个脚本片断之间可以嵌入文本、HTML标记和其他JSP元素。 ​ 举例： 123456789&lt;% int x = 10; out.println(x);%&gt;&lt;p&gt;这是JSP页面文本&lt;/p&gt;&lt;% int y = 20; out.println(y);%&gt; 多个脚本片断中的代码可以相互访问，犹如将所有的代码放在一对&lt;%%&gt;之中的情况。如：out.println(x); 单个脚本片断中的Java语句可以是不完整的，但是，多个脚本片断组合后的结果必须是完整的Java语句，例如： 12345678&lt;% for (int i=1; i&lt;5; i++) &#123;%&gt; &lt;H1&gt;http://localhost:8080/JavaWeb_Jsp_Study_20140603/&lt;/H1&gt;&lt;% &#125;%&gt; 四、JSP声明 JSP页面中编写的所有代码，默认会翻译到servlet的service方法中， 而Jsp声明中的java代码被翻译到_jspService方法的外面。语法： &lt;%！ java代码 %&gt; 所以，JSP声明可用于定义JSP页面转换成的Servlet程序的静态代码块、成员变量和方法 。 多个静态代码块、变量和函数可以定义在一个JSP声明中，也可以分别单独定义在多个JSP声明中。 JSP隐式对象的作用范围仅限于Servlet的_jspService方法，所以在JSP声明中不能使用这些隐式对象。 JSP声明案例： 1234567891011121314151617&lt;%!static &#123; System.out.println("loading Servlet!"); &#125;private int globalVar = 0;public void jspInit()&#123; System.out.println("initializing jsp!");&#125;%&gt;&lt;%!public void jspDestroy()&#123; System.out.println("destroying jsp!");&#125;%&gt; 五、JSP注释在JSP中，注释有两大类： 显式注释：直接使用HTML风格的注释：&lt;!- - **注释内容**- -&gt; 隐式注释：直接使用JAVA的注释：//、/***……*/** **JSP自己的注释：&lt;%- - 注释内容- -%&gt;** 这三种注释的区别 1234567891011&lt;!--这个注释可以看见--&gt;&lt;% //JAVA中的单行注释 /* JAVA中的多行注释 */%&gt;&lt;%--JSP自己的注释--%&gt; HTML的注释在浏览器中查看源文件的时候是可以看得到的，而JAVA注释和JSP注释在浏览器中查看源文件时是看不到注释的内容的，这就是这三种注释的区别。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十四)--JSP原理]]></title>
    <url>%2F2017%2F07%2F04%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81%E5%9B%9B-JSP%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[[TOC] 一、什么是JSP？ JSP全称是Java Server Pages，它和servle技术一样，都是SUN公司定义的一种用于开发动态web资源的技术。 JSP这门技术的最大的特点在于，写jsp就像在写html，但它相比html而言，html只能为用户提供静态数据，而Jsp技术允许在页面中嵌套java代码，为用户提供动态数据。 二、JSP原理2.1、Web服务器是如何调用并执行一个jsp页面的？ 浏览器向服务器发请求，不管访问的是什么资源，其实都是在访问Servlet，所以当访问一个jsp页面时，其实也是在访问一个Servlet，服务器在执行jsp的时候，首先把jsp翻译成一个Servlet，所以我们访问jsp时，其实不是在访问jsp，而是在访问jsp翻译过后的那个Servlet，例如下面的代码： 3.jsp 123456789101112131415161718192021222324&lt;%-- Created by IntelliJ IDEA. User: wuqinghua Date: 17/7/4 Time: 上午11:20 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";%&gt;&lt;html&gt;&lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% out.print("Hello Jsp"); %&gt;&lt;/body&gt;&lt;/html&gt; 当我们通过浏览器访问3.jsp时，服务器首先将index.jsp翻译成一个_3_jsp.class，在Tomcat服务器的work\Catalina\localhost\项目名\org\apache\jsp目录下可以看到_3_jsp.class的源代码文件index_jsp.java，index_jsp.java的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150/* * Generated by the Jasper component of Apache Tomcat * Version: Apache Tomcat/8.0.41 * Generated at: 2017-07-04 03:25:11 UTC * Note: The last modified time of this file was set to * the last modified time of the source file after * generation to assist with modification tracking. */package org.apache.jsp;import javax.servlet.*;import javax.servlet.http.*;import javax.servlet.jsp.*;public final class _3_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent, org.apache.jasper.runtime.JspSourceImports &#123; private static final javax.servlet.jsp.JspFactory _jspxFactory = javax.servlet.jsp.JspFactory.getDefaultFactory(); private static java.util.Map&lt;java.lang.String,java.lang.Long&gt; _jspx_dependants; private static final java.util.Set&lt;java.lang.String&gt; _jspx_imports_packages; private static final java.util.Set&lt;java.lang.String&gt; _jspx_imports_classes; static &#123; _jspx_imports_packages = new java.util.HashSet&lt;&gt;(); _jspx_imports_packages.add("javax.servlet"); _jspx_imports_packages.add("javax.servlet.http"); _jspx_imports_packages.add("javax.servlet.jsp"); _jspx_imports_classes = null; &#125; private volatile javax.el.ExpressionFactory _el_expressionfactory; private volatile org.apache.tomcat.InstanceManager _jsp_instancemanager; public java.util.Map&lt;java.lang.String,java.lang.Long&gt; getDependants() &#123; return _jspx_dependants; &#125; public java.util.Set&lt;java.lang.String&gt; getPackageImports() &#123; return _jspx_imports_packages; &#125; public java.util.Set&lt;java.lang.String&gt; getClassImports() &#123; return _jspx_imports_classes; &#125; public javax.el.ExpressionFactory _jsp_getExpressionFactory() &#123; if (_el_expressionfactory == null) &#123; synchronized (this) &#123; if (_el_expressionfactory == null) &#123; _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory(); &#125; &#125; &#125; return _el_expressionfactory; &#125; public org.apache.tomcat.InstanceManager _jsp_getInstanceManager() &#123; if (_jsp_instancemanager == null) &#123; synchronized (this) &#123; if (_jsp_instancemanager == null) &#123; _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig()); &#125; &#125; &#125; return _jsp_instancemanager; &#125; public void _jspInit() &#123; &#125; public void _jspDestroy() &#123; &#125; public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException &#123;final java.lang.String _jspx_method = request.getMethod();if (!"GET".equals(_jspx_method) &amp;&amp; !"POST".equals(_jspx_method) &amp;&amp; !"HEAD".equals(_jspx_method) &amp;&amp; !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) &#123;response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSPs only permit GET POST or HEAD");return;&#125; final javax.servlet.jsp.PageContext pageContext; javax.servlet.http.HttpSession session = null; final javax.servlet.ServletContext application; final javax.servlet.ServletConfig config; javax.servlet.jsp.JspWriter out = null; final java.lang.Object page = this; javax.servlet.jsp.JspWriter _jspx_out = null; javax.servlet.jsp.PageContext _jspx_page_context = null; try &#123; response.setContentType("text/html;charset=UTF-8"); pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; out.write('\n'); out.write('\n'); String path = request.getContextPath(); String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/"; out.write("\n"); out.write("&lt;html&gt;\n"); out.write("&lt;head&gt;\n"); out.write(" &lt;base href=\""); out.print(basePath); out.write("\"&gt;\n"); out.write(" &lt;title&gt;Title&lt;/title&gt;\n"); out.write("&lt;/head&gt;\n"); out.write("&lt;body&gt;\n"); out.write(" "); out.print("Hello Jsp"); out.write("\n"); out.write("&lt;/body&gt;\n"); out.write("&lt;/html&gt;\n"); &#125; catch (java.lang.Throwable t) &#123; if (!(t instanceof javax.servlet.jsp.SkipPageException))&#123; out = _jspx_out; if (out != null &amp;&amp; out.getBufferSize() != 0) try &#123; if (response.isCommitted()) &#123; out.flush(); &#125; else &#123; out.clearBuffer(); &#125; &#125; catch (java.io.IOException e) &#123;&#125; if (_jspx_page_context != null) _jspx_page_context.handlePageException(t); else throw new ServletException(t); &#125; &#125; finally &#123; _jspxFactory.releasePageContext(_jspx_page_context); &#125; &#125;&#125; 2.3、Jsp页面中的java代码服务器是如何执行的？ 在jsp中编写的java代码会被翻译到_jspService方法中去，当执行_jspService方法处理请求时，就会执行在jsp编写的java代码了，所以Jsp页面中的java代码服务器是通过调用_jspService方法处理请求时执行的。 2.4、Web服务器在调用jsp时，会给jsp提供一些什么java对象？ 查看_jspService方法可以看到，Web服务器在调用jsp时，会给Jsp提供如下的8个java对象 12345678PageContext pageContext;HttpSession session;ServletContext application;ServletConfig config;JspWriter out;Object page = this;HttpServletRequest request, HttpServletResponse response 其中page对象，request和response已经完成了实例化，而其它5个没有实例化的对象通过下面的方式实例化 12345pageContext = _jspxFactory.getPageContext(this, request, response,null, true, 8192, true);application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); 8个java对象可以直接使用 12345678910111213&lt;% session.setAttribute("name", "session对象");//使用session对象，设置session对象属性 out.print(session.getAttribute("name") + "&lt;br /&gt;");//获取session对象的属性 pageContext.setAttribute("name", "pageContext对象");//使用pageContext对象 out.print(pageContext.getAttribute("name") + "&lt;br /&gt;");//获取pageContext对象 application.setAttribute("name", "application对象");//使用application对象,设置application对象的属性 out.print(application.getAttribute("name") + "&lt;br/&gt;");//获取application对象的属性 out.print("Hello Jsp" + "&lt;br/&gt;");//使用out对象 out.print("服务器调用index.jsp页面时翻译成的类的名字是：" + page.getClass() + "&lt;br/&gt;");//使用page对象 out.print("处理请求的Servlet的名字是：" + config.getServletName().toString() + "&lt;br/&gt;");//使用config对象 out.print(response.getContentType() + "&lt;br/&gt;");//使用response对象 out.print(request.getContextPath() + "&lt;br/&gt;");//使用request对象%&gt; 运行结果如下： 2.5、Jsp最佳实践 Jsp最佳实践就是jsp技术在开发中该怎么去用。 不管是JSP还是Servlet，虽然都可以用于开发动态web资源。但由于这2门技术各自的特点，在长期的软件实践中，人们逐渐把servlet作为web应用中的控制器组件来使用，而把JSP技术作为数据显示模板来使用。其原因为，程序的数据通常要美化后再输出：让jsp既用java代码产生动态数据，又做美化会导致页面难以维护。让servlet既产生数据，又在里面嵌套html代码美化数据，同样也会导致程序可读性差，难以维护。因此最好的办法就是根据这两门技术的特点，让它们各自负责各的，servlet只负责响应请求产生数据，并把数据通过转发技术带给jsp，数据的显示jsp来做。 2.6、Tomcat服务器的执行流程 第一次执行： 客户端通过电脑连接服务器，因为是请求是动态的，所以所有的请求交给WEB容器来处理 在容器中找到需要执行的*.jsp文件 之后.jsp文件通过转换变为.java文件 .java文件经过编译后，形成.class文件 最终服务器要执行形成的*.class文件 第二次执行： 因为已经存在了*.class文件，所以不在需要转换和编译的过程 修改后执行： ​ 1.源文件已经被修改过了，所以需要重新转换，重新编译。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十三)--使用session防止表单重复提交]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81%E4%B8%89-%E4%BD%BF%E7%94%A8session%E9%98%B2%E6%AD%A2%E8%A1%A8%E5%8D%95%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[[TOC] 在平时开发中，如果网速比较慢的情况下，用户提交表单后，发现服务器半天都没有响应，那么用户可能会以为是自己没有提交表单，就会再点击提交按钮重复提交表单，我们在开发中必须防止表单重复提交。 一、表单重复提交的常见应用场景有如下的form.jsp页面 12345678910111213141516171819&lt;%-- Created by IntelliJ IDEA. User: wuqinghua Date: 17/7/4 Time: 上午8:33 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Form表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="$&#123;pageContext.request.contextPath&#125;/repeatSubmitServlet" method="post"&gt; 用户名：&lt;input type="text" name="username" /&gt; &lt;input type="submit" value="提交" id="submit" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 后台servlet 12345678910111213141516171819202122232425262728package org.wuqinghua.java.ch06;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.concurrent.TimeUnit;/** * Created by wuqinghua on 17/7/4. */@WebServlet(urlPatterns = "/repeatSubmitServlet")public class RepeatSubmitServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding("UTF-8"); String username = req.getParameter("username"); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("向数据库中添加数据："+username); &#125;&#125; 如果没有进行form表单重复提交处理，那么在网络延迟的情况下下面的操作将会导致form表单重复提交多次 1.1、场景一：在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交 演示动画如下所示： 1.2、场景二：表单提交后用户点击【刷新】按钮导致表单重复提交演示动画如下所示： 点击浏览器的刷新按钮，就是把浏览器上次做的事情再做一次，因为这样也会导致表单重复提交。 1.3、场景三：用户提交表单后，点击浏览器的【后退】按钮回退到表单页面后进行再次提交演示动画如下所示： 二、利用JavaScript防止表单重复提交 既然存在上述所说的表单重复提交问题，那么我们就要想办法解决，比较常用的方法是采用JavaScript来防止表单重复提交，具体做法如下： 修改form.jsp页面，添加如下的JavaScript代码来防止表单重复提交 12345678910111213141516171819202122232425262728293031&lt;%-- Created by IntelliJ IDEA. User: wuqinghua Date: 17/7/4 Time: 上午8:33 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Form表单&lt;/title&gt; &lt;script&gt; var isCommitted = false;//表单 function doSubmit()&#123; if (!isCommitted)&#123; isCommitted=true; return true; &#125;else&#123; return false; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="$&#123;pageContext.request.contextPath&#125;/repeatSubmitServlet" method="post" onsubmit="return doSubmit()"&gt; 用户名：&lt;input type="text" name="username" /&gt; &lt;input type="submit" value="提交" id="submit" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 我们看看使用了JavaScript来防止表单提交重复是否可以成功，运行效果如下： 可以看到，针对”在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交“这个应用场景，使用JavaScript是可以解决这个问题的，解决的做法就是“用JavaScript控制Form表单只能提交一次“。 除了用这种方式之外，经常见的另一种方式就是表单提交之后，将提交按钮设置为不可用，让用户没有机会点击第二次提交按钮，代码如下： 12345678function dosubmit()&#123; //获取表单提交按钮 var btnSubmit = document.getElementById("submit"); //将表单提交按钮设置为不可用，这样就可以避免用户再次点击提交按钮 btnSubmit.disabled= "disabled"; //返回true让表单可以正常提交 return true;&#125; 运行效果如下： 另外还有一种做法就是提交表单后，将提交按钮隐藏起来，这种做法和将提交按钮设置为不可用是差不多的，个人觉得将提交按钮隐藏影响到页面布局的美观，并且可能会让用户误以为是bug(怎么我一点击按钮，按钮就不见了呢？用户可能会有这样的疑问)，我个人在开发中用得比较多的是表单提交后，将提交按钮设置为不可用，反正使用JavaScript防止表单重复提交的做法都是差不多的，目的都是让表单只能提交一次，这样就可以做到表单不重复提交了。 使用JavaScript防止表单重复提交的做法只对上述提交到导致表单重复提交的三种场景中的【场景一】有效，而对于【场景二】和【场景三】是没有用，依然无法解决表单重复提交问题。 三、利用Session防止表单重复提交 对于【场景二】和【场景三】导致表单重复提交的问题，既然客户端无法解决，那么就在服务器端解决，在服务器端解决就需要用到session了。 具体的做法：在服务器端生成一个唯一的随机标识号，专业术语称为Token(令牌)，同时在当前用户的Session域中保存这个Token。然后将Token发送到客户端的Form表单中，在Form表单中使用隐藏域来存储这个Token，表单提交的时候连同这个Token一起提交到服务器端，然后在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致，如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。如果相同则处理表单提交，处理完后清除当前用户的Session域中存储的标识号。 在下列情况下，服务器程序将拒绝处理用户提交的表单请求： 存储Session域中的Token(令牌)与表单提交的Token(令牌)不同。 当前用户的Session中不存在Token(令牌)。 用户提交的表单数据中没有Token(令牌)。 看具体的范例： 1.创建FormServlet，用于生成Token(令牌)和跳转到form.jsp页面 1234567891011121314151617181920&lt;%-- Created by IntelliJ IDEA. User: wuqinghua Date: 17/7/4 Time: 上午8:33 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Form表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="$&#123;pageContext.request.contextPath&#125;/repeatSubmitServlet" method="post"&gt; 用户名：&lt;input type="text" name="username" /&gt; &lt;input type="hidden" name="token" value="$&#123;token&#125;"/&gt; &lt;input type="submit" value="提交" id="submit" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package org.wuqinghua.java.ch06;import org.wuqinghua.java.repeat.TokenProccessor;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.concurrent.TimeUnit;/** * Created by wuqinghua on 17/7/4. */@WebServlet(urlPatterns = "/repeatSubmitServlet")public class RepeatSubmitServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String token = TokenProccessor.getInstance().makeToken(); req.getSession().setAttribute("token", token); req.getRequestDispatcher("form.jsp").forward(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding("UTF-8"); if (!isRepeat(req)) &#123; String username = req.getParameter("username"); System.out.println("向数据库中添加数据：" + username); &#125; &#125; private boolean isRepeat(HttpServletRequest req) &#123; String token = req.getParameter("token"); if (token == null || "".equals(token)) &#123; return true; &#125; String sessionToken = (String) req.getSession().getAttribute("token"); if (sessionToken == null || "".equals(sessionToken)) &#123; return true; &#125; if (!token.equals(sessionToken)) &#123; return true; &#125; req.getSession().removeAttribute("token"); return false; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package org.wuqinghua.java.ch06;import org.wuqinghua.java.repeat.TokenProccessor;import sun.misc.BASE64Encoder;import sun.plugin2.message.Message;import javax.xml.crypto.dsig.DigestMethod;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Base64;import java.util.Random;/** * Created by wuqinghua on 17/7/4. */public class TokenProcessor &#123; /** * 单例设计模式 * 1.把类的构造方法设计为私有的 * 2.自己创建一个类的对象 * 3.对外提供一个公共的方法，返回类的对象 */ private static TokenProccessor instance = new TokenProccessor(); private TokenProcessor()&#123;&#125; public static TokenProccessor getInstance()&#123; return instance; &#125; public String makeToken()&#123; String token = (System.currentTimeMillis()+new Random().nextInt(999999999))+""; try &#123; MessageDigest md5 = MessageDigest.getInstance("md5"); byte[] digest = md5.digest(token.getBytes()); BASE64Encoder base64Encoder = new BASE64Encoder(); return base64Encoder.encode(digest); &#125; catch (NoSuchAlgorithmException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 首先访问FormServlet，在FormServlet中生成Token之后再重定向到form.jsp页面，这次是在服务器端处理表单重复提交的，运行效果如下： 从运行效果中可以看到，通过这种方式处理表单重复提交，可以解决上述的场景二和场景三中出现的表单重复提交问题。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十二)--Session]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81%E4%BA%8C-Session%2F</url>
    <content type="text"><![CDATA[[TOC] 一、Session简单介绍 在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。 二、Session和Cookie的主要区别 Cookie是把用户的数据写给用户的浏览器。 Session技术把用户的数据写到用户独占的session中。 Session对象由服务器创建，开发人员可以调用request对象的getSession方法得到session对象。 三、session实现原理3.1、服务器是如何实现一个session为一个用户浏览器服务的？ 服务器创建session出来后，会把session的id号，以cookie的形式回写给客户机，这样，只要客户机的浏览器不关，再去访问服务器时，都会带着session的id号去，服务器发现客户机浏览器带session id过来了，就会使用内存中与之对应的session为之服务。可以用如下的代码证明： 123456789101112131415161718192021222324252627282930313233343536package org.wuqinghua.java.ch03;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/sessionDemo01")public class SessionDemo01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding("UTF-8"); resp.setContentType("text/html;charset=UTF-8"); HttpSession session = req.getSession();//获取session //将数据存储进去 session.setAttribute("data","孤傲苍狼"); //获取session的id String sessionId = session.getId(); //判断session是否为新的 if(session.isNew())&#123; resp.getWriter().print("session创建成功！sessionId为:"+sessionId); &#125;else&#123; resp.getWriter().print("服务器已经存在该session了,sessionId为:"+sessionId); &#125; &#125;&#125; 第一次访问时，服务器会创建一个新的sesion，并且把session的Id以cookie的形式发送给客户端浏览器，如下图所示： 点击刷新按钮，再次请求服务器，此时就可以看到浏览器再请求服务器时，会把存储到cookie中的session的Id一起传递到服务器端了，如下图所示： 我猜想request.getSession()方法内部新创建了Session之后一定是做了如下的处理 1234567//获取session的IdString sessionId = session.getId();//将session的Id存储到名字为JSESSIONID的cookie中Cookie cookie = new Cookie("JSESSIONID", sessionId);//设置cookie的有效路径cookie.setPath(request.getContextPath());response.addCookie(cookie); 四、浏览器禁用Cookie后的session处理4.1、IE8禁用cookie1 工具-&gt;internet选项-&gt;隐私-&gt;设置-&gt;将滑轴拉到最顶上（阻止所有cookies） 4.2、解决方案：URL重写 response.encodeRedirectURL(java.lang.String url) 用于对sendRedirect方法后的url地址进行重写。 response.encodeURL(java.lang.String url)用于对表单action和超链接的url地址进行重写 4.3、范例：禁用Cookie后servlet共享Session中的数据IndexServlet 12345678910111213141516171819202122232425262728293031323334353637package org.wuqinghua.java.ch03;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.Map;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/index")public class IndexServlet extends HttpServlet&#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding("UTF-8"); resp.setContentType("text/html;charset=UTF-8"); PrintWriter out = resp.getWriter(); //创建session req.getSession(); out.print("本网站有如下图书:&lt;br /&gt;"); Map&lt;String,Book&gt; books = DB.getAll(); for (Map.Entry&lt;String,Book&gt; book: books.entrySet()) &#123; Book b = book.getValue(); String url = req.getContextPath()+"/buyServlet?id="+b.getId(); url = resp.encodeURL(url);//对于表单的action和超链接使用此方法重写 out.print(b.getName()+"&lt;a href='"+url+"'&gt;购买&lt;/a&gt;&lt;br /&gt;"); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829package org.wuqinghua.java.ch03;import java.util.HashMap;import java.util.Map;import java.util.StringJoiner;/** * Created by wuqinghua on 17/6/30. * 模拟数据库 */public class DB &#123; private static Map&lt;String, Book&gt; map = new HashMap&lt;&gt;(); static &#123; map.put("1", new Book("1", "javaweb开发")); map.put("2", new Book("2", "spring开发")); map.put("3", new Book("3", "hibernate开发")); map.put("4", new Book("4", "struts开发")); map.put("5", new Book("5", "ajax开发")); &#125; public static Map&lt;String,Book&gt; getAll()&#123; return map; &#125; public static Book get(String id)&#123; return map.get(id); &#125;&#125; 123456789101112131415161718192021222324252627282930313233package org.wuqinghua.java.ch03;/** * Created by wuqinghua on 17/6/30. */public class Book &#123; private String id; private String name; public Book() &#123; &#125; public Book(String id, String name) &#123; this.id = id; this.name = name; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package org.wuqinghua.java.ch03;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/buyServlet")public class BuyServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String id = req.getParameter("id"); Book book = DB.get(id);//得到想要购买的书 HttpSession session = req.getSession(); List&lt;Book&gt; books = (List&lt;Book&gt;) session.getAttribute("books"); if(books==null)&#123; books = new ArrayList&lt;&gt;(); session.setAttribute("books",books); &#125; books.add(book); String url = resp.encodeRedirectURL(req.getContextPath()+"/listCartServlet"); System.out.println(url); resp.sendRedirect(url); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940package org.wuqinghua.java.ch03;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;import java.io.PrintWriter;import java.util.List;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/listCartServlet")public class ListCartServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding("UTF-8"); resp.setContentType("text/html;charset=UTF-8"); PrintWriter out = resp.getWriter(); HttpSession session = req.getSession(); List&lt;Book&gt; books = (List&lt;Book&gt;) session.getAttribute("books"); if(books==null || books.size()==0)&#123; out.print("对不起，您没有购买任何产品。"); return; &#125; //显示用户的购买纪录 out.write("您买过如下产品:&lt;br /&gt;"); for (Book book: books) &#123; out.write(book.getName()+"&lt;br /&gt;"); &#125; &#125;&#125; 在禁用了cookie的IE8下的运行效果如下： 通过查看IndexServlet生成的html代码可以看到，每一个超链接后面都带上了session的Id，如下所示 12345本网站有如下书：&lt;br/&gt;javaweb开发 &lt;a href='/JavaWeb_Session_Study_20140720/servlet/BuyServlet;jsessionid=96BDFB9D87A08D5AB1EAA2537CDE2DB2?id=1'&gt;购买&lt;/a&gt;&lt;br/&gt;spring开发 &lt;a href='/JavaWeb_Session_Study_20140720/servlet/BuyServlet;jsessionid=96BDFB9D87A08D5AB1EAA2537CDE2DB2?id=2'&gt;购买&lt;/a&gt;&lt;br/&gt;hibernate开发 &lt;a href='/JavaWeb_Session_Study_20140720/servlet/BuyServlet;jsessionid=96BDFB9D87A08D5AB1EAA2537CDE2DB2?id=3'&gt;购买&lt;/a&gt;&lt;br/&gt;struts开发 &lt;a href='/JavaWeb_Session_Study_20140720/servlet/BuyServlet;jsessionid=96BDFB9D87A08D5AB1EAA2537CDE2DB2?id=4'&gt;购买&lt;/a&gt;&lt;br/&gt;ajax开发 &lt;a href='/JavaWeb_Session_Study_20140720/servlet/BuyServlet;jsessionid=96BDFB9D87A08D5AB1EAA2537CDE2DB2?id=5'&gt;购买&lt;/a&gt;&lt;br/&gt; 所以，当浏览器禁用了cookie后，就可以用URL重写这种解决方案解决Session数据共享问题。而且response. encodeRedirectURL(java.lang.String url) 和response. encodeURL(java.lang.String url)是两个非常智能的方法，当检测到浏览器没有禁用cookie时，那么就不进行URL重写了。我们在没有禁用cookie的火狐浏览器下访问，效果如下： 从演示动画中可以看到，浏览器第一次访问时，服务器创建Session，然后将Session的Id以Cookie的形式发送回给浏览器，response. encodeURL(java.lang.String url)方法也将URL进行了重写，当点击刷新按钮第二次访问，由于火狐浏览器没有禁用cookie，所以第二次访问时带上了cookie，此时服务器就可以知道当前的客户端浏览器并没有禁用cookie，那么就通知response. encodeURL(java.lang.String url)方法不用将URL进行重写了。 五、session对象的创建和销毁时机5.1、session对象的创建时机 在程序中第一次调用request.getSession()方法时就会创建一个新的Session，可以用isNew()方法来判断Session是不是新创建的 范例：创建session 12345678910//使用request对象的getSession()获取session，如果session不存在则创建一个HttpSession session = request.getSession();//获取session的IdString sessionId = session.getId();//判断session是不是新创建的if (session.isNew()) &#123; response.getWriter().print("session创建成功，session的id是："+sessionId);&#125;else &#123; response.getWriter().print("服务器已经存在session，session的id是："+sessionId);&#125; 5.2、session对象的销毁时机 session对象默认30分钟没有使用，则服务器会自动销毁session，在web.xml文件中可以手工配置session的失效时间，例如： 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; &lt;display-name&gt;&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 设置Session的有效时间:以分钟为单位--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt; 当需要在程序中手动设置Session失效时，可以手工调用session.invalidate方法，摧毁session。 123 HttpSession session = request.getSession();//手工调用session.invalidate方法，摧毁session session.invalidate();]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十一)--使用Cookie进行会话管理]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81%E4%B8%80-%E4%BD%BF%E7%94%A8Cookie%E8%BF%9B%E8%A1%8C%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[[TOC] 一、会话的概念 会话可简单理解为：用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。 有状态会话：一个同学来过教室，下次再来教室，我们会知道这个同学曾经来过，这称之为有状态会话。 二、会话过程中要解决的一些问题？ 每个用户在使用浏览器与服务器进行会话的过程中，不可避免各自会产生一些数据，程序要想办法为每个用户保存这些数据。 三、保存会话数据的两种技术3.1、Cookie Cookie是客户端技术，程序把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。这样，web资源处理的就是用户各自的数据了。 3.2、Session Session是服务器端技术，利用这个技术，服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象，由于session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户再去访问服务器中的其它web资源时，其它web资源再从用户各自的session中取出数据为用户服务。 四、Java提供的操作Cookie的API Java中的javax.servlet.http.Cookie类用于创建一个Cookie Cookie类的主要方法 No. 方法 类型 描述 1 Cookie(String name, String value) 构造方法 实例化Cookie对象，传入cooke名称和cookie的值 2 public String getName() 普通方法 取得Cookie的名字 3 public String getValue() 普通方法 取得Cookie的值 4 public void setValue(String newValue) 普通方法 设置Cookie的值 5 public void setMaxAge(int expiry) 普通方法 设置Cookie的最大保存时间，即cookie的有效期，当服务器给浏览器回送一个cookie时，如果在服务器端没有调用setMaxAge方法设置cookie的有效期，那么cookie的有效期只在一次会话过程中有效，用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一次会话，当用户关闭浏览器，会话就结束了，此时cookie就会失效，如果在服务器端使用setMaxAge方法设置了cookie的有效期，比如设置了30分钟，那么当服务器把cookie发送给浏览器时，此时cookie就会在客户端的硬盘上存储30分钟，在30分钟内，即使浏览器关了，cookie依然存在，在30分钟内，打开浏览器访问服务器时，浏览器都会把cookie一起带上，这样就可以在服务器端获取到客户端浏览器传递过来的cookie里面的信息了，这就是cookie设置maxAge和不设置maxAge的区别，不设置maxAge，那么cookie就只在一次会话中有效，一旦用户关闭了浏览器，那么cookie就没有了，那么浏览器是怎么做到这一点的呢，我们启动一个浏览器，就相当于启动一个应用程序，而服务器回送的cookie首先是存在浏览器的缓存中的，当浏览器关闭时，浏览器的缓存自然就没有了，所以存储在缓存中的cookie自然就被清掉了，而如果设置了cookie的有效期，那么浏览器在关闭时，就会把缓存中的cookie写到硬盘上存储起来，这样cookie就能够一直存在了。 6 public int getMaxAge() 普通方法 获取Cookies的有效期 7 public void setPath(String uri) 普通方法 设置cookie的有效路径，比如把cookie的有效路径设置为”/xdp”，那么浏览器访问”xdp”目录下的web资源时，都会带上cookie，再比如把cookie的有效路径设置为”/xdp/gacl”，那么浏览器只有在访问”xdp”目录下的”gacl”这个目录里面的web资源时才会带上cookie一起访问，而当访问”xdp”目录下的web资源时，浏览器是不带cookie的 8 public String getPath() 普通方法 获取cookie的有效路径 9 public void setDomain(String pattern) 普通方法 设置cookie的有效域 10 public String getDomain() 普通方法 获取cookie的有效域 response接口也中定义了一个addCookie方法，它用于在其响应头中增加一个相应的Set-Cookie头字段。 同样，request接口中也定义了一个getCookies方法，它用于获取客户端提交的Cookie。 五、Cookie使用范例5.1、使用cookie记录用户上一次访问的时间123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package org.wuqinghua.java.ch02;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.Date;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = &#123;"/cookieDemo01"&#125;)public class CookieDemo01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置服务器以UTF－8编码进行输出 resp.setCharacterEncoding("utf-8"); //设置浏览器以UTF－8进行接受，解决乱码问题 resp.setContentType("text/html;charset=UTF-8"); PrintWriter writer = resp.getWriter(); //获取浏览器访问服务器时传递的cookie Cookie[] cookies = req.getCookies(); //如果是第一次访问那么cookies为null if (cookies!=null)&#123; writer.print("您上次访问的时间为:"); for (Cookie cookie: cookies) &#123; if(cookie.getName().equals("lastAccessTime"))&#123; long lastAccessTime = Long.parseLong(cookie.getValue()); Date date = new Date(lastAccessTime); writer.write(date.toLocaleString()); &#125; &#125; &#125;else&#123; writer.write("您是第一次访问本站."); &#125; //用户访问之后重新设置用户的访问时间,存储到cookie中，然后在发送给浏览器 Cookie cookie = new Cookie("lastAccessTime",System.currentTimeMillis()+""); //将cookie添加到resp对象中 resp.addCookie(cookie); &#125;&#125; 第一次访问时这个Servlet时，效果如下所示： 点击浏览器的刷新按钮，进行第二次访问，此时就服务器就可以通过cookie获取浏览器上一次访问的时间了，效果如下： 在上面的例子中，在程序代码中并没有使用setMaxAge方法设置cookie的有效期，所以当关闭浏览器之后，cookie就失效了，要想在关闭了浏览器之后，cookie依然有效，那么在创建cookie时，就要为cookie设置一个有效期。如下所示： 123456//用户访问之后重新设置用户的访问时间,存储到cookie中，然后在发送给浏览器 Cookie cookie = new Cookie("lastAccessTime",System.currentTimeMillis()+""); //设置Cookie有效期为一天 cookie.setMaxAge(24*60*60); //将cookie添加到resp对象中 resp.addCookie(cookie); 用户第一次访问时，服务器发送给浏览器的cookie就存储到了硬盘上，如下所示： 这样即使关闭了浏览器，下次再访问时，也依然可以通过cookie获取用户上一次访问的时间。 六、Cookie注意细节 一个Cookie只能标识一种信息，它至少含有一个标识该信息的名称（NAME）和设置值（VALUE）。 一个WEB站点可以给一个WEB浏览器发送多个Cookie，一个WEB浏览器也可以存储多个WEB站点提供的Cookie。 浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB。 如果创建了一个cookie，并将他发送到浏览器，默认情况下它是一个会话级别的cookie（即存储在浏览器的内存中），用户退出浏览器之后即被删除。若希望浏览器将该cookie存储在磁盘上，则需要使用maxAge，并给出一个以秒为单位的时间。将最大时效设为0则是命令浏览器删除该cookie。 6.1、删除Cookie注意：删除cookie时，path必须一致，否则不会删除 12345678910111213141516171819202122232425package org.wuqinghua.java.ch02;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/cookieDemo02")public class CookieDemo02 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //创建一个名字为lastAccessTime的cookie Cookie cookie = new Cookie("lastAccessTime",System.currentTimeMillis()+""); //将cookie的有效期设置为0，命令浏览器删除该cookie cookie.setMaxAge(0); resp.addCookie(cookie); &#125;&#125; 6.2、cookie中存取中文 要想在cookie中存储中文，那么必须使用URLEncoder类里面的encode(String s, String enc)方法进行中文转码，例如： 1Cookie cookie = new Cookie("userName", URLEncoder.encode("孤傲苍狼", "UTF-8")); response.addCookie(cookie); 在获取cookie中的中文数据时，再使用URLDecoder类里面的decode(String s, String enc)进行解码，例如： 1URLDecoder.decode(cookies[i].getValue(), "UTF-8")]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十)--HttpServletRequest]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81-HttpServletRequest%2F</url>
    <content type="text"><![CDATA[[TOC] 一、HttpServletRequest介绍 HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中，通过这个对象提供的方法，可以获得客户端请求的所有信息。 二、Request常用方法2.1、获得客户机信息 getRequestURL方法返回客户端发出请求时的完整URL。 getRequestURI方法返回请求行中的资源名部分。 getQueryString 方法返回请求行中的参数部分。 getPathInfo方法返回请求URL中的额外路径信息。额外路径信息是请求URL中的位于Servlet的路径之后和查询参数之前的内容，它以“/”开头。 getRemoteAddr方法返回发出请求的客户机的IP地址。 getRemoteHost方法返回发出请求的客户机的完整主机名。 getRemotePort方法返回客户机所使用的网络端口号。 getLocalAddr方法返回WEB服务器的IP地址。 getLocalName方法返回WEB服务器的主机名。 范例：通过request对象获取客户端请求信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package org.wuqinghua.java.ch05;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * Created by wuqinghua on 17/7/3. */@WebServlet(urlPatterns = "/requestDemo01")public class RequestDemo01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; /** * 获取客户端信息 */ String requestUrl = req.getRequestURL().toString();//获取请求的url地址 String requestURI = req.getRequestURI();//获取请求的资源 String queryString = req.getQueryString();//获取请求参数中附带的参数 String remoteAddr = req.getRemoteAddr();//获取来访的ip String remoteHost = req.getRemoteHost(); int remotePort = req.getRemotePort();//获取来访的端口 String remoteUser = req.getRemoteUser(); String method = req.getMethod();//得到请求url使用的方法 String pathInfo = req.getPathInfo(); String localAddr = req.getLocalAddr();//获取服务器的ip地址 String localName = req.getLocalName();//获取服务器的主机名称 resp.setCharacterEncoding("UTF-8"); resp.setContentType("text/html;charset=UTF-8"); PrintWriter out = resp.getWriter(); out.print("获取到的客户机信息如下:"); out.print("&lt;hr /&gt;"); out.print("请求的url：" + requestUrl); out.print("&lt;br /&gt;"); out.print("请求的资源:" + requestURI); out.print("&lt;br /&gt;"); out.print("附带的参数:" + queryString); out.print("&lt;br /&gt;"); out.print("来访者的ip地址:" + remoteAddr); out.print("&lt;br /&gt;"); out.print("来访者的主机名称:" + remoteHost); out.print("&lt;br /&gt;"); out.print("来访者的端口:" + remotePort); out.print("&lt;br /&gt;"); out.print("remoteUser:" + remoteUser); out.print("&lt;br /&gt;"); out.print("请求方法:" + method); out.print("&lt;br /&gt;"); out.print("pathInfo:" + pathInfo); out.print("&lt;br /&gt;"); out.print("服务器的ip:" + localAddr); out.print("&lt;br /&gt;"); out.print("服务器的主机:" + localName); &#125;&#125; 运行结果： 2.2、获得客户机请求头 getHeader(string name)方法:String getHeaders(String name)方法:Enumeration getHeaderNames()方法 范例：通过request对象获取客户端请求头信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package org.wuqinghua.java.ch05;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.Enumeration;/** * Created by wuqinghua on 17/7/3. */@WebServlet(urlPatterns = "/requestDemo02")public class ResquestDemo02 extends HttpServlet&#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding("utf-8"); resp.setContentType("text/html;charset=utf-8"); PrintWriter out = resp.getWriter(); Enumeration&lt;String&gt; headerNames = req.getHeaderNames();//获取所有的头部 out.print("获取客户端请求头部如下:"); out.print("&lt;hr /&gt;"); while (headerNames.hasMoreElements())&#123; String headName = headerNames.nextElement(); String headerValue = req.getHeader(headName);//根据头部名称获取头部值 out.print(headName+":"+headerValue); out.print("&lt;br /&gt;"); &#125; out.write("&lt;br/&gt;"); out.write("获取到的客户端Accept-Encoding请求头的值："); out.write("&lt;hr/&gt;"); String value = req.getHeader("Accept-Encoding");//获取Accept-Encoding请求头对应的值 out.write(value); Enumeration&lt;String&gt; e = req.getHeaders("Accept-Encoding"); while (e.hasMoreElements()) &#123; String string = e.nextElement(); System.out.println(string); &#125; &#125;&#125; 运行结果如下： 2.3、获得客户机请求参数(客户端提交的数据) getParameter(String)方法(常用) getParameterValues(String name)方法(常用) getParameterNames()方法(不常用) getParameterMap()方法(编写框架时常用) 比如现在有如下的form表单 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Html的Form表单元素&lt;/title&gt;&lt;/head&gt;&lt;fieldset style="width:500px;"&gt; &lt;legend&gt;Html的Form表单元素&lt;/legend&gt; &lt;!--form表单的action属性规定当提交表单时，向何处发送表单数据，method属性指明表单的提交方式，分为get和post，默认为get--&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/servlet/RequestDemo03" method="post"&gt; &lt;!--输入文本框，SIZE表示显示长度，maxlength表示最多输入长度--&gt; 编&amp;nbsp;&amp;nbsp;号(文本框)： &lt;input type="text" name="userid" value="NO." size="2" maxlength="2"&gt;&lt;br&gt; &lt;!--输入文本框，通过value指定其显示的默认值--&gt; 用户名(文本框)：&lt;input type="text" name="username" value="请输入用户名"&gt;&lt;br&gt; &lt;!--密码框，其中所有输入的内容都以密文的形式显示--&gt; 密&amp;nbsp;&amp;nbsp;码(密码框)： &lt;!--&amp;nbsp;表示的是一个空格--&gt; &lt;input type="password" name="userpass" value="请输入密码"&gt;&lt;br&gt; &lt;!--单选按钮，通过checked指定默认选中，名称必须一样，其中value为真正需要的内容--&gt; 性&amp;nbsp;&amp;nbsp;别(单选框)： &lt;input type="radio" name="sex" value="男" checked&gt;男 &lt;input type="radio" name="sex" value="女"&gt;女&lt;br&gt; &lt;!--下拉列表框，通过&lt;option&gt;元素指定下拉的选项--&gt; 部&amp;nbsp;&amp;nbsp;门(下拉框)： &lt;select name="dept"&gt; &lt;option value="技术部"&gt;技术部&lt;/option&gt; &lt;option value="销售部" SELECTED&gt;销售部&lt;/option&gt; &lt;option value="财务部"&gt;财务部&lt;/option&gt; &lt;/select&gt;&lt;br&gt; &lt;!--复选框，可以同时选择多个选项，名称必须一样，其中value为真正需要的内容--&gt; 兴&amp;nbsp;&amp;nbsp;趣(复选框)： &lt;input type="checkbox" name="inst" value="唱歌"&gt;唱歌 &lt;input type="checkbox" name="inst" value="游泳"&gt;游泳 &lt;input type="checkbox" name="inst" value="跳舞"&gt;跳舞 &lt;input type="checkbox" name="inst" value="编程" checked&gt;编程 &lt;input type="checkbox" name="inst" value="上网"&gt;上网 &lt;br&gt; &lt;!--大文本输入框，宽度为34列，高度为5行--&gt; 说&amp;nbsp;&amp;nbsp;明(文本域)： &lt;textarea name="note" cols="34" rows="5"&gt; &lt;/textarea&gt; &lt;br&gt; &lt;!--隐藏域，在页面上无法看到，专门用来传递参数或者保存参数--&gt; &lt;input type="hidden" name="hiddenField" value="hiddenvalue"/&gt; &lt;!--提交表单按钮，当点击提交后，所有填写的表单内容都会被传输到服务器端--&gt; &lt;input type="submit" value="提交(提交按钮)"&gt; &lt;!--重置表单按钮，当点击重置后，所有表单恢复原始显示内容--&gt; &lt;input type="reset" value="重置(重置按钮)"&gt;&lt;/form&gt;&lt;!--表单结束--&gt;&lt;/fieldset&gt;&lt;/body&gt;&lt;!--完结标记--&gt;&lt;/html&gt;&lt;!--完结标记--&gt; 在Form表单中填写数据，然后提交到RequestDemo03这个Servlet进行处理，填写的表单数据如下： 在服务器端使用getParameter方法和getParameterValues方法接收表单参数，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package gacl.request.study;import java.io.IOException;import java.text.MessageFormat;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author gacl * 获取客户端通过Form表单提交上来的参数 */public class RequestDemo03 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //客户端是以UTF-8编码提交表单数据的，所以需要设置服务器端以UTF-8的编码进行接收，否则对于中文数据就会产生乱码 request.setCharacterEncoding("UTF-8"); /** * 编&amp;nbsp;&amp;nbsp;号(文本框)： &lt;input type="text" name="userid" value="NO." size="2" maxlength="2"&gt; */ String userid = request.getParameter("userid");//获取填写的编号，userid是文本框的名字，&lt;input type="text" name="userid"&gt; /** * 用户名(文本框)：&lt;input type="text" name="username" value="请输入用户名"&gt; */ String username = request.getParameter("username");//获取填写的用户名 /** * 密&amp;nbsp;&amp;nbsp;码(密码框)：&lt;input type="password" name="userpass" value="请输入密码"&gt; */ String userpass = request.getParameter("userpass");//获取填写的密码 String sex = request.getParameter("sex");//获取选中的性别 String dept = request.getParameter("dept");//获取选中的部门 //获取选中的兴趣，因为可以选中多个值，所以获取到的值是一个字符串数组，因此需要使用getParameterValues方法来获取 String[] insts = request.getParameterValues("inst"); String note = request.getParameter("note");//获取填写的说明信息 String hiddenField = request.getParameter("hiddenField");//获取隐藏域的内容 String instStr=""; /** * 获取数组数据的技巧，可以避免insts数组为null时引发的空指针异常错误！ */ for (int i = 0; insts!=null &amp;&amp; i &lt; insts.length; i++) &#123; if (i == insts.length-1) &#123; instStr+=insts[i]; &#125;else &#123; instStr+=insts[i]+","; &#125; &#125; String htmlStr = "&lt;table&gt;" + "&lt;tr&gt;&lt;td&gt;填写的编号：&lt;/td&gt;&lt;td&gt;&#123;0&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;填写的用户名：&lt;/td&gt;&lt;td&gt;&#123;1&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;填写的密码：&lt;/td&gt;&lt;td&gt;&#123;2&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;选中的性别：&lt;/td&gt;&lt;td&gt;&#123;3&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;选中的部门：&lt;/td&gt;&lt;td&gt;&#123;4&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;选中的兴趣：&lt;/td&gt;&lt;td&gt;&#123;5&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;填写的说明：&lt;/td&gt;&lt;td&gt;&#123;6&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;隐藏域的内容：&lt;/td&gt;&lt;td&gt;&#123;7&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;/table&gt;"; htmlStr = MessageFormat.format(htmlStr, userid,username,userpass,sex,dept,instStr,note,hiddenField); response.setCharacterEncoding("UTF-8");//设置服务器端以UTF-8编码输出数据到客户端 response.setContentType("text/html;charset=UTF-8");//设置客户端浏览器以UTF-8编码解析数据 response.getWriter().write(htmlStr);//输出htmlStr里面的内容到客户端浏览器显示 &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 运行结果如下： 在服务器端使用getParameterNames方法接收表单参数，代码如下： 123456Enumeration&lt;String&gt; paramNames = request.getParameterNames();//获取所有的参数名 while (paramNames.hasMoreElements()) &#123; String name = paramNames.nextElement();//得到参数名 String value = request.getParameter(name);//通过参数名获取对应的值 System.out.println(MessageFormat.format("&#123;0&#125;=&#123;1&#125;", name,value)); &#125; 运行结果如下： 在服务器端使用getParameterMap方法接收表单参数，代码如下： 123456789101112131415//request对象封装的参数是以Map的形式存储的 Map&lt;String, String[]&gt; paramMap = request.getParameterMap(); for(Map.Entry&lt;String, String[]&gt; entry :paramMap.entrySet())&#123; String paramName = entry.getKey(); String paramValue = ""; String[] paramValueArr = entry.getValue(); for (int i = 0; paramValueArr!=null &amp;&amp; i &lt; paramValueArr.length; i++) &#123; if (i == paramValueArr.length-1) &#123; paramValue+=paramValueArr[i]; &#125;else &#123; paramValue+=paramValueArr[i]+","; &#125; &#125; System.out.println(MessageFormat.format("&#123;0&#125;=&#123;1&#125;", paramName,paramValue)); &#125; 运行结果如下： 三、request接收表单提交中文参数乱码问题3.1、以POST方式提交表单中文参数的乱码问题例如有如下的form表单页面： 12345678910111213141516171819&lt;%-- Created by IntelliJ IDEA. User: wuqinghua Date: 17/7/3 Time: 下午9:13 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;request接受正文参数乱码&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="&lt;%=request.getContextPath()%&gt;/requestDemo04" method="post"&gt; 用户名： &lt;input type="text" name="userName"/&gt; &lt;input type="submit" value="post方式提交"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 代码如下: 1234567891011121314151617181920package org.wuqinghua.java.ch05;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/7/3. */@WebServlet(urlPatterns = "/requestDemo04")public class RequestDemo04 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String userName = req.getParameter("userName"); System.out.println("userName:"+userName); &#125;&#125; 运行结果为： 3.2、post方式提交中文数据乱码产生的原因和解决办法 可以看到，之所以会产生乱码，就是因为服务器和客户端沟通的编码不一致造成的，因此解决的办法是：在客户端和服务器之间设置一个统一的编码，之后就按照此编码进行数据的传输和接收。 由于客户端是以UTF-8字符编码将表单数据传输到服务器端的，因此服务器也需要设置以UTF-8字符编码进行接收，要想完成此操作，服务器可以直接使用从ServletRequest接口继承而来的”setCharacterEncoding(charset)”方法进行统一的编码设置。修改后的代码如下： 1234567891011121314151617181920212223242526package org.wuqinghua.java.ch05;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/7/3. */@WebServlet(urlPatterns = "/requestDemo04")public class RequestDemo04 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; /** * 客户端是以utf-8的编码提交到后台的，所以需要设置服务器端以utf－8的编码进行接收，否则对于中文数据就会产生乱码 */ req.setCharacterEncoding("UTF-8"); String userName = req.getParameter("userName"); System.out.println("userName:"+userName); &#125;&#125; 3.3、以GET方式提交表单中文参数的乱码问题12345678910public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * * 对于以get方式传输的数据，request即使设置了以指定的编码接收数据也是无效的，默认的还是使用ISO8859-1这个字符编码来接收数据 */ String name = request.getParameter("name");//接收数据 name =new String(name.getBytes("ISO8859-1"), "UTF-8") ;//获取request对象以ISO8859-1字符编码接收到的原始数据的字节数组，然后通过字节数组以指定的编码构建字符串，解决乱码问题 System.out.println("name："+name); &#125; 3.6、提交中文数据乱码问题总结 1、如果提交方式为post，想不乱码，只需要在服务器端设置request对象的编码即可，客户端以哪种编码提交的，服务器端的request对象就以对应的编码接收，比如客户端是以UTF-8编码提交的，那么服务器端request对象就以UTF-8编码接收(request.setCharacterEncoding(“UTF-8”)) 2、如果提交方式为get，设置request对象的编码是无效的，request对象还是以默认的ISO8859-1编码接收数据，因此要想不乱码，只能在接收到数据后再手工转换，步骤如下： 1).获取获取客户端提交上来的数据，得到的是乱码字符串,data=”???è?????” String data = request.getParameter(“paramName”); 2).查找ISO8859-1码表，得到客户机提交的原始数据的字节数组 byte[] source = data.getBytes(“ISO8859-1”); 3).通过字节数组以指定的编码构建字符串，解决乱码 data = new String(source, “UTF-8”); 通过字节数组以指定的编码构建字符串，这里指定的编码是根据客户端那边提交数据时使用的字符编码来定的，如果是GB2312，那么就设置成data = new String(source, “GB2312”)，如果是UTF-8，那么就设置成data = new String(source, “UTF-8”) 四、Request对象实现请求转发4.1、请求转发的基本概念 请求转发：指一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理。 请求转发的应用场景：MVC设计模式 在Servlet中实现请求转发的两种方式： 1、通过ServletContext的getRequestDispatcher(String path)方法，该方法返回一个RequestDispatcher对象，调用这个对象的forward方法可以实现请求转发。 例如：将请求转发的test.jsp页面 121 RequestDispatcher reqDispatcher =this.getServletContext().getRequestDispatcher(&quot;/test.jsp&quot;);2 reqDispatcher.forward(request, response); 2、通过request对象提供的getRequestDispatche(String path)方法，该方法返回一个RequestDispatcher对象，调用这个对象的forward方法可以实现请求转发。 例如：将请求转发的test.jsp页面 11 request.getRequestDispatcher(&quot;/test.jsp&quot;).forward(request, response); request对象同时也是一个域对象(Map容器)，开发人员通过request对象在实现转发时，把数据通过request对象带给其它web资源处理。 request对象作为一个域对象(Map容器)使用时，主要是通过以下的四个方法来操作 setAttribute(String name,Object o)方法，将数据作为request对象的一个属性存放到request对象中，例如：request.setAttribute(“data”, data); getAttribute(String name)方法，获取request对象的name属性的属性值，例如：request.getAttribute(“data”) removeAttribute(String name)方法，移除request对象的name属性，例如：request.removeAttribute(“data”) getAttributeNames方法，获取request对象的所有属性名，返回的是一个，例如：Enumeration attrNames = request.getAttributeNames(); 4.2、请求重定向和请求转发的区别 一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理，称之为请求转发/307。 一个web资源收到客户端请求后，通知浏览器去访问另外一个web资源进行处理，称之为请求重定向/302。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(九)--通过Servlet生成验证码]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B9%9D-%E9%80%9A%E8%BF%87Servlet%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[[TOC] 一、BufferedImage类介绍生成验证码图片主要用到了一个BufferedImage类，如下： 创建一个DrawImage Servlet，用来生成验证码图片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193package org.wuqinghua.java.ch04;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;/** * Created by wuqinghua on 17/7/3. */@WebServlet(urlPatterns = "/drawImage")public class DrawImage extends HttpServlet &#123; public static final int WIDTH = 120;//生成的图片的宽度 public static final int HEIGHT = 30;//生成的图片的高度 @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String createTypeFlag = req.getParameter("createTypeFlag"); //1.在内存中创建一个图片 BufferedImage image = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB); //2.获取到画笔 Graphics2D g = (Graphics2D) image.getGraphics(); //3.设置图片的背景颜色 setBackground(g, Color.WHITE); //4.设置边框 setBorder(g, Color.BLUE); //5.在图片上设置干扰线 drawRandomLine(g, Color.GREEN, 5); //6.在图片上生成随机验证码 String code = drawRandomCode(g, Color.RED, ImageType.getImageType(createTypeFlag)); //7.将验证码存入到session req.getSession().setAttribute("code", code); //8.设置响应头 resp.setHeader("content-type", "image/jpeg"); //9.不要缓存 resp.setDateHeader("expries", -1); resp.setHeader("Cache-Control", "no-cache"); resp.setHeader("Pragma", "no-cache"); //10.将图片写入浏览器 ImageIO.write(image,"jpg",resp.getOutputStream()); &#125; /** * 生成随机验证码 * * @param g * @param color * @param imageType * @return */ private String drawRandomCode(Graphics2D g, Color color, ImageType imageType) &#123; g.setColor(color); //设置字体 g.setFont(new Font("宋体", Font.BOLD, 20)); //常用的中国汉字 String baseChineseChar = "\u7684\u4e00\u4e86\u662f\u6211\u4e0d\u5728\u4eba\u4eec\u6709\u6765\u4ed6\u8fd9\u4e0a\u7740\u4e2a\u5730\u5230\u5927\u91cc\u8bf4\u5c31\u53bb\u5b50\u5f97\u4e5f\u548c\u90a3\u8981\u4e0b\u770b\u5929\u65f6\u8fc7\u51fa\u5c0f\u4e48\u8d77\u4f60\u90fd\u628a\u597d\u8fd8\u591a\u6ca1\u4e3a\u53c8\u53ef\u5bb6\u5b66\u53ea\u4ee5\u4e3b\u4f1a\u6837\u5e74\u60f3\u751f\u540c\u8001\u4e2d\u5341\u4ece\u81ea\u9762\u524d\u5934\u9053\u5b83\u540e\u7136\u8d70\u5f88\u50cf\u89c1\u4e24\u7528\u5979\u56fd\u52a8\u8fdb\u6210\u56de\u4ec0\u8fb9\u4f5c\u5bf9\u5f00\u800c\u5df1\u4e9b\u73b0\u5c71\u6c11\u5019\u7ecf\u53d1\u5de5\u5411\u4e8b\u547d\u7ed9\u957f\u6c34\u51e0\u4e49\u4e09\u58f0\u4e8e\u9ad8\u624b\u77e5\u7406\u773c\u5fd7\u70b9\u5fc3\u6218\u4e8c\u95ee\u4f46\u8eab\u65b9\u5b9e\u5403\u505a\u53eb\u5f53\u4f4f\u542c\u9769\u6253\u5462\u771f\u5168\u624d\u56db\u5df2\u6240\u654c\u4e4b\u6700\u5149\u4ea7\u60c5\u8def\u5206\u603b\u6761\u767d\u8bdd\u4e1c\u5e2d\u6b21\u4eb2\u5982\u88ab\u82b1\u53e3\u653e\u513f\u5e38\u6c14\u4e94\u7b2c\u4f7f\u5199\u519b\u5427\u6587\u8fd0\u518d\u679c\u600e\u5b9a\u8bb8\u5feb\u660e\u884c\u56e0\u522b\u98de\u5916\u6811\u7269\u6d3b\u90e8\u95e8\u65e0\u5f80\u8239\u671b\u65b0\u5e26\u961f\u5148\u529b\u5b8c\u5374\u7ad9\u4ee3\u5458\u673a\u66f4\u4e5d\u60a8\u6bcf\u98ce\u7ea7\u8ddf\u7b11\u554a\u5b69\u4e07\u5c11\u76f4\u610f\u591c\u6bd4\u9636\u8fde\u8f66\u91cd\u4fbf\u6597\u9a6c\u54ea\u5316\u592a\u6307\u53d8\u793e\u4f3c\u58eb\u8005\u5e72\u77f3\u6ee1\u65e5\u51b3\u767e\u539f\u62ff\u7fa4\u7a76\u5404\u516d\u672c\u601d\u89e3\u7acb\u6cb3\u6751\u516b\u96be\u65e9\u8bba\u5417\u6839\u5171\u8ba9\u76f8\u7814\u4eca\u5176\u4e66\u5750\u63a5\u5e94\u5173\u4fe1\u89c9\u6b65\u53cd\u5904\u8bb0\u5c06\u5343\u627e\u4e89\u9886\u6216\u5e08\u7ed3\u5757\u8dd1\u8c01\u8349\u8d8a\u5b57\u52a0\u811a\u7d27\u7231\u7b49\u4e60\u9635\u6015\u6708\u9752\u534a\u706b\u6cd5\u9898\u5efa\u8d76\u4f4d\u5531\u6d77\u4e03\u5973\u4efb\u4ef6\u611f\u51c6\u5f20\u56e2\u5c4b\u79bb\u8272\u8138\u7247\u79d1\u5012\u775b\u5229\u4e16\u521a\u4e14\u7531\u9001\u5207\u661f\u5bfc\u665a\u8868\u591f\u6574\u8ba4\u54cd\u96ea\u6d41\u672a\u573a\u8be5\u5e76\u5e95\u6df1\u523b\u5e73\u4f1f\u5fd9\u63d0\u786e\u8fd1\u4eae\u8f7b\u8bb2\u519c\u53e4\u9ed1\u544a\u754c\u62c9\u540d\u5440\u571f\u6e05\u9633\u7167\u529e\u53f2\u6539\u5386\u8f6c\u753b\u9020\u5634\u6b64\u6cbb\u5317\u5fc5\u670d\u96e8\u7a7f\u5185\u8bc6\u9a8c\u4f20\u4e1a\u83dc\u722c\u7761\u5174\u5f62\u91cf\u54b1\u89c2\u82e6\u4f53\u4f17\u901a\u51b2\u5408\u7834\u53cb\u5ea6\u672f\u996d\u516c\u65c1\u623f\u6781\u5357\u67aa\u8bfb\u6c99\u5c81\u7ebf\u91ce\u575a\u7a7a\u6536\u7b97\u81f3\u653f\u57ce\u52b3\u843d\u94b1\u7279\u56f4\u5f1f\u80dc\u6559\u70ed\u5c55\u5305\u6b4c\u7c7b\u6e10\u5f3a\u6570\u4e61\u547c\u6027\u97f3\u7b54\u54e5\u9645\u65e7\u795e\u5ea7\u7ae0\u5e2e\u5566\u53d7\u7cfb\u4ee4\u8df3\u975e\u4f55\u725b\u53d6\u5165\u5cb8\u6562\u6389\u5ffd\u79cd\u88c5\u9876\u6025\u6797\u505c\u606f\u53e5\u533a\u8863\u822c\u62a5\u53f6\u538b\u6162\u53d4\u80cc\u7ec6"; //数字和字母的组合 String baseNumLetter = "0123456789ABCDEFGHJKLMNOPQRSTUVWXYZ"; //纯数字 String baseNum = "0123456789"; //纯字母 String baseLetter = "ABCDEFGHJKLMNOPQRSTUVWXYZ"; switch (imageType) &#123; case CH://汉字 return createRandomChar(g, baseChineseChar); case NL://数字和字母 return createRandomChar(g, baseNumLetter); case L: return createRandomChar(g, baseLetter); default: return createRandomChar(g, baseNum); &#125; &#125; /** * 根据基础字符生成随机字符串 * * @param g * @param baseChar * @return */ private String createRandomChar(Graphics2D g, String baseChar) &#123; StringBuffer buffer = new StringBuffer(); int x = 5; String ch = ""; //控制字数 for (int i = 0; i &lt; 4; i++) &#123; //设置字体的旋转角度 int degree = new Random().nextInt() % 30; ch = baseChar.charAt(new Random().nextInt(baseChar.length())) + ""; buffer.append(ch); //正向角度 g.rotate(degree * Math.PI / 180, x, 20); g.drawString(ch, x, 20); //反向角度 g.rotate(-degree * Math.PI / 180, x, 20); x += 30; &#125; return buffer.toString(); &#125; /** * 设置干扰线 * * @param g */ private void drawRandomLine(Graphics2D g, Color color, int lineCount) &#123; g.setColor(color); for (int i = 0; i &lt; lineCount; i++) &#123; int x1 = new Random().nextInt(WIDTH); int y1 = new Random().nextInt(HEIGHT); int x2 = new Random().nextInt(WIDTH); int y2 = new Random().nextInt(HEIGHT); g.drawLine(x1, y1, x2, y2); &#125; &#125; /** * 设置边框 * * @param g * @param color */ private void setBorder(Graphics2D g, Color color) &#123; g.setColor(color); g.drawRect(1, 1, WIDTH - 2, HEIGHT - 2); &#125; /** * 设置背景颜色 * * @param g */ private void setBackground(Graphics2D g, Color color) &#123; g.setColor(color); g.fillRect(0, 0, WIDTH, HEIGHT); &#125; private enum ImageType &#123; CH("ch"), NL("nl"), N("n"), L("l"); private String createTypeFlag = null; ImageType(String createTypeFlag) &#123; this.createTypeFlag = createTypeFlag; &#125; public static ImageType getImageType(String createTypeFlag) &#123; if (createTypeFlag.equals("ch")) &#123; return CH; &#125; else if (createTypeFlag.equals("nl")) &#123; return NL; &#125; else if (createTypeFlag.equals("L")) &#123; return L; &#125; else &#123; return N; &#125; &#125; String getValue() &#123; return this.createTypeFlag; &#125; &#125;&#125; 运行结果如下： 二、在Form表单中使用验证码图片1234567891011121314151617181920212223&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;在Form表单中使用验证码&lt;/title&gt; &lt;script type="text/javascript"&gt; //刷新验证码 function changeImg()&#123; document.getElementById("validateCodeImg").src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?"+Math.random(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/servlet/CheckServlet" method="post"&gt; 验证码：&lt;input type="text" name="validateCode"/&gt; &lt;img alt="验证码看不清，换一张" src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage" id="validateCodeImg" onclick="changeImg()"&gt; &lt;a href="javascript:void(0)" onclick="changeImg()"&gt;看不清，换一张&lt;/a&gt; &lt;br/&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 运行结果： DrawImage Servlet除了可以生成的字母和数字的组合的验证码图片之外，还可以生成汉字，纯数字，纯字母的验证码图片，只需要向DrawImage Servlet传递约定好的生成标识符参数即可，如下所示： 12345678910111213141516171819202122232425262728293031&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;在Form表单中使用验证码&lt;/title&gt; &lt;script type="text/javascript"&gt; //刷新验证码 function changeImg(obj,createTypeFlag)&#123; document.getElementById(obj.id).src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?createTypeFlag="+createTypeFlag+"&amp;"+Math.random(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/servlet/CheckServlet" method="post"&gt; 数字字母混合验证码：&lt;input type="text" name="validateCode"/&gt; &lt;img alt="验证码看不清，换一张" src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage" id="validateCodeImg1" onclick="changeImg(this,'nl')"&gt; &lt;br/&gt; 中文验证码：&lt;input type="text" name="validateCode"/&gt; &lt;img alt="验证码看不清，换一张" src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?createTypeFlag=ch" id="validateCodeImg2" onclick="changeImg(this,'ch')"&gt; &lt;br/&gt; 英文验证码：&lt;input type="text" name="validateCode"/&gt; &lt;img alt="验证码看不清，换一张" src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?createTypeFlag=l" id="validateCodeImg3" onclick="changeImg(this,'l')"&gt; &lt;br/&gt; 数字验证码：&lt;input type="text" name="validateCode"/&gt; &lt;img alt="验证码看不清，换一张" src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?createTypeFlag=n" id="validateCodeImg4" onclick="changeImg(this,'n')"&gt; &lt;br/&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 运行结果如下： 三、服务器端对form表单提交上来的验证码处理12345678910111213141516171819202122232425262728package gacl.response.study;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author gacl * 服务器端接收到验证码后的处理 */public class CheckServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String clientCheckcode = request.getParameter("validateCode");//接收客户端浏览器提交上来的验证码 String serverCheckcode = (String) request.getSession().getAttribute("checkcode");//从服务器端的session中取出验证码 if (clientCheckcode.equals(serverCheckcode)) &#123;//将客户端验证码和服务器端验证比较，如果相等，则表示验证通过 System.out.println("验证码验证通过！"); &#125;else &#123; System.out.println("验证码验证失败！"); &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(七)--HttpServletResponse(二)]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B8%83-HttpServletResponse-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 一、HttpServletResponse常见应用——生成验证码1.1、生成随机图片用作验证码 生成图片主要用到了一个BufferedImage类， 生成随机图片范例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package org.wuqinghua.java.ch04;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;/** * Created by wuqinghua on 17/7/2. */@WebServlet(urlPatterns = "/responseDemo05")public class ResponseDemo05 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置浏览器每隔5秒刷新一次 resp.setHeader("refresh", "5"); //1.在内存中创建一张图片 BufferedImage image = new BufferedImage(100, 25, BufferedImage.TYPE_INT_RGB); //2.绘制图片 获取画笔 Graphics2D g = (Graphics2D) image.getGraphics(); g.setColor(Color.WHITE);//设置图片的背景色 g.fillRect(0, 0, 100, 25);//填充背景 //3.向图片上写数值 g.setColor(Color.BLUE); g.setFont(new Font(null, Font.BOLD, 20)); g.drawString(makeNum(),0,20); //4.设置浏览器以图片方式打开 resp.setHeader("content-type","image/jpeg"); //5.设置浏览器不缓存图片 resp.setDateHeader("expries",-1); resp.setHeader("Cache-Control","no-cache"); resp.setHeader("Pragma","no-cache"); //6.将图片写到浏览器 ImageIO.write(image,"jpg",resp.getOutputStream()); &#125; private String makeNum() &#123; Random random = new Random(); String num = random.nextInt(9999999) + ""; StringBuffer buffer = new StringBuffer(); for (int i = 0; i &lt; 7 - num.length(); i++) &#123; buffer.append("0"); &#125; num = buffer.toString() + num; return num; &#125;&#125; 运行结果如下： 二、HttpServletResponse常见应用——设置响应头控制浏览器的行为2.1、设置http响应头控制浏览器禁止缓存当前文档内容123response.setDateHeader("expries", -1);response.setHeader("Cache-Control", "no-cache");response.setHeader("Pragma", "no-cache"); 2.2、设置http响应头控制浏览器定时刷新网页(refresh)1response.setHeader("refresh", "5");//设置refresh响应头控制浏览器每隔5秒钟刷新一次 2.3、通过response实现请求重定向 请求重定向指：一个web资源收到客户端请求后，通知客户端去访问另外一个web资源，这称之为请求重定向。 应用场景：用户登陆，用户首先访问登录页面，登录成功后，就会跳转到某个页面，这个过程就是一个请求重定向的过程 实现方式：response.sendRedirect(String location)，即调用response对象的sendRedirect方法实现请求重定向 sendRedirect内部的实现原理：使用response设置**302状态码和设置location响应头实现重定向** 例如： 1234567891011121314151617181920212223242526272829package gacl.response.study;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ResponseDemo04 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * 1.调用sendRedirect方法实现请求重定向, * sendRedirect方法内部调用了 * response.setHeader("Location", "/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"); * response.setStatus(HttpServletResponse.SC_FOUND);//设置302状态码，等同于response.setStatus(302); */ response.sendRedirect("/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"); //2.使用response设置302状态码和设置location响应头实现重定向实现请求重定向 //response.setHeader("Location", "/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"); //response.setStatus(HttpServletResponse.SC_FOUND);//设置302状态码，等同于response.setStatus(302); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 三、response细节问题 getOutputStream和getWriter方法分别用于得到输出二进制数据、输出文本数据的ServletOuputStream、Printwriter对象。 getOutputStream和getWriter这两个方法互相排斥，调用了其中的任何一个方法后，就不能再调用另一方法。 Servlet程序向ServletOutputStream或PrintWriter对象中写入的数据将被Servlet引擎从response里面获取，Servlet引擎将这些数据当作响应消息的正文，然后再与响应状态行和各响应头组合后输出到客户端。 Serlvet的service方法结束后，Servlet引擎将检查getWriter或getOutputStream方法返回的输出流对象是否已经调用过close方法，如果没有，Servlet引擎将调用close方法关闭该输出流对象。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(七)--HttpServletResponse(一)]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B8%83-HttpServletResponse-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[[TOC] Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对象。request和response对象即然代表请求和响应，那我们要获取客户机提交过来的数据，只需要找request对象就行了。要向客户机输出数据，只需要找response对象就行了。 一、HttpServletResponse对象介绍 HttpServletResponse对象代表服务器的响应。这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法。查看HttpServletResponse的API，可以看到这些相关的方法。 1.1、负责向客户端(浏览器)发送数据的相关方法 1.2、负责向客户端(浏览器)发送响应头的相关方法 1.3、负责向客户端(浏览器)发送响应状态码的相关方法 1.4、响应状态码的常量 HttpServletResponse定义了很多状态码的常量(具体可以查看Servlet的API)，当需要向客户端发送响应状态码时，可以使用这些常量，避免了直接写数字，常见的状态码对应的常量： 状态码404对应的常量 状态码200对应的常量 状态码500对应的常量 二、HttpServletResponse对象常见应用2.1、使用OutputStream流向客户端浏览器输出中文数据使用OutputStream流输出中文注意问题： 在服务器端，数据是以哪个码表输出的，那么就要控制客户端浏览器以相应的码表打开，比如：outputStream.write(“中国”.getBytes(“UTF-8”));使用OutputStream流向客户端浏览器输出中文，以UTF-8的编码进行输出，此时就要控制客户端浏览器以UTF-8的编码打开，否则显示的时候就会出现中文乱码，那么在服务器端如何控制客户端浏览器以以UTF-8的编码显示数据呢？可以通过设置响应头控制浏览器的行为，例如：response.setHeader(“content-type”, “text/html;charset=UTF-8”);通过设置响应头控制浏览器以UTF-8的编码显示数据。 范例：使用OutputStream流向客户端浏览器输出”中国”这两个汉字 123456789101112131415161718192021222324252627282930313233package org.wuqinghua.java.ch04;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.nio.charset.Charset;/** * Created by wuqinghua on 17/7/1. */@WebServlet(urlPatterns = "/responseDemo01")public class ResponseDemo01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String data = "中国"; ServletOutputStream outputStream = resp.getOutputStream();//获取输出流 resp.setContentType("text/html;charset=UTF-8");//通过响应头告诉浏览器需要使用utf-8显示数据 /** * data.getBytes()是一个将字符串转换为字节数组的过程，这个过程一定会查询码表， * 如果是中文操作系统，默认就会查询GB2312的码表， * 将字符串转换成字节数组的过程就是将中文字符转换为GB2312上对应的数字 * 比如： "中" 在GB2312上对应的数字为98 * "国" 为99 */ byte[] bytes = data.getBytes(Charset.forName("UTF-8")); outputStream.write(bytes); &#125;&#125; 运行结果如下： 客户端浏览器接收到数据后，就按照响应头上设置的字符编码来解析数据，如下所示： 2.2、使用PrintWriter流向客户端浏览器输出中文数据使用PrintWriter流输出中文注意问题： 在获取PrintWriter输出流之前首先使用”response.setCharacterEncoding(charset)”设置字符以什么样的编码输出到浏览器，如：response.setCharacterEncoding(“UTF-8”);设置将字符以”UTF-8”编码输出到客户端浏览器，然后再使用response.getWriter();获取PrintWriter输出流，这两个步骤不能颠倒，如下： 123456response.setCharacterEncoding("UTF-8");//设置将字符以"UTF-8"编码输出到客户端浏览器/*** PrintWriter out = response.getWriter();这句代码必须放在response.setCharacterEncoding("UTF-");之后* 否则response.setCharacterEncoding("UTF-8")这行代码的设置将无效，浏览器显示的时候还是乱码*/PrintWriter out = response.getWriter();//获取PrintWriter输出流 然后再使用response.setHeader(“content-type”, “text/html;charset=字符编码”);设置响应头，控制浏览器以指定的字符编码编码进行显示，例如： 12//通过设置响应头控制浏览器以UTF-8的编码显示数据，如果不加这句话，那么浏览器显示的将是乱码response.setHeader("content-type", "text/html;charset=UTF-8"); 除了可以使用response.setHeader(“content-type”, “text/html;charset=字符编码”);设置响应头来控制浏览器以指定的字符编码编码进行显示这种方式之外，还可以用如下的方式来模拟响应头的作用 123456/*** 多学一招：使用HTML语言里面的&lt;meta&gt;标签来控制浏览器行为，模拟通过设置响应头控制浏览器行为 *response.getWriter().write("&lt;meta http-equiv='content-type' content='text/html;charset=UTF-8'/&gt;");* 等同于response.setHeader("content-type", "text/html;charset=UTF-8");*/response.getWriter().write("&lt;meta http-equiv='content-type' content='text/html;charset=UTF-8'/&gt;"); 范例：使用PrintWriter流向客户端浏览器输出”中国”这两个汉字 123456789101112131415161718192021222324252627package org.wuqinghua.java.ch04;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * Created by wuqinghua on 17/7/2. */@WebServlet(urlPatterns = "/responseDemo02")public class ResponseDemo02 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String data = "中国"; resp.setCharacterEncoding("UTF-8"); resp.setContentType("text/html;charset=utf-8"); PrintWriter out = resp.getWriter(); out.print(data); &#125;&#125; 当需要向浏览器输出字符数据时，使用PrintWriter比较方便，省去了将字符转换成字节数组那一步。 2.3、使用OutputStream或者PrintWriter向客户端浏览器输出数字比如有如下的代码： 123456789101112131415161718192021222324package org.wuqinghua.java.ch04;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.OutputStream;/** * Created by wuqinghua on 17/7/2. */@WebServlet(urlPatterns = "/responseDemo03")public class ResponseDemo03 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setHeader("content-type","text/html;charset=utf-8"); OutputStream outputStream = resp.getOutputStream(); outputStream.write("使用outputStream向界面输出1:".getBytes("UTF-8")); outputStream.write(1); &#125;&#125; 运行上面代码显示的结果如下： 运行的结果和我们想象中的不一样，数字1没有输出来，下面我们修改一下上面的outputOneByOutputStream方法的代码，修改后的代码如下： 12345678910111213141516171819202122232425package org.wuqinghua.java.ch04;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.OutputStream;/** * Created by wuqinghua on 17/7/2. */@WebServlet(urlPatterns = "/responseDemo03")public class ResponseDemo03 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setHeader("content-type","text/html;charset=utf-8"); OutputStream outputStream = resp.getOutputStream(); outputStream.write("使用outputStream向界面输出1:".getBytes("UTF-8"));// outputStream.write(1); outputStream.write((1+"").getBytes("UTF-8")); &#125;&#125; 1+””这一步是将数字1和一个空字符串相加，这样处理之后，数字1就变成了字符串1了，然后再将字符串1转换成字节数组使用OutputStream进行输出，此时看到的结果如下： 这次可以看到输出来的1了，这说明了一个问题：在开发过程中，如果希望服务器输出什么浏览器就能看到什么，那么在服务器端都要以字符串的形式进行输出。 如果使用PrintWriter流输出数字，那么也要先将数字转换成字符串后再输出，如下： 12345678910111213/** * 使用PrintWriter流输出数字1 * @param request * @param response * @throws IOException */ public void outputOneByPrintWriter(HttpServletResponse response) throws IOException&#123; response.setHeader("content-type", "text/html;charset=UTF-8"); response.setCharacterEncoding("UTF-8"); PrintWriter out = response.getWriter();//获取PrintWriter输出流 out.write("使用PrintWriter流输出数字1："); out.write(1+""); &#125; 2.4、文件下载 文件下载功能是web开发中经常使用到的功能，使用HttpServletResponse对象就可以实现文件的下载 文件下载功能的实现思路： 1.获取要下载的文件的绝对路径 2.获取要下载的文件名 3.设置content-disposition响应头控制浏览器以下载的形式打开文件 4.获取要下载的文件输入流 5.创建数据缓冲区 6.通过response对象获取OutputStream流 7.将FileInputStream流写入到buffer缓冲区 8.使用OutputStream将缓冲区的数据输出到客户端浏览器 范例：使用Response实现文件下载 123456789101112131415161718192021222324252627282930313233343536373839package org.wuqinghua.java.ch04;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;/** * Created by wuqinghua on 17/7/2. */@WebServlet(urlPatterns = "/responseDemo04")public class ResponseDemo04 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取绝对路径 String realPath = this.getServletContext().getRealPath("/img/WP_20131005_002.jpg"); //2.获取文件的名称 String filename = realPath.substring(realPath.lastIndexOf("\\") + 1); //3.设置响应头content-disposition控制浏览器以下载的方式打开文件 resp.setHeader("content-disposition","attachment;filename="+filename); //4.获取文件的输入流 InputStream in = new FileInputStream(realPath); //5.获取输出流 OutputStream outputStream = resp.getOutputStream(); //6.将输入流写入到输出流中 byte[] buffer = new byte[4096]; int len = -1; while ((len=in.read(buffer,0,4096))!=-1)&#123; outputStream.write(buffer,0,len); &#125; outputStream.close(); &#125;&#125; 运行结果如下所示： 范例：**使用Response实现中文文件下载** 下载中文文件时，需要注意的地方就是中文文件名要使用URLEncoder.encode方法进行编码(URLEncoder.encode(fileName, “字符编码”))，否则会出现文件名乱码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package gacl.response.study;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.PrintWriter;import java.net.URLEncoder;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author gacl * 文件下载 */public class ResponseDemo02 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; downloadChineseFileByOutputStream(response);//下载中文文件 &#125; /** * 下载中文文件,中文文件下载时，文件名要经过URL编码，否则会出现文件名乱码 * @param response * @throws FileNotFoundException * @throws IOException */ private void downloadChineseFileByOutputStream(HttpServletResponse response) throws FileNotFoundException, IOException &#123; String realPath = this.getServletContext().getRealPath("/download/张家界国家森林公园.JPG");//获取要下载的文件的绝对路径 String fileName = realPath.substring(realPath.lastIndexOf("\\")+1);//获取要下载的文件名 //设置content-disposition响应头控制浏览器以下载的形式打开文件，中文文件名要使用URLEncoder.encode方法进行编码，否则会出现文件名乱码 response.setHeader("content-disposition", "attachment;filename="+URLEncoder.encode(fileName, "UTF-8")); InputStream in = new FileInputStream(realPath);//获取文件输入流 int len = 0; byte[] buffer = new byte[1024]; OutputStream out = response.getOutputStream(); while ((len = in.read(buffer)) &gt; 0) &#123; out.write(buffer,0,len);//将缓冲区的数据输出到客户端浏览器 &#125; in.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 运行结果如下所示： 文件下载注意事项：编写文件下载功能时推荐使用OutputStream流，避免使用PrintWriter流，因为OutputStream流是字节流，可以处理任意类型的数据，而PrintWriter流是字符流，只能处理字符数据，如果用字符流处理字节数据，会导致数据丢失。 范例：使用PrintWriter流下载文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package gacl.response.study;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.PrintWriter;import java.net.URLEncoder;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author gacl * 文件下载 */public class ResponseDemo02 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; downloadFileByPrintWriter(response);//下载文件，通过PrintWriter流 &#125; /** * 下载文件，通过PrintWriter流，虽然也能够实现下载，但是会导致数据丢失，因此不推荐使用PrintWriter流下载文件 * @param response * @throws FileNotFoundException * @throws IOException */ private void downloadFileByPrintWriter(HttpServletResponse response) throws FileNotFoundException, IOException &#123; String realPath = this.getServletContext().getRealPath("/download/张家界国家森林公园.JPG");//获取要下载的文件的绝对路径 String fileName = realPath.substring(realPath.lastIndexOf("\\")+1);//获取要下载的文件名 //设置content-disposition响应头控制浏览器以下载的形式打开文件，中文文件名要使用URLEncoder.encode方法进行编码 response.setHeader("content-disposition", "attachment;filename="+URLEncoder.encode(fileName, "UTF-8")); FileReader in = new FileReader(realPath); int len = 0; char[] buffer = new char[1024]; PrintWriter out = response.getWriter(); while ((len = in.read(buffer)) &gt; 0) &#123; out.write(buffer,0,len);//将缓冲区的数据输出到客户端浏览器 &#125; in.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 运行结果如下： 正常弹出下载框，此时我们点击【保存】按钮将文件下载下来，如下所示： 可以看到，只下载了5.25MB，而这张图片的原始大小却是 这说明在下载的时候数据丢失了，所以下载不完全，所以这张图片虽然能够正常下载下来，但是却是无法打开的，因为丢失掉了部分数据，如下所示： 所以使用PrintWriter流处理字节数据，会导致数据丢失，这一点千万要注意，因此在编写下载文件功能时，要使用OutputStream流，避免使用PrintWriter流，因为OutputStream流是字节流，可以处理任意类型的数据，而PrintWriter流是字符流，只能处理字符数据，如果用字符流处理字节数据，会导致数据丢失。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(六)--Servlet开发(二)]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%85%AD-Servlet%E5%BC%80%E5%8F%91-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 一、ServletConfig讲解1.1、通过ServletConfig获取Servlet的初始化参数 当servlet配置了初始化参数后，web容器在创建servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时，将ServletConfig对象传递给servlet。进而，我们通过ServletConfig对象就可以得到当前servlet的初始化参数信息。 ​ 例如: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package org.wuqinghua.java.ch01;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.annotation.WebInitParam;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Enumeration;/** * Created by wuqinghua on 17/6/30. */@WebServlet(name = "servletConfigDemo01",urlPatterns = &#123;"/servletConfigDemo01"&#125;,initParams =&#123;@WebInitParam(name = "name",value = "gacl"),@WebInitParam(name = "password",value = "123"),@WebInitParam(name = "charset",value = "UTF-8")&#125; )public class ServletConfigDemo01 extends HttpServlet &#123; //定义ServletConfig对象来接受配置的初始化参数 private ServletConfig servletConfig; /** *当servlet配置了初始化参数后，web容器在创建servlet实例对象时， * 会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时， * 将servletConfig对象传递给servlet。进而，通过ServletConfig对象就可以得到初始化数据 */ @Override public void init(ServletConfig config) throws ServletException &#123; this.servletConfig = config; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取配置的参数 String paramVal = this.servletConfig.getInitParameter("name"); resp.getWriter().print(paramVal); resp.getWriter().print("&lt;hr /&gt;"); //获取所有初始化参数 Enumeration&lt;String&gt; e = this.servletConfig.getInitParameterNames(); while (e.hasMoreElements())&#123; String name = e.nextElement(); String value = this.servletConfig.getInitParameter(name); resp.getWriter().print(name+"-"+value+"&lt;br /&gt;"); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 运行结果如下： 二、ServletContext对象 WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用。 ServletConfig对象中维护了ServletContext对象的引用，开发人员在编写servlet时，可以通过ServletConfig.getServletContext方法获得ServletContext对象。 由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。 三、ServletContext的应用 3.1、多个Servlet通过ServletContext对象实现数据共享 范例：ServletContextDemo1和ServletContextDemo2通过ServletContext对象实现数据共享 1234567891011121314151617181920212223242526272829303132333435package org.wuqinghua.java.ch01;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebInitParam;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/servletContextDemo01",initParams = @WebInitParam(name = "name",value = "hello"))public class ServletContextDemo01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String data = "xdp_gacl"; /** * 获取ServletContext */ ServletContext servletContext = this.getServletConfig().getServletContext(); ServletContext servletContext1 = this.getServletContext(); System.out.println(servletContext == servletContext1); System.out.println(this.getServletConfig().getInitParameter("name")); servletContext.setAttribute("data", data); &#125;&#125; 1234567891011121314151617181920212223package org.wuqinghua.java.ch01;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/servletContextDemo02")public class ServletContextDemo02 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext servletContext = this.getServletContext(); String data = (String) servletContext.getAttribute("data"); resp.getWriter().print("data="+data); &#125;&#125; 先运行ServletContextDemo1，将数据data存储到ServletContext对象中，然后运行ServletContextDemo2就可以从ServletContext对象中取出数据了，这样就实现了数据共享，如下图所示： 3.2、获取WEB应用的初始化参数 在web.xml文件中使用标签配置WEB应用的初始化参数，如下所示： 1234&lt;context-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql://localhost:3306/test&lt;/param-value&gt;&lt;/context-param&gt; 获取参数代码： 1234567891011121314151617181920212223package org.wuqinghua.java.ch01;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet("/servletContextDemo03")public class ServletContextDemo03 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取servletContext ServletContext servletContext = this.getServletContext(); String url = servletContext.getInitParameter("url"); resp.getWriter().print(url); &#125;&#125; 运行结果： 3.3、用servletContext实现请求转发1234567891011121314151617181920212223242526package org.wuqinghua.java.ch01;import javax.servlet.RequestDispatcher;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = &#123;"/servletContextDemo04"&#125;)public class ServletContextDemo04 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String data = "&lt;h1&gt;&lt;font color='red'&gt;abcdefghijkl&lt;/font&gt;&lt;/h1&gt;"; resp.getOutputStream().write(data.getBytes()); ServletContext servletContext = this.getServletContext(); RequestDispatcher rd = servletContext.getRequestDispatcher("/servletContextDemo05"); rd.forward(req,resp); &#125;&#125; 12345678910111213141516171819package org.wuqinghua.java.ch01;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/servletContextDemo05")public class ServletContextDemo05 extends HttpServlet&#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.getOutputStream().write("servletContextDemo05".getBytes()); &#125;&#125; 运行结果： 访问的是ServletContextDemo4，浏览器显示的却是ServletContextDemo5的内容，这就是使用ServletContext实现了请求转发 3.4、利用ServletContext对象读取资源文件项目目录结构如下： 代码范例：使用servletContext读取资源文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137package gacl.servlet.study;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.text.MessageFormat;import java.util.Properties;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 使用servletContext读取资源文件 * * @author gacl * */public class ServletContextDemo6 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * response.setContentType("text/html;charset=UTF-8");目的是控制浏览器用UTF-8进行解码； * 这样就不会出现中文乱码了 */ response.setHeader("content-type","text/html;charset=UTF-8"); readSrcDirPropCfgFile(response);//读取src目录下的properties配置文件 response.getWriter().println("&lt;hr/&gt;"); readWebRootDirPropCfgFile(response);//读取WebRoot目录下的properties配置文件 response.getWriter().println("&lt;hr/&gt;"); readPropCfgFile(response);//读取src目录下的db.config包中的db3.properties配置文件 response.getWriter().println("&lt;hr/&gt;"); readPropCfgFile2(response);//读取src目录下的gacl.servlet.study包中的db4.properties配置文件 &#125; /** * 读取src目录下的gacl.servlet.study包中的db4.properties配置文件 * @param response * @throws IOException */ private void readPropCfgFile2(HttpServletResponse response) throws IOException &#123; InputStream in = this.getServletContext().getResourceAsStream("/WEB-INF/classes/gacl/servlet/study/db4.properties"); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty("driver"); String url = prop.getProperty("url"); String username = prop.getProperty("username"); String password = prop.getProperty("password"); response.getWriter().println("读取src目录下的gacl.servlet.study包中的db4.properties配置文件："); response.getWriter().println( MessageFormat.format( "driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;", driver,url, username, password)); &#125; /** * 读取src目录下的db.config包中的db3.properties配置文件 * @param response * @throws FileNotFoundException * @throws IOException */ private void readPropCfgFile(HttpServletResponse response) throws FileNotFoundException, IOException &#123; //通过ServletContext获取web资源的绝对路径 String path = this.getServletContext().getRealPath("/WEB-INF/classes/db/config/db3.properties"); InputStream in = new FileInputStream(path); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty("driver"); String url = prop.getProperty("url"); String username = prop.getProperty("username"); String password = prop.getProperty("password"); response.getWriter().println("读取src目录下的db.config包中的db3.properties配置文件："); response.getWriter().println( MessageFormat.format( "driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;", driver,url, username, password)); &#125; /** * 通过ServletContext对象读取WebRoot目录下的properties配置文件 * @param response * @throws IOException */ private void readWebRootDirPropCfgFile(HttpServletResponse response) throws IOException &#123; /** * 通过ServletContext对象读取WebRoot目录下的properties配置文件 * “/”代表的是项目根目录 */ InputStream in = this.getServletContext().getResourceAsStream("/db2.properties"); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty("driver"); String url = prop.getProperty("url"); String username = prop.getProperty("username"); String password = prop.getProperty("password"); response.getWriter().println("读取WebRoot目录下的db2.properties配置文件："); response.getWriter().print( MessageFormat.format( "driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;", driver,url, username, password)); &#125; /** * 通过ServletContext对象读取src目录下的properties配置文件 * @param response * @throws IOException */ private void readSrcDirPropCfgFile(HttpServletResponse response) throws IOException &#123; /** * 通过ServletContext对象读取src目录下的db1.properties配置文件 */ InputStream in = this.getServletContext().getResourceAsStream("/WEB-INF/classes/db1.properties"); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty("driver"); String url = prop.getProperty("url"); String username = prop.getProperty("username"); String password = prop.getProperty("password"); response.getWriter().println("读取src目录下的db1.properties配置文件："); response.getWriter().println( MessageFormat.format( "driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;", driver,url, username, password)); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 运行结果如下： 代码范例：使用类装载器读取资源文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package gacl.servlet.study;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.text.MessageFormat;import java.util.Properties;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 用类装载器读取资源文件 * 通过类装载器读取资源文件的注意事项:不适合装载大文件，否则会导致jvm内存溢出 * @author gacl * */public class ServletContextDemo7 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * response.setContentType("text/html;charset=UTF-8");目的是控制浏览器用UTF-8进行解码； * 这样就不会出现中文乱码了 */ response.setHeader("content-type","text/html;charset=UTF-8"); test1(response); response.getWriter().println("&lt;hr/&gt;"); test2(response); response.getWriter().println("&lt;hr/&gt;"); //test3(); test4(); &#125; /** * 读取类路径下的资源文件 * @param response * @throws IOException */ private void test1(HttpServletResponse response) throws IOException &#123; //获取到装载当前类的类装载器 ClassLoader loader = ServletContextDemo7.class.getClassLoader(); //用类装载器读取src目录下的db1.properties配置文件 InputStream in = loader.getResourceAsStream("db1.properties"); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty("driver"); String url = prop.getProperty("url"); String username = prop.getProperty("username"); String password = prop.getProperty("password"); response.getWriter().println("用类装载器读取src目录下的db1.properties配置文件："); response.getWriter().println( MessageFormat.format( "driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;", driver,url, username, password)); &#125; /** * 读取类路径下面、包下面的资源文件 * @param response * @throws IOException */ private void test2(HttpServletResponse response) throws IOException &#123; //获取到装载当前类的类装载器 ClassLoader loader = ServletContextDemo7.class.getClassLoader(); //用类装载器读取src目录下的gacl.servlet.study包中的db4.properties配置文件 InputStream in = loader.getResourceAsStream("gacl/servlet/study/db4.properties"); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty("driver"); String url = prop.getProperty("url"); String username = prop.getProperty("username"); String password = prop.getProperty("password"); response.getWriter().println("用类装载器读取src目录下的gacl.servlet.study包中的db4.properties配置文件："); response.getWriter().println( MessageFormat.format( "driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;", driver,url, username, password)); &#125; /** * 通过类装载器读取资源文件的注意事项:不适合装载大文件，否则会导致jvm内存溢出 */ public void test3() &#123; /** * 01.avi是一个150多M的文件，使用类加载器去读取这个大文件时会导致内存溢出： * java.lang.OutOfMemoryError: Java heap space */ InputStream in = ServletContextDemo7.class.getClassLoader().getResourceAsStream("01.avi"); System.out.println(in); &#125; /** * 读取01.avi,并拷贝到e:\根目录下 * 01.avi文件太大，只能用servletContext去读取 * @throws IOException */ public void test4() throws IOException &#123; // path=G:\Java学习视频\JavaWeb学习视频\JavaWeb\day05视频\01.avi // path=01.avi String path = this.getServletContext().getRealPath("/WEB-INF/classes/01.avi"); /** * path.lastIndexOf("\\") + 1是一个非常绝妙的写法 */ String filename = path.substring(path.lastIndexOf("\\") + 1);//获取文件名 InputStream in = this.getServletContext().getResourceAsStream("/WEB-INF/classes/01.avi"); byte buffer[] = new byte[1024]; int len = 0; OutputStream out = new FileOutputStream("e:\\" + filename); while ((len = in.read(buffer)) &gt; 0) &#123; out.write(buffer, 0, len); &#125; out.close(); in.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 运行结果如下： 四、在客户端缓存Servlet的输出 对于不经常变化的数据，在servlet中可以为其设置合理的缓存时间值，以避免浏览器频繁向服务器发送请求，提升服务器的性能。例如： 1234567891011121314151617181920212223242526272829package gacl.servlet.study;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ServletDemo5 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String data = "abcddfwerwesfasfsadf"; /** * 设置数据合理的缓存时间值，以避免浏览器频繁向服务器发送请求，提升服务器的性能 * 这里是将数据的缓存时间设置为1天 */ response.setDateHeader("expires",System.currentTimeMillis() + 24 * 3600 * 1000); response.getOutputStream().write(data.getBytes()); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(五)--Servlet开发(一)]]></title>
    <url>%2F2017%2F06%2F29%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%BA%94-Servlet%E5%BC%80%E5%8F%91-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[[TOC] 一、Servlet简介 Servlet是sun公司提供的一门用于开发动态web资源的技术。 Sun公司在其API中提供了一个servlet接口，用户若想用发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤： 1、编写一个Java类，实现servlet接口。 2、把开发好的Java类部署到web服务器中。 按照一种约定俗成的称呼习惯，通常我们也把实现了servlet接口的java程序，称之为Servlet 二、Servlet的运行过程Servlet程序是由WEB服务器调用，web服务器收到客户端的Servlet访问请求后： ①Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第②步。 ②装载并创建该Servlet的一个实例对象。 ③调用Servlet实例对象的init()方法。 ④创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。 ⑤WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。 三、Servlet调用图 四、在Eclipse中开发Servlet 在eclipse中新建一个web project工程，eclipse会自动创建下图所示目录结构： 4.1、Servlet接口实现类 Servlet接口SUN公司定义了两个默认实现类，分别为：GenericServlet、HttpServlet。 HttpServlet指能够处理HTTP请求的servlet，它在原有Servlet接口上添加了一些与HTTP协议处理方法，它比Servlet接口的功能更为强大。因此开发人员在编写Servlet时，通常应继承这个类，而避免直接去实现Servlet接口。 HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。因此，开发人员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法。 4.2、通过Eclipse创建和编写Servlet 选中gacl.servlet.study包，右键→New→Servlet，如下图所示： 这样，我们就通过Eclipse帮我们创建好一个名字为ServletDemo1的Servlet，创建好的ServletDemo01里面会有如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 package gacl.servlet.study; import java.io.IOException; import java.io.PrintWriter; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;public class ServletDemo1 extends HttpServlet &#123; /** * The doGet method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to get. * * @param request the request send by the client to the server * @param response the response send by the server to the client * @throws ServletException if an error occurred * @throws IOException if an error occurred */ public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html"); PrintWriter out = response.getWriter(); out.println("&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;"); out.println("&lt;HTML&gt;"); out.println(" &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;"); out.println(" &lt;BODY&gt;"); out.print(" This is "); out.print(this.getClass()); out.println(", using the GET method"); out.println(" &lt;/BODY&gt;"); out.println("&lt;/HTML&gt;"); out.flush(); out.close(); &#125; /** * The doPost method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to post. * * @param request the request send by the client to the server * @param response the response send by the server to the client * @throws ServletException if an error occurred * @throws IOException if an error occurred */ public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html"); PrintWriter out = response.getWriter(); out.println("&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;"); out.println("&lt;HTML&gt;"); out.println(" &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;"); out.println(" &lt;BODY&gt;"); out.print(" This is "); out.print(this.getClass()); out.println(", using the POST method"); out.println(" &lt;/BODY&gt;"); out.println("&lt;/HTML&gt;"); out.flush(); out.close(); &#125;&#125; 这些代码都是Eclipse自动生成的，而web.xml文件中也多了和两对标签，这两对标签是配置ServletDemo1的，如下图所示： 然后我们就可以通过浏览器访问ServletDemo1这个Servlet，如下图所示： 五、Servlet开发注意细节5.1、Servlet访问URL映射配置 由于客户端是通过URL地址访问web服务器中的资源，所以Servlet程序若想被外界访问，必须把servlet程序映射到一个URL地址上，这个工作在web.xml文件中使用元素和元素完成。 元素用于注册Servlet，它包含有两个主要的子元素：和，分别用于设置Servlet的注册名称和Servlet的完整类名。一个元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：和，分别用于指定Servlet的注册名称和Servlet的对外访问路径。例如： 123456789&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;gacl.servlet.study.ServletDemo1&lt;/servlet-class&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/ServletDemo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 同一个Servlet可以被映射到多个URL上，即多个元素的子元素的设置值可以是同一个Servlet的注册名。 例如： 12345678910111213141516171819202122232425 &lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;gacl.servlet.study.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/ServletDemo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/1.htm&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/2.jsp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/3.php&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/4.ASPX&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 通过上面的配置，当我们想访问名称是ServletDemo1的Servlet，可以使用如下的几个地址去访问： http://localhost:8080/JavaWeb_Servlet_Study_20140531**/servlet/ServletDemo1** http://localhost:8080/JavaWeb_Servlet_Study_20140531**/1.htm** http://localhost:8080/JavaWeb_Servlet_Study_20140531**/2.jsp** http://localhost:8080/JavaWeb_Servlet_Study_20140531**/3.php** http://localhost:8080/JavaWeb_Servlet_Study_20140531**/4.ASPX** ServletDemo1被映射到了多个URL上。 5.2、Servlet访问URL使用*通配符映射 在Servlet映射到的URL中也可以使用*通配符，但是只能有两种固定的格式：一种格式是”.扩展名”，另一种格式是以正斜杠（/）开头并以”/“结尾。例如： 12345678&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;gacl.servlet.study.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; *可以匹配任意的字符，所以此时可以用任意的URL去访问ServletDemo1这个Servlet，如下图所示： 对于如下的一些映射关系： Servlet1 映射到 /abc/ Servlet2 映射到 / Servlet3 映射到 /abc Servlet4 映射到 .do问题： 当请求URL为“/abc/a.html”，“/abc/”和“/”都匹配，哪个servlet响应​ Servlet引擎将调用Servlet1。 当请求URL为“/abc”时，“/abc/”和“/abc”都匹配，哪个servlet响应​ Servlet引擎将调用Servlet3。 当请求URL为“/abc/a.do”时，“/abc/”和“.do”都匹配，哪个servlet响应​ Servlet引擎将调用Servlet1。 当请求URL为“/a.do”时，“/”和“.do”都匹配，哪个servlet响应​ Servlet引擎将调用Servlet2。 当请求URL为“/xxx/yyy/a.do”时，“/”和“.do”都匹配，哪个servlet响应​ Servlet引擎将调用Servlet2。 匹配的原则就是”谁长得更像就找谁” 5.3、Servlet与普通Java类的区别 Servlet是一个供其他Java程序（Servlet引擎）调用的Java类，它不能独立运行，它的运行完全由Servlet引擎来控制和调度。 针对客户端的多次Servlet请求，通常情况下，服务器只会创建一个Servlet实例对象，也就是说Servlet实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至web容器退出，servlet实例对象才会销毁。 在Servlet的整个生命周期内，Servlet的init方法只被调用一次。而对一个Servlet的每次访问请求都导致Servlet引擎调用一次servlet的service方法。对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。 如果在元素中配置了一个元素，那么WEB应用程序在启动时，就会装载并创建Servlet的实例对象、以及调用Servlet实例对象的init()方法。​ 举例：​ ​ invoker​ ​ org.apache.catalina.servlets.InvokerServlet​ ​ 1​ 用途：为web应用写一个InitServlet，这个servlet配置为启动时装载，为整个web应用创建必要的数据库表和数据。 5.4、缺省Servlet 如果某个Servlet的映射路径仅仅为一个正斜杠（/），那么这个Servlet就成为当前Web应用程序的缺省Servlet。 凡是在web.xml文件中找不到匹配的元素的URL，它们的访问请求都将交给缺省Servlet处理，也就是说，缺省Servlet用于处理所有其他Servlet都不处理的访问请求。 例如： 1234567891011&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo2&lt;/servlet-name&gt; &lt;servlet-class&gt;gacl.servlet.study.ServletDemo2&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 将ServletDemo2配置成缺省Servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo2&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 当访问不存在的Servlet时，就使用配置的默认Servlet进行处理，如下图所示： 在\conf\web.xml文件中，注册了一个名称为org.apache.catalina.servlets.DefaultServlet的Servlet，并将这个Servlet设置为了缺省Servlet。 12345678910111213141516171819 &lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- The mapping for the default servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 当访问Tomcat服务器中的某个静态HTML文件和图片时，实际上是在访问这个缺省Servlet。 5.5、Servlet的线程安全问题 当多个客户端并发访问同一个Servlet时，web服务器会为每一个客户端的访问请求创建一个线程，并在这个线程上调用Servlet的service方法，因此service方法内如果访问了同一个资源的话，就有可能引发线程安全问题。例如下面的代码： 不存在线程安全问题的代码： 12345678910111213141516171819202122232425262728293031323334 package gacl.servlet.study; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ServletDemo3 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * 当多线程并发访问这个方法里面的代码时，会存在线程安全问题吗 * i变量被多个线程并发访问，但是没有线程安全问题，因为i是doGet方法里面的局部变量， * 当有多个线程并发访问doGet方法时，每一个线程里面都有自己的i变量， * 各个线程操作的都是自己的i变量，所以不存在线程安全问题 * 多线程并发访问某一个方法的时候，如果在方法内部定义了一些资源(变量，集合等) * 那么每一个线程都有这些东西，所以就不存在线程安全问题了 */ int i=1; i++; response.getWriter().write(i); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 存在线程安全问题的代码： 123456789101112131415161718192021222324252627282930package gacl.servlet.study; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ServletDemo3 extends HttpServlet &#123; int i=1; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; i++; try &#123; Thread.sleep(1000*4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; response.getWriter().write(i+""); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 把i定义成全局变量，当多个线程并发访问变量i时，就会存在线程安全问题了，如下图所示：同时开启两个浏览器模拟并发访问同一个Servlet，本来正常来说，第一个浏览器应该看到2，而第二个浏览器应该看到3的，结果两个浏览器都看到了3，这就不正常。 线程安全问题只存在多个线程并发操作同一个资源的情况下，所以在编写Servlet的时候，如果并发访问某一个资源(变量，集合等)，就会存在线程安全问题，那么该如何解决这个问题呢？ 先看看下面的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041 package gacl.servlet.study; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ServletDemo3 extends HttpServlet &#123; int i=1; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * 加了synchronized后，并发访问i时就不存在线程安全问题了， * 为什么加了synchronized后就没有线程安全问题了呢？ * 假如现在有一个线程访问Servlet对象，那么它就先拿到了Servlet对象的那把锁 * 等到它执行完之后才会把锁还给Servlet对象，由于是它先拿到了Servlet对象的那把锁， * 所以当有别的线程来访问这个Servlet对象时，由于锁已经被之前的线程拿走了，后面的线程只能排队等候了 * */ synchronized (this) &#123;//在java中，每一个对象都有一把锁，这里的this指的就是Servlet对象 i++; try &#123; Thread.sleep(1000*4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; response.getWriter().write(i+""); &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 现在这种做法是给Servlet对象加了一把锁，保证任何时候都只有一个线程在访问该Servlet对象里面的资源，这样就不存在线程安全问题了，如下图所示： 这种做法虽然解决了线程安全问题，但是编写Servlet却万万不能用这种方式处理线程安全问题，假如有9999个人同时访问这个Servlet，那么这9999个人必须按先后顺序排队轮流访问。 针对Servlet的线程安全问题，Sun公司是提供有解决方案的：让Servlet去实现一个SingleThreadModel接口，如果某个Servlet实现了SingleThreadModel接口，那么Servlet引擎将以单线程模式来调用其service方法。 查看Sevlet的API可以看到，SingleThreadModel接口中没有定义任何方法和常量，在Java中，把没有定义任何方法和常量的接口称之为标记接口，经常看到的一个最典型的标记接口就是”Serializable“，这个接口也是没有定义任何方法和常量的，标记接口在Java中有什么用呢？主要作用就是给某个对象打上一个标志，告诉JVM，这个对象可以做什么，比如实现了”Serializable“接口的类的对象就可以被序列化，还有一个”Cloneable”接口，这个也是一个标记接口，在默认情况下，Java中的对象是不允许被克隆的，就像现实生活中的人一样，不允许克隆，但是只要实现了”Cloneable”接口，那么对象就可以被克隆了。 让Servlet实现了SingleThreadModel接口，只要在Servlet类的定义中增加实现SingleThreadModel接口的声明即可。 对于实现了SingleThreadModel接口的Servlet，Servlet引擎仍然支持对该Servlet的多线程并发访问，其采用的方式是产生多个Servlet实例对象，并发的每个线程分别调用一个独立的Servlet实例对象。 实现SingleThreadModel接口并不能真正解决Servlet的线程安全问题，因为Servlet引擎会创建多个Servlet实例对象，而真正意义上解决多线程安全问题是指一个Servlet实例对象被多个线程同时调用的问题。事实上，在Servlet API 2.4中，已经将SingleThreadModel标记为Deprecated（过时的）。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(四)--Http协议]]></title>
    <url>%2F2017%2F06%2F28%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%9B%9B-Http%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[[TOC] 一、什么是HTTP协议 HTTP是hypertext transfer protocol（超文本传输协议）的简写，它是TCP/IP协议的一个应用层协议，用于定义WEB浏览器与WEB服务器之间交换数据的过程。客户端连上web服务器后，若想获得web服务器中的某个web资源，需遵守一定的通讯格式，HTTP协议用于定义客户端与web服务器通迅的格式。 二、HTTP协议的版本 HTTP协议的版本：HTTP/1.0、HTTP/1.1 三、HTTP1.0和HTTP1.1的区别 在HTTP1.0协议中，客户端与web服务器建立连接后，只能获得一个web资源。 在HTTP1.1协议，允许客户端与web服务器建立连接后，在一个连接上获取多个web资源。 四、HTTP请求4.1、HTTP请求包括的内容 客户端连上服务器后，向服务器请求某个web资源，称之为客户端向服务器发送了一个HTTP请求。 一个完整的HTTP请求包括如下内容：一个请求行、若干消息头、以及实体内容范例： 4.2、HTTP请求的细节——请求行 请求行中的GET称之为请求方式，请求方式有：POST、GET、HEAD、OPTIONS、DELETE、TRACE、PUT，常用的有： GET、 POST 用户如果没有设置，默认情况下浏览器向服务器发送的都是get请求，例如在浏览器直接输地址访问，点超链接访问等都是get，用户如想把请求方式改为post，可通过更改表单的提交方式实现。 不管POST或GET，都用于向服务器请求某个WEB资源，这两种方式的区别主要表现在数据传递上：如果请求方式为GET方式，则可以在请求的URL地址后以?的形式带上交给服务器的数据，多个数据之间以&amp;进行分隔，例如：GET /mail/1.html?name=abc&amp;password=xyz HTTP/1.1 GET方式的特点：在URL地址后附带的参数是有限制的，其数据容量通常不能超过1K。 如果请求方式为POST方式，则可以在请求的实体内容中向服务器发送数据，Post方式的特点：传送的数据量无限制。 4.3、HTTP请求的细节——消息头 HTTP请求中的常用消息头 accept:浏览器通过这个头告诉服务器，它所支持的数据类型 Accept-Charset: 浏览器通过这个头告诉服务器，它支持哪种字符集 Accept-Encoding：浏览器通过这个头告诉服务器，支持的压缩格式 Accept-Language：浏览器通过这个头告诉服务器，它的语言环境 Host：浏览器通过这个头告诉服务器，想访问哪台主机 If-Modified-Since: 浏览器通过这个头告诉服务器，缓存数据的时间 Referer：浏览器通过这个头告诉服务器，客户机是哪个页面来的 防盗链 Connection：浏览器通过这个头告诉服务器，请求完后是断开链接还是何持链接 例如： 12345678Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*Referer: http://localhost:8080/JavaWebDemoProject/Web/2.jspAccept-Language: zh-CNUser-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; InfoPath.3)Accept-Encoding: gzip, deflateHost: localhost:8080Connection: Keep-Alive 五、HTTP响应5.1、HTTP响应包括的内容 一个HTTP响应代表服务器向客户端回送的数据，它包括： 一个状态行、若干消息头、以及实体内容 。 范例： 1234567891011121314 HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Content-Type: text/html;charset=ISO-8859-1 Content-Length: 105 Date: Tue, 27 May 2014 16:23:28 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello World JSP&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello World! &lt;/body&gt;&lt;/html&gt; 5.2、HTTP响应的细节——状态行 状态行格式： HTTP版本号 状态码 原因叙述​ 举例：HTTP/1.1 200 OK 状态码用于表示服务器对请求的处理结果，它是一个三位的十进制数。响应状态码分为5类，如下所示： 5.3、HTTP响应细节——常用响应头 HTTP响应中的常用响应头(消息头) Location: 服务器通过这个头，来告诉浏览器跳到哪里 Server：服务器通过这个头，告诉浏览器服务器的型号 Content-Encoding：服务器通过这个头，告诉浏览器，数据的压缩格式 Content-Length: 服务器通过这个头，告诉浏览器回送数据的长度 Content-Language: 服务器通过这个头，告诉浏览器语言环境 Content-Type：服务器通过这个头，告诉浏览器回送数据的类型 Refresh：服务器通过这个头，告诉浏览器定时刷新 Content-Disposition: 服务器通过这个头，告诉浏览器以下载方式打数据 Transfer-Encoding：服务器通过这个头，告诉浏览器数据是以分块方式回送的 Expires: -1 控制浏览器不要缓存 Cache-Control: no-cache Pragma: no-cache 六、在服务端设置响应头来控制客户端浏览器###6.1、设置Location响应头，实现请求重定向 123456789101112131415161718192021222324252627package org.wuqinghua.java.ch01;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/27. * 设置Location响应头，实现请求重定向 */public class ServletDemo01 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setStatus(302);//设置服务器的响应状态码 /** *设置响应头，服务器通过Location这个头，来告诉浏览器跳到哪里，这就是所谓的请求的重定向 */ resp.setHeader("Location","/JavaWeb_HttpProtocol_Study_20140528/1.jsp"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 当在浏览器中使用URL地址”http://localhost:8080/JavaWeb_HttpProtocol_Study_20140528/servlet/ServletDemo01&quot;访问ServletDemo01时，就可以看到服务器作出响应后发送到浏览器的状态码和响应头信息，如下图所示： 服务器返回一个302状态码告诉浏览器，你要的资源我没有，但是我通过Location响应头告诉你哪里有，而浏览器解析响应头Location后知道要跳转到/JavaWeb_HttpProtocol_Study_20140528/1.jsp页面，所以就会自动跳转到1.jsp，如下图所示： 6.2、设置Content-Encoding响应头，告诉浏览器数据的压缩格式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package org.wuqinghua.java.ch01;import com.sun.xml.internal.messaging.saaj.util.ByteOutputStream;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.zip.GZIPOutputStream;/** * Created by wuqinghua on 17/6/29. * 这个程序主要两个知识点 * 1.使用GZIPOutputStream流来压缩数据 * 2.通过响应头Content-Encoding来告诉浏览器，服务器端发送的数据压缩格式 */public class ServletDemo02 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String data = "abcdabcdabcdabcdabcdabcdab" + "cdabcdabcdabcdabcdabcdabcdabcdabc" + "dabcdabcdabcdabcdabcdabcdabcdabc" + "dabcdabcdabcdabcdabcdabcdabcdabcdab" + "cdabcdabcdabcdabcdabcdabcdabcdabcdab" + "cdabcdabcdabcdabcdabcdabcdabcdabcdab" + "cdabcdabcdabcdabcdabcdabcdabcdabcdab" + "cdabcdabcdabcdabcdabcdabcdabcdabcdabcd"; System.out.println("原始数据大小:"+data.getBytes().length); ByteOutputStream bout = new ByteOutputStream(); GZIPOutputStream gout = new GZIPOutputStream(bout); gout.write(data.getBytes()); gout.close(); //获取压缩后的数据 byte[] g = bout.toByteArray(); resp.setHeader("Content-Encoding","gzip"); resp.setHeader("Content-Length",g.length+""); resp.getOutputStream().write(g); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 服务器发给浏览器的响应信息如下： 浏览器支持的压缩格式有： 6.3、设置Content-type响应头，指定回送数据类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546package org.wuqinghua.java.ch01;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;/** * Created by wuqinghua on 17/6/29. */public class ServletDemo03 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; /** * 浏览器能接收(Accept)的数据类型有: * application/x-ms-application, * image/jpeg, * application/xaml+xml, * image/gif, * image/jpeg, * application/x-ms-xbap, * application/vnd.ms-excel, * application/vnd.ms-powerpoint, * application/msword, */ resp.setHeader("Content-type", "image/jpeg");//使用content-type响应头指定发送给浏览器的数据类型为image/jpeg //读入图片 InputStream in = this.getServletContext().getResourceAsStream("/img/WP_20131005_002.jpg"); byte buffer[] = new byte[1024]; int len = -1; OutputStream out = resp.getOutputStream(); while ((len = in.read(buffer, 0, buffer.length)) != -1) &#123; out.write(buffer, 0, len); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 服务器发给浏览器的响应信息如下： ServletDemo03的运行结果如下图所示： 在浏览器中显示出了图片 6.4、设置refresh响应头，让浏览器定时刷新1234567891011121314151617181920212223242526272829303132package org.wuqinghua.java.ch01;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/29. */@WebServlet(name = "servletDemo04",urlPatterns = &#123;"/servletDemo04"&#125;)public class ServletDemo04 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; /** * 设置refresh响应头，让浏览器每隔3秒定时刷新 */// resp.setHeader("refresh","3"); /** * 设置refresh响应头，让浏览器3秒后跳转到http://www.baidu.com */ resp.setHeader("refresh", "3;url='http://www.baidu.com'"); resp.getWriter().write("gacl"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 6.5、设置content－disposition响应头，让浏览器下载 123456789101112131415161718192021222324252627282930313233343536package org.wuqinghua.java.ch01;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;/** * Created by wuqinghua on 17/6/29. */@WebServlet(name = "servletDemo05", urlPatterns = &#123;"/servletDemo05"&#125;)public class ServletDemo05 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; /** * 设置content－disposition响应头，让浏览器下载文件 */ resp.setHeader("content-disposition", "attachment;filename=xxx.jpg"); InputStream in = this.getServletContext().getResourceAsStream("/img/WP_20131005_002.jpg"); byte buffer[] = new byte[1024]; int len = -1; OutputStream out = resp.getOutputStream(); while ((len = in.read(buffer, 0, buffer.length)) != -1) &#123; out.write(buffer, 0, len); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 在浏览器中访问ServletDemo05就会弹出文件下载框，如下图所示：]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(三)——Tomcat服务器学习和使用(二)]]></title>
    <url>%2F2017%2F06%2F27%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B8%89-Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 一、打包JavaWeb应用 在Java中，使用”jar”命令来对将JavaWeb应用打包成一个War包，jar命令的用法如下： 范例：将JavaWebDemoProject这个JavaWeb应用打包成war包 执行完之后，就可以得到一个文件，平时开发完JavaWeb应用后，一般都会将JavaWeb应用打包成一个war包，然后将这个war包放到Tomcat服务器的webapps目录下，当Tomcat服务器启动时，就会自动将webapps目录下的war包解压。 比如现在将放到放到Tomcat服务器的webapps目录下 Tomcat服务器启动后会自动”Deploying web application”，将这个war文件解压缩，如下图所示： 二、Tomcat的体系结构 Tomcat服务器的启动是基于一个server.xml文件的，Tomcat启动的时候首先会启动一个Server，Server里面就会启动Service，Service里面就会启动多个”Connector(连接器)”，每一个连接器都在等待客户机的连接，当有用户使用浏览器去访问服务器上面的web资源时，首先是连接到Connector(连接器)，Connector(连接器)是不处理用户的请求的，而是将用户的请求交给一个Engine(引擎)去处理，Engine(引擎)接收到请求后就会解析用户想要访问的Host，然后将请求交给相应的Host，Host收到请求后就会解析出用户想要访问这个Host下面的哪一个Web应用,一个web应用对应一个Context。 1234567891011121314151617181920212223242526&lt;?xml version='1.0' encoding='utf-8'?&gt; &lt;Server port="8005" shutdown="SHUTDOWN"&gt; &lt;Service name="Catalina"&gt; &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; &lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11Protocol" maxThreads="150" SSLEnabled="true" scheme="https" secure="true" clientAuth="false" sslProtocol="TLS" keystoreFile="conf/.keystore" keystorePass="123456"/&gt; &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt; &lt;Engine name="Catalina" defaultHost="localhost"&gt; &lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log." suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;/Host&gt; &lt;Host name="www.gacl.cn" appBase="F:\JavaWebApps"&gt; &lt;Context path="" docBase="F:\JavaWebApps\JavaWebDemo1"/&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; 三、互联网上的加密原理 Tomcat服务器启动时候会启动多个Connector(连接器)，而Tomcat服务器的连接器又分为加密连接器和非加密连机器，比如： 这里访问的就是使用8080端口的那个连接器 123&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 这个Connector是一个没有加密的连接器，使用”http://localhost:8080/JavaWebDemoProject/Web/1.jsp&quot;去请求服务器上的web资源的这个过程中，我们的请求是不加密的，要是想以一种加密的方式来访问Tomcat服务器，那么就要在Tomcat里面配置一个加密的Connector。要配置一个加密连接器，首先应该把互联网上的加密原理弄清楚。 3.1、对称加密 采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。 需要对加密和解密使用相同密钥的加密算法。由于其速度快，对称性加密通常在消息发送方需要加密大量数据时使用。对称性加密也称为密钥加密。 所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。 加密的安全性不仅取决于加密算法本身，密钥管理的安全性更是重要。因为加密和解密都使用同一个密钥，如何把密钥安全地传递到解密者手上就成了必须要解决的问题。 常用的对称加密有：DES、IDEA、RC2、RC4、SKIPJACK、RC5、AES算法等 3.2、非对称加密 非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。另一方面，甲方可以使用乙方的公钥对机密信息进行签名后再发送给乙方；乙方再用自己的私匙对数据进行验签。 非对称加密工作原理 1.A要向B发送信息，A和B都要产生一对用于加密和解密的公钥和私钥。 2.A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。 3.A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。 4.A将这个消息发给B（已经用B的公钥加密消息）。 5.B收到这个消息后，B用自己的私钥解密A的消息。其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥 发送方使用接收方的公钥对数据加密，而接收方则使用自己的私钥解密，这样，信息就可以安全无误地到达目的地了，即使被第三方截获，由于没有相应的私钥，也无法进行解密。通过数字的手段保证加密过程是一个不可逆过程，即只有用私有密钥才能解密。 非对称性加密依然没有解决数据传输的安全性问题，比如A想向B发数据，B首先生成一对密钥(公钥和私钥)，然后将公钥发给A，A拿到B发给他的公钥有就可以使用公钥加密数据后发给B，然而在B公钥发送给A的这个过程中，很有可能会被第三方C截获，C截获到B的公钥后，也使用B的公钥加密数据，然后发给B，B接收到数据后就晕了，因为搞不清楚接收到的数据到底是A发的还是C发的，这是其中一个问题，另一个问题就是，C截获到B发的公钥后，C可以自己生成一对密钥(公钥和私钥)，然后发给A，A拿到公钥后就以为是B发给他的，然后就使用公钥加密数据发给B，发送给B的过程中被C截获下来，由于A是用C发给他的公钥加密数据的，而C有私钥，因此就可以解密A加密过后的内容了，而B接收到A发给他的数据后反而解不开了，因为数据是用C的公钥加密的，B没有C的私钥，所以就无法解密。所以，非对称性加密存在一个问题：A想向B发数据，A如何确定拿到的公钥一定是B发的呢？那么如何解决这个问题呢？只能靠一个第三方机构(CA机构，即证书授权中心(Certificate Authority )，或称证书授权机构)来担保。A想向B发数据，B首先将公钥发给CA机构，CA机构拿到B的公钥后跑到B的家里问：这是你发的公钥吗？B确认过后说是：没错，是我发的！那么此时CA机构就会为B的公钥做担保，生成一份数字证书给B，数字证书包含了CA的担保认证签名和B的公钥，B拿到CA的这份数字证书后，就发给A，A拿到数字证书后，看到上面有CA的签名，就可以确定当前拿到的公钥是B发的，那么就可以放心大胆地使用公钥加密数据，然后发给B了。 四、https连接器 明白了互联网上的加密原理之后，下面来看看浏览器与服务器交互时，浏览器想将数据加密后再发送给服务器，那么该怎么做呢？服务器首先要向浏览器出示一份数字证书，浏览器看到数字证书后，就可以使用数字证书里面的公钥加密数据，所以要想做浏览器和服务器的加密数据传输，那么首先得针对服务器生成一份数字证书。然后再配置一下服务器，让服务器收到浏览器的请求之后，会向浏览器出示它的数字证书。 4.1、生成Tomcat服务器的数字证书 SUN公司提供了制作证书的工具keytool， 在JDK 1.4以后的版本中都包含了这一工具，它的位置为\bin\keytool.exe 1keytool -genkey -alias tomcat -keyalg RSA 使用keytool生成一个名字为tomcat的证书，存放在.keystore这个密钥库中 命令执行完之后，操作系统的用户文件夹下面就会生成一个.keystore文件，如下图所示： 使用命令：keytool -list -keystore .keystore查看.keystore密钥库里面的所有证书 4.2、配置https连接器 将生成的.keystore密钥库文件拷贝到Tomcat服务器的conf目录下，如下图所示： 修改server.xml文件，配置https连接器，代码如下： 1234&lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11Protocol" maxThreads="150" SSLEnabled="true" scheme="https" secure="true" clientAuth="false" sslProtocol="TLS" keystoreFile="conf/.keystore" keystorePass="123456"/&gt; 在server.xml文件中配置了一个端口是8443的加密连接器，浏览器访问8443端口的连接器时，将会以加密的方式来访问web服务器，这个连接器收到浏览器的请求后，将会向浏览器出示一份数字证书，浏览器再用数字证书里面的公钥来加密数据，keystoreFile=”conf/.keystore” 用来指明密钥库文件的所在路径，服务器从密钥库中提取证书时需要密码，keystorePass=”123456”指明密钥库的访问密码。 使用”https://localhost:8443/&quot;访问8443的加密连接器 由于密钥库里面的证书是我们手工生成的，没有经过CA的认证，所以使用”https://localhost:8443/“ 访问8443的加密连接器，浏览器会出现”证书错误，导航已阻止”，浏览器认为当前要访问的这个主机是不安全的，不推荐继续访问，点击就可以继续访问了，如下图所示： 4.3、安装数字证书 为了让浏览器信任我们生成的数字证书，需要将数字证书安装到浏览器中，以IE8浏览器为例进行证书安装说明，安装步骤如下： 证书安装成功后，重启IE浏览器，使用”https://localhost:8443/&quot;访问8443的加密连接器，此时浏览器就不再提示证书错误了，如下图所示： 4.4、删除数字证书 以IE8为例进行说明，操作步骤如下：工具—–&gt;Internet选项 删除之后重启浏览器即可]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(二)--Tomcat服务器学习使用(一)]]></title>
    <url>%2F2017%2F06%2F27%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%BA%8C-Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[[TOC] 一、Tomcat服务器端口的配置 Tomcat的所有配置都放在conf文件夹之中，里面的server.xml文件是配置的核心文件。 如果想修改Tomcat服务器的启动端口，则可以在server.xml配置文件中的Connector节点进行的端口修改 例如：将Tomcat服务器的启动端口由默认的8080改成8081端口 Tomcat服务器启动端口默认配置 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 将Tomcat服务器启动端口修改成8081端口 123&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 这样就把原来默认Tomcat默认的的8080端口改成了8081端口了，需要注意的是，一旦服务器中的*.xml文件改变了，则Tomcat服务器就必须重新启动，重新启动之后将重新读取新的配置信息。因为已经在server.xml文件中将Tomcat的启动端口修改成了8081，所以Tomcat服务器启动时就以8081端口启动了，如下图所示： 访问Tomcat服务器也必须以新的访问端口去访问：http://localhost:8081/，如下图所示： 二、Tomcat服务器虚拟目录的映射方式 Web应用开发好后，若想供外界访问，需要把web应用所在目录交给web服务器管理，这个过程称之为虚似目录的映射。那么在Tomcat服务器中，如何进行虚拟目录的映射呢？总共有如下的几种方式： 2.1、虚拟目录的映射方式一：在server.xml文件的host元素中配置找到server.xml文件的host元素，如下图所示： 在这对标签加上即可将在F盘下的JavaWebDemoProject这个JavaWeb应用映射到JavaWebApp这个虚拟目录上，JavaWebApp这个虚拟目录是由Tomcat服务器管理的，JavaWebApp是一个硬盘上不存在的目录，是我们自己随便写的一个目录，也就是虚拟的一个目录，所以称之为”虚拟目录”，代码如下： 123456&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;Context path=&quot;/JavaWebApp&quot; docBase=&quot;F:\JavaWebDemoProject&quot; /&gt; &lt;/Host&gt; 其中，Context表示上下文，代表的就是一个JavaWeb应用，Context元素有两个属性， Ⅰ.path：用来配置虚似目录，必须以”/“开头。 Ⅱ.docBase：配置此虚似目录对应着硬盘上的Web应用所在目录。 使用浏览器访问”/JavaWebApp”这个虚拟目录下的1.jsp这个web资源，访问结果如下： 1.jsp可以正常访问，这说明我们已经成功地将将在F盘下的JavaWebDemoProject这个JavaWeb应用映射到JavaWebApp这个虚拟目录上了，访问”/JavaWebApp/1.jsp”就相当于访问”F:\JavaWebDemoProject\1.jsp” 注意：在Tomcat6之后中，不再建议在server.xml文件中使用配置context元素的方式来添加虚拟目录的映射，因为每次修改server.xml文件后，Tomcat服务器就必须要重新启动后才能重新加载server.xml文件。在Tomcat服务器的文档http://localhost:8080/docs/config/context.html中有这样的说明： It is NOT recommended to place elements directly in the server.xml file. This is because it makes modifying the Context configuration more invasive since the main conf/server.xml file cannot be reloaded without restarting Tomcat. Individual Context elements may be explicitly defined: In an individual file at /META-INF/context.xml inside the application files. Optionally (based on the Host’s copyXML attribute) this may be copied to $CATALINA_BASE/conf/[enginename]/[hostname]/ and renamed to application’s base file name plus a “.xml” extension. In individual files (with a “.xml” extension) in the $CATALINA_BASE/conf/[enginename]/[hostname]/ directory. The context path and version will be derived from the base name of the file (the file name less the .xml extension). This file will always take precedence over any context.xml file packaged in the web application’s META-INF directory. Inside a Host element in the main conf/server.xml. 2.2、虚拟目录的映射方式二：让tomcat服务器自动映射 tomcat服务器会自动管理webapps目录下的所有web应用，并把它映射成虚似目录。换句话说，tomcat服务器webapps目录中的web应用，外界可以直接访问。 例如：把F盘下的JavaWebDemoProject这个JavaWeb应用直接copy到tomcat服务器webapps目录中，如下图所示： 此时Tomcat服务器就会自动为JavaWebDemoProject这个JavaWeb应用映射一个同名的虚拟目录”/JavaWebDemoProject”，然后就可以使用浏览器访问这个JavaWeb应用的资源了，如下图所示： 2.3、虚拟目录的映射方式三 参考Tomcat服务器文档： In individual files (with a “.xml” extension) in the $CATALINA_BASE/conf/[enginename]/[hostname]/ directory. The context path and version will be derived from the base name of the file (the file name less the .xml extension). This file will always take precedence over any context.xml file packaged in the web application’s META-INF directory. 意思就是：在tomcat服务器的\conf\Catalina\localhost目录下添加一个以xml作为扩展名的文件，xml文件的名字可以任意取，比如下面的aa.xml，注意这一句话”The context path and version will be derived from the base name of the file“，这一句话的意思翻译过来就是”context元素的path属性源自于是这个xml文件的名字”，上面提到过，Context元素的path属性是用来配置虚似目录的名称的，所以虚似目录的名称就是这个xml文件的名称。 $CATALINA_BASE指的就是tomcat服务器根目录，[enginename]指的是Tomcat服务器使用的引擎名称，Tomcat使用的引擎是Catalina 在aa.xml文件中添加Context元素映射JavaWeb应用，代码如下： 11 &lt;Context docBase=&quot;F:\JavaWebDemoProject&quot; /&gt; 注意：在Context元素中并没有指明path属性来设置虚拟目录的名称，那么”F:\JavaWebDemoProject”映射的虚拟目录名称是神马呢，就是当前正在编辑的这个xml文件的名称aa。 使用这种方式映射虚拟目录的最大好处是修改了配置文件后不用重启Tomcat服务器，比如将aa.xml修改成bb.xml，Tomcat服务器会自动Undeploying context [/aa]，然后自动信息: Deploying configuration descriptor D:\apache-tomcat-7.0.53\conf\Catalina\localhost\bb.xml 三、Tomcat服务器配置虚似主机3.1、配置虚拟主机 配置虚似主机就是配置一个网站。 在Tomcat服务器配置一个虚拟主机(网站)，需要修改conf文件夹下的server.xml这个配置文件，使用Host元素进行配置，打开server.xml，可以看到Tomcat服务器自带的一个名称为localhost的虚拟主机(网站)，如下图所示： 平时我们将开发好的JavaWeb应用放到webapps文件夹下，然后就可以使用”http://localhost:端口号/JavaWebAppName“的方式去访问了，其实访问的就是name是”localhost”的那台虚拟主机(Host)，这台虚拟主机管理webapps文件夹下的所有web应用。 例如：http://localhost:8080/JavaWebDemoProject/1.jsp，这个URL地址访问的就是名称是localhost的那台虚拟主机下的JavaWebDemoProject这个应用里面的1.jsp这个web资源。 我们可以使用如下的方式配置一个虚拟主机，例如： 123&lt;Host name=&quot;www.gacl.cn&quot; appBase=&quot;F:\JavaWebApps&quot;&gt; &lt;/Host&gt; 这里我们新配置一个虚拟主机，虚拟主机的name是”www.gacl.cn”，虚拟主机”www.gacl.cn”现在管理着JavaWebApps文件夹下的所有web应用，平时我们在互联网上使用域名”www.baidu.com”访问百度的网站时，其实就是在访问一个名称是”www.baidu.com”的虚拟主机，所以当我们要访问name是”www.gacl.cn”的这个虚拟主机时，就可以使用”域名(www.gacl.cn)”去访问，注意一下appBase=”F:\JavaWebApps”，这里的JavaWebApps文件夹代表的不是一个项目的根目录，而是一个存放了一个或者多个JavaWeb应用的文件夹，如下图所示： 就好像是Tomcat服务器的webapps文件夹一样，里面存放了很多的JavaWeb应用 3.2、windows系统中注册域名 配置的主机(网站)要想通过域名被外部访问，必须在DNS服务器或windows系统中注册访问网站时使用的域名，找到”C:\Windows\System32\drivers\etc“目录下的hosts文件，如下图所示： 编辑这个文件，将新添加的网站的域名和IP地址绑定在一起，这样我们就可以在浏览器中使用www.gacl.cn这个域名去访问name是www.gacl.cn那个虚拟主机里面管理的那些web应用了 使用浏览器通过域名”www.gacl.cn”访问”www.gacl.cn”这个虚拟主机下的JavaWebDemo1这个web应用下的1.jsp这个web资源，”www.gacl.cn”这个虚拟主机开放了一个8080端口，用户只能通过这个8080端口去访问JavaWebDemo1这个web应用下的1.jsp这个web资源 四、浏览器与服务器交互的过程4.1、浏览器与服务器交互图 当我们打开浏览器，在浏览器的地址栏中输入URL地址”http://www.gacl.cn:8080/JavaWebDemo1/1.jsp&quot;去访问服务器上的1.jsp这个web资源的过程中，浏览器和服务器都做了神马操作呢，我们是怎么在浏览器里面看到1.jsp这个web资源里面的内容的呢？ 浏览器和服务器做了以下几个操作： 1、浏览器根据主机名”www.gacl.cn”去操作系统的Hosts文件中查找主机名对应的IP地址。 2、浏览器如果在操作系统的Hosts文件中没有找到对应的IP地址，就去互联网上的DNS服务器上查找”www.gacl.cn”这台主机对应的IP地址。 3、浏览器查找到”www.gacl.cn”这台主机对应的IP地址后，就使用IP地址连接到Web服务器。 4、浏览器连接到web服务器后，就使用http协议向服务器发送请求，发送请求的过程中，浏览器会向Web服务器以Stream(流)的形式传输数据，告诉Web服务器要访问服务器里面的哪个Web应用下的Web资源，如下图所示： 这就是浏览器向Web服务器发请求时向服务器传输的数据，解释一下”GET /JavaWebDemo1/1.jsp HTTP/1.1“这里面的内容， GET：告诉Web服务器，浏览器是以GET的方式向服务器发请求。 /JavaWebDemo1/1.jsp：告诉Web服务器，浏览器要访问JavaWebDemo1应用里面的1.jsp这个Web资源。 HTTP/1.1：告诉Web服务器，浏览器是以HTTP协议请求的，使用的是1.1的版本。 5、浏览器做完上面4步工作后，就开始等待，等待Web服务器把自己想要访问的1.jsp这个Web资源传输给它。 6、服务器接收到浏览器传输的数据后，开始解析接收到的数据，服务器解析”GET /JavaWebDemo1/1.jsp HTTP/1.1“里面的内容时知道客户端浏览器要访问的是JavaWebDemo1应用里面的1.jsp这个Web资源，然后服务器就去读取1.jsp这个Web资源里面的内容，将读到的内容再以Stream(流)的形式传输给浏览器，如下图所示： 这个就是Web服务器传输给浏览器的数据。 7、浏览器拿到服务器传输给它的数据之后，就可以把数据展现给用户看了，如下图所示： 看到的这个”JavaWebDemo1”就是浏览器解析服务器发送回来的数据后的效果 服务器发送回来的数据： ;) 123456789101112131415 HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Content-Type: text/html;charset=ISO-8859-1 Content-Length: 102 Date: Mon, 19 May 2014 14:25:14 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;JavaWebDemo1&lt;/title&gt; &lt;/head&gt; &lt;body&gt; JavaWebDemo1 &lt;/body&gt;&lt;/html&gt; ;) 这就是浏览器和服务器的交互过程。 五、JavaWeb应用的组成结构 开发JavaWeb应用时，不同类型的文件有严格的存放规则，否则不仅可能会使web应用无法访问，还会导致web服务器启动报错 WebRoot →Web应用所在目录，一般情况下虚拟目录要配置到此文件夹当中。 ┝WEB-INF：此文件夹必须位于**WebRoot文件夹里面，而且必须以这样的形式去命名，字母都要大写。** ┝web.xml：配置文件，有格式要求，此文件必须以这样的形式去命名，并且必须放置到**WEB-INF文件夹中。** web.xml的格式可以直接从Tomcat中参考得到：找到Tomcat目录下的webapps\ROOT\WEB-INF这个目录下的web.xml文件，把这个文件拷贝到我们新建的WEB-INF文件夹中，并修改这个web.xml文件，把里面的注释删除掉，只留下如下所示的代码即可： web.xml : 123456789101112 &lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt; &lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; version=&quot;2.5&quot;&gt; &lt;display-name&gt;Welcome to Tomcat&lt;/display-name&gt; &lt;description&gt; Welcome to Tomcat &lt;/description&gt;&lt;/web-app&gt; 这就是web.xml这个文件的格式]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(一)--JavaWeb开发入门]]></title>
    <url>%2F2017%2F06%2F27%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B8%80-JavaWeb%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 一.基本概念1.1、WEB开发相关知识WEB，在英语中web即表示网页的意思，它用于表示Internet主机上供外界访问的资源。 Internet上供外界访问的Web资源分为： 静态web资源（如html 页面）：指web页面中供人们浏览的数据始终是不变。 动态web资源：指web页面中供人们浏览的数据是由程序产生的，不同时间点访问web页面看到的内容各不相同。 静态web资源开发技术：Html 常用动态web资源开发技术：JSP/Servlet、ASP、PHP等 在Java中，动态web资源开发技术统称为Javaweb。 1.2、WEB应用程序 WEB应用程序指供浏览器访问的程序，通常也简称为web应用。例如有a.html 、b.html…..多个web资源，这多个web资源用于对外提供服务，此时应把这多个web资源放在一个目录中，以组成一个web应用（或web应用程序） 一个web应用由多个静态web资源和动态web资源组成，如:html、css、js文件，Jsp文件、java程序、支持jar包、配置文件等等。 Web应用开发好后，若想供外界访问，需要把web应用所在目录交给web服务器管理，这个过程称之为虚似目录的映射 1.3、WEB发展史 WEB发展的两个阶段：静态、动态 1.4、静态WEB htm、html，这些是网页的后缀，如果现在在一个服务器上直接读取这些内容，那么意味着是把这些网页的内容通过网络服务器展现给用户。整个静态WEB操作的过程图如下： 在静态WEB程序中，客户端使用WEB浏览器（IE、FireFox等）经过网络(Network)连接到服务器上，使用HTTP协议发起一个请求（Request），告诉服务器我现在需要得到哪个页面，所有的请求交给WEB服务器，之后WEB服务器根据用户的需要，从文件系统（存放了所有静态页面的磁盘）取出内容。之后通过WEB服务器返回给客户端，客户端接收到内容之后经过浏览器渲染解析，得到显示的效果。 静态WEB中存在以下几个缺点： 1、Web页面中的内容无法动态更新，所有的用户每时每刻看见的内容和最终效果都是一样的。 为了可以让静态的WEB的显示更加好看，可以加入了JavaScript以完成一些页面上的显示特效，但是这些特效都是在客户端上借助于浏览器展现给用户的，所以在服务器上本身并没有任何的变化。 实现静态WEB客户端动态效果的手段： JavaScript VBScript 在实际的开发中JavaScript使用得最多。 2、静态WEB无法连接数据库，无法实现和用户的交互。 使用数据库保存数据是现在大多数系统的选择，因为数据库中可以方便地管理数据，增删改查操作可以使用标准的SQL语句完成。 1.5、动态WEB 所谓的动态不是指页面会动，主要的特性的是：“WEB的页面展示效果因时因人而变”，而且动态WEB具有交互性，WEB的页面的内容可以动态更新。整个动态WEB操作的过程图如下： 动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器（IE、FireFox等），通过网络(Network)连接到服务器上，使用HTTP协议发起请求（Request），现在的所有请求都先经过一个WEB Server Plugin（服务器插件）来处理，此插件用于区分是请求的是静态资源(.htm或者是.htm)还是动态资源。 如果WEB Server Plugin发现客户端请求的是静态资源(.htm或者是.htm)，则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。 如果WEB Server Plugin发现客户端请求的是动态资源（.jsp、.asp/.aspx、.php），则先将请求转交给WEB Container(WEB容器)，在WEB Container中连接数据库，从数据库中取出数据等一系列操作后动态拼凑页面的展示内容，拼凑页面的展示内容后，把所有的展示内容交给WEB服务器，之后通过WEB服务器将内容发送回客户端浏览器进行解析执行。 1.6、动态WEB应用的实现手段 动态WEB现在的实现手段非常多，较为常见的有以下几种： Microsoft ASP、ASP.NET PHP JAVA Servlet/JSP 1、Microsoft ASP、ASP.NET 微软公司动态WEB开发是比较早的，而且最早在国内最流行的是ASP。ASP就是在HTML语言之中增加了VB脚本，但是标准的开发应用应该是使用ASP+COM，但是实际情况来看，在开发ASP的时候基本上都在一个页面中写上成百上千的代码，页面代码极其混乱。 ASP本身有开发平台的限制：Windows+IIS+SQL Server/Access，ASP只能运行在Windows操作系统上，ASP现在基本上已经淘汰，现在基本上都是使用ASP.NET进行开发，ASP.NET在性能有了很大的改善，而且开发迅速，但是依然受限于平台。ASP.NET中主要是使用C#语言。 2.PHP PHP开发速度很快，功能强大，跨平台(平台指的就是运行的操作系统)，而且代码也简单。 3.Servlet/JSP 这是SUN公司(SUN现在已经被Oracle公司收购)主推的B/S架构的实现语言，是基于JAVA语言发展起来的，因为JAVA语言足够简单，而且很干净。 Servlet/JSP技术的性能也是非常高的，不受平台的限制，各个平台基本上都可以使用。而且在运行中是使用多线程的处理方式，所以性能非常高。 SUN公司最早推出的WEB技术推出的是Servlet程序，Servlet程序本身使用的时候有一些问题，所有的程序是采用JAVA代码+HTML的方式编写的，即，要使用JAVA输出语句，一行一行地输出所有的HTML代码，之后，SUN公司受到了ASP的启发，发展出了JSP(Java Server Page)，JSP某些代码的编写效果与ASP是非常相似的。这样可以很方便地使一些ASP程序员转向JSP的学习，加大市场的竞争力度。 二、WEB服务器2.1、WEB服务器简介 1、Web服务器是指驻留于因特网上某种类型计算机的程序，是可以向发出请求的浏览器提供文档的程序。当Web浏览器（客户端）连到服务器上并请求文件时，服务器将处理该请求并将文件反馈到该浏览器上，附带的信息会告诉浏览器如何查看该文件（即文件类型）。 2、服务器是一种被动程序：只有当Internet上运行在其他计算机中的浏览器发出请求时，服务器才会响应。 2.2、常见的Web服务器介绍 1、WebLogic WebLogic是美国bea公司出品的一个application server。BEA WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。是目前应用最广泛的Web服务器，支持J2EE规范，而且不断的完善以适应新的开发要求，启动界面如图 2、WebSphere WebSphere Application Server 是一种功能完善、开放的Web应用程序服务器，是IBM公司电子商务计划的核心部分，它是基于 Java 的应用环境，用于建立、部署和管理 Internet 和 Intranet Web 应用程序。这一整套产品进行了扩展，以适应 Web应用程序服务器的需要，范围从简单到高级直到企业级。启动界面如图： 3、Tomcat TomcatTomcat是一个实现了JAVA EE标准的最小的WEB服务器，是Apache 软件基金会的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。因为Tomcat 技术先进、性能稳定，而且开源免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。学习JavaWeb开发一般都使用Tomcat服务器，该服务器支持全部JSP以及Servlet规范，启动界面如图： 4、IIS Microsoft的Web服务器产品为Internet Information Services （IIS），IIS 是允许在公共Intranet或Internet上发布信息的Web服务器。ⅡS是目前最流行的Web服务器产品之一，很多著名的网站都是建立在ⅡS的平 台上。IIS提供了一个图形界面的管理工具，称为Internet信息服务管理器，可用于监视配置和控制Internet服务。 IIS是一种Web服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供ISAPI(Intranet Server API）作为扩展Web服务器功能的编程接口；同时，它还提供一个Internet数据库连接器，可以实现对数据库的查询和更新。 学习web开发，需要先安装一台web服务器，然后再在web服务器中开发相应的web资源，供用户使用浏览器访问。 三、搭建JavaWeb应用开发环境——Tomcat服务器3.1、疑问：学习web开发，为什么必须要先装一个WEB服务器？ 在本地计算机上随便创建一个web页面，用户是无法访问到的，但是如果启动tomcat服务器，把web页面放在tomcat服务器中，用户就可以访问了。这说明什么问题？ 1、不管什么web资源，想被远程计算机访问，都必须有一个与之对应的网络通信程序，当用户来访问时，这个网络通信程序读取web资源数据，并把数据发送给来访者。 2、WEB服务器就是这样一个程序，它用于完成底层网络通迅。使用这些服务器，We应用的开发者只需要关注web资源怎么编写，而不需要关心资源如何发送到客户端手中，从而极大的减轻了开发者的开发工作量。 3.2、下载和安装Tomcat服务器 Tomcat官方站点：http://jakarta.apache.org 下载Tomcat安装程序包：http://tomcat.apache.org/ 点击【Download】跳转到如下图所示的下载页面 tar.gz文件是Linux操作系统下的安装版本 exe文件是Windows系统下的安装版本 zip文件是Windows系统下的压缩版本 下载完成后，得到的是一个压缩包，将压缩包解压就可以完成Tomcat服务器的安装 将压缩包解压后，得到的就是如下图所示的文件夹，这样就完成了Tomcat服务器的安装。 3.3、启动和测试Tomcat服务器 启动Tomcat服务器 双击 bin 目录下的 startup.bat 文件启动Tomcat服务器 测试Tomcat服务器 打开浏览器，输入http://localhost:8080/，能显示如下界面代表安装成功。 3.4、Tomcat启动常见问题 导致Tomcat服务器无法正常启动的原因一般来说就是如下的两个： 1、JAVA_HOME环境变量设置问题 要想双击bin目录下的startup.bat文件启动Tomcat服务器，首先要做的就是在windows中设置JAVA_HOME环境变量，因为Tomcat服务器的启动需要用到这个JAVA_HOME环境变量，如果windows中不存在JAVA_HOME环境变量，则Tomcat服务器是无法启动的。 在Window中配置JAVA_HOME变量 操作步骤(win7系统)：计算机→右键“属性”→高级系统设置→高级→环境变量，如下图所示： 点击系统变量下面的“【新建】”，弹出一个新建系统变量对话框，首先在变量名写上JAVA_HOME，顾名思义，JAVA_HOME的含义就是JDK的安装路径，，然后在变量值写JDK的安装路径，如这里设置的变量值是”D:\Program Files (x86)\Java\jdk1.7.0“，设置好变量值之后，点击【确定】按钮，JAVA_HOME环境变量就设置完成，如下图所示：系统变量中多了一个”JAVA_HOME”变量。 正常来说，学习Java开发的第一步就是配置Path环境变量，比较好的配置方式是先配置JAVA_HOME环境变量，然后在Path变量中使用”%JAVA_HOME%“引用JAVA_HOME变量的值。 所以这个JAVA_HOME环境变量在Window中一般都是已经配置好了的，如果忘记配置JAVA_HOME环境变量，那么可以使用上述的方式配置 2、端口占用问题 因为Tomcat服务器启动时是需要默认是使用8080端口的，如果这个8080端口被别的应用程序占用了，那么Tomcat服务器就无法正常启动，看到的现象就是”Tomcat服务器启动界面会打印出异常错误信息，然后就自动关闭了”，如下图所示： 由于这个窗口从启动到关闭的时间非常短，我们很难通过这个窗口看到Tomcat启动时的报错异常信息，因此我们一般只能通过Tomcat服务器的记录的log(日志)信息去查看Tomcat服务器的运行情况。 在Tomcat服务器的根目录下有一个logs文件夹， logs文件夹存放Tomcat 的日志文件，打开logs文件夹，可以看到里面的log文件，其中有一个以”catalina.yyyy-MM-dd.log“形式命名的log文件，例如”catalina.2014-05-17.log”日志文件就是记录Tomcat服务器2014-05-17这一天的运行情况。 打开catalina.2014-05-17.log文件，看看里面的日志记录信息， 日志信息里面清楚的记录了Tomcat服务器的运行情况，如果因为8080端口被占用而无法正常启动，就会记录如上图所示的异常信息，通过查看异常信息，我们就可知道Tomcat服务器为什么不能够正常启动了！ 总结：当Tomcat服务器无法正常启动时，首先检查是否配置了JAVA_HOME环境变量，然后再检查Tomcat服务器启动时的端口是否被别的应用程序占用了。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP获取绝对路径]]></title>
    <url>%2F2017%2F06%2F27%2FJSP%E8%8E%B7%E5%8F%96%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[在JavaWeb开发中，常使用绝对路径的方式来引入JavaScript和CSS文件，这样可以避免因为目录变动导致引入文件找不到的情况，常用的做法如下： 一、使用${pageContext.request.contextPath} 代码” ${pageContext.request.contextPath}”的作用是取出部署的应用程序名，这样不管如何部署，所用路径都是正确的。 例如： 123456&lt;!--使用绝对路径的方式引入CSS文件--&gt;&lt;link rel="stylesheet" href="$&#123;pageContext.request.contextPath&#125;/themes/default/css/ueditor.css" type="text/css"/&gt;&lt;!--使用绝对路径的方式引入JavaScript脚本--&gt;&lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath&#125;/ueditor1_3_6-gbk-jsp/ueditor.config.js"&gt;&lt;/script&gt; 使用&lt;%=request.getContextPath()%&gt;和使用${pageContext.request.contextPath}达到同样的效果 12&lt;script type="text/javascript" src="&lt;%=request.getContextPath()%&gt;/ueditor1_3_6-gbk-jsp/ueditor.all.js"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC将根目录文件夹的权限赋给用户]]></title>
    <url>%2F2017%2F06%2F26%2FMAC%E5%B0%86%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%9D%83%E9%99%90%E8%B5%8B%E7%BB%99%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[[TOC] 1、sudu -i进入root模式（需输入密码）2、chown -R 用户名 /文件夹名1234sudo -iPassword:shuaigedeMacBook-Pro:~ root# mkdir /interestingchown -R shuaige /interesting 用PHP写socket通讯时需要用到端口，有的时候关闭了服务器，但是端口还是占用，解决的方法是kill掉占用该端口的进程 命令行 lsof -i:9000 这里9000是我要释放的端口号 可以看到，该端口被id围11475的进程所占用，这个时候直接在命令行输入 kill 11475 该进程就中止了，端口成功过释放出来]]></content>
      <categories>
        <category>Util</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http常见的请求头和响应头]]></title>
    <url>%2F2017%2F06%2F26%2Fhttp%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[[TOC] 1.常见的HTTP请求头部 请求头部 说明 Accept-Charset 用于指定客户端接受的字符集 Accept-Encoding 用于指定可接受的内容编码，如Accept-Encoding:gzip,deflate Accept-Language 用于指定一种自然语言，如Accept-Language:zh-cn User-Agent 客户端将它的操作系统、浏览器和其他属性告诉服务器 Host 用于指定被请求资源的Internet主机和端口号,如Host:www.taobao.com Connection 当前连接是否保持，如Connection:Keep-Alive 2.常见的HTTP响应头 响应头部 说明 Server 使用的服务器名称，如Server:Apache/1.3.6(Unix) Content-Type 用来指明发送给接收者的实体正文的媒体类型，如Content-Type:text/html;charset=GBK Content-Encoding 与请求报头Accept-Encoding对应，告诉浏览器服务端采用什么压缩编码 Content-Langeage 描述资源所使用的自然语言 Content-Length 指明实体正文的长度，用以字节方式存储的十进制数字表示 Keep-Alive 保持连接的时间，如Keep-Alive:timeout=5,max=120 3.常见的HTTP状态码 状态码 说明 200 客户端请求成功 302 临时跳转，跳转地址使用Location指定 400 客户端请求有语法错误，不能被服务器识别 403 服务器接受到请求，但是拒绝提供服务 404 请求资源不存在 500 服务器发生不可预期的错误]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dbUnit使用]]></title>
    <url>%2F2017%2F06%2F08%2FdbUnit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[TOC] ​ DbUnit(http://dbunit.sourceforge.net/ )是专门针对数据库测试框架Junit的一个扩展。本文介绍了使用DbUnit工具让我们在使用Junit测试的时候，不会对数据库造成破坏。本文将会简单的介绍使用dbUnit进行备份和恢复数据操作。 使用DbUnit的步骤:(Maven方式) 1.添加maven依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;org.dbunit&lt;/groupId&gt; &lt;artifactId&gt;dbunit&lt;/artifactId&gt; &lt;version&gt;2.4.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt; 2.使用DbUnit进行插入测试数据a.创建测试数据(提供数据配置文件dataset.xml,其中t_user为表名，属性为列名)123&lt;dataset&gt; &lt;t_user id="1" username="admin" password="123" nickname="admin_123"/&gt;&lt;/dataset&gt; b.创建DbUnit的连接信息(这个连接获取需要依赖项目的连接)1234567891011121314151617181920212223242526272829303132333435363738394041public class DbUtil &#123; private static final String url = "jdbc:mysql://127.0.0.1:3306/db_junit?useUnicode=true" + "&amp;characterEncoding=UTF-8"; private static final String username = "root"; private static final String password = "root"; public static Connection getConnection() throws SQLException &#123; Connection conn = DriverManager.getConnection(url, username, password); return conn; &#125; public static void close(Connection conn) &#123; try &#123; if (conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static void close(PreparedStatement ps) &#123; try &#123; if (ps != null) ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static void close(ResultSet rs) &#123; try &#123; if (rs != null) rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class TestDbUnit &#123; @Test public void testDbUnit() throws SQLException, DatabaseUnitException &#123; //1.创建dbunit的connection IDatabaseConnection conn = new DatabaseConnection(DbUtil.getConnection()); //2.获取配置的数据 IDataSet ds = new FlatXmlDataSet(new FlatXmlProducer(new InputSource(TestDbUnit.class .getResourceAsStream("/dataset.xml")))); //3.清空数据库,将测试数据添加进去 DatabaseOperation.CLEAN_INSERT.execute(conn,ds); &#125; //备份所有的数据 @Test public void testBackUpAllData() throws SQLException, DatabaseUnitException, IOException &#123; //1.获取dbunit的连接 IDatabaseConnection conn = new DatabaseConnection(DbUtil.getConnection()); //2.获取数据库中的所有的数据 IDataSet ds = conn.createDataSet(); //3.将dataset数据写入到一个文件中 FlatXmlDataSet.write(ds,new FileWriter("backUp.xml")); &#125; //备份部分表 @Test public void testBackUpSomeTable() throws SQLException, DatabaseUnitException, IOException &#123; IDatabaseConnection conn = new DatabaseConnection(DbUtil.getConnection()); //创建查询的dataset QueryDataSet queryDataSet = new QueryDataSet(conn); queryDataSet.addTable("t_user"); FlatXmlDataSet.write(queryDataSet,new FileWriter("backUp.xml")); &#125; //测试恢复 @Test public void testResume() throws SQLException, DatabaseUnitException &#123; IDatabaseConnection conn = new DatabaseConnection(DbUtil.getConnection()); IDataSet ds = new FlatXmlDataSet(new FlatXmlProducer(new InputSource("backUp.xml"))); DatabaseOperation.CLEAN_INSERT.execute(conn,ds); &#125;&#125; ​]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>dbUnit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown简介]]></title>
    <url>%2F2017%2F01%2F17%2FMarkdown%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[[TOC] Markdown简介 Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成各式丰富的HTML页面。–维基百科 图片1![描述](example.jpg) 笔记本1@(笔记本)［标签1，标签2，标签3］ 标题123标题一 标题二======= ----------## 标题二 ###### 标题六 列表121.有序列表 -无序列表 -[] 复选框2.有序列表 -无序列表 -[x] 复选框 引用12&gt; 这是引用的文字&gt; 引用内可以嵌套标题、列表等 代码1234这是一句行内代码｀var a = 1｀,以下是代码区块：&apos;&apos;&apos;rubyprint &apos;Hello world&apos;&apos;&apos;&apos; laTex公式12这是一句行内公式 $ y = x + 1 $,以下为整行公式：$$ a^2 + b^2 = c^2 $$ 表格123|Item | Value| Qty||:-------|--------:|:---:||Computer|1600 USD| 5|]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>